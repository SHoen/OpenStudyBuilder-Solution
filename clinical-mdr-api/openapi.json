{"openapi": "3.0.2", "info": {"title": "Clinical MDR API", "description": "\n## NOTICE\n\nThis license information is applicable to the swagger documentation of the clinical-mdr-api, that is the openapi.json.\n\n## License Terms (MIT)\n\nCopyright (C) 2022 Novo Nordisk A/S, Danish company registration no. 24256790\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n## Licenses and Acknowledgements for Incorporated Software\n\nThis component contains software licensed under different licenses when compiled, please refer to the third-party-licenses.md file for further information and full license texts.\n\n## Authentication:\n\nSupports OAuth2 [Authorization Code Flow](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1),\nat paths described in the [OpenID Connect Discovery metadata document](None).\nMicrosoft Identity Platform\n([documentation](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow)).\n\nAuthentication can be turned off with `OAUTH_ENABLED=false` environment variable. When Authentication is turned on, all \nAPI requests have to provide valid bearer (JWT) token. When turned off\nall endpoints accept (optional) custom header `X-Test-User-Id` which \nallows any request to inject any user id value (for testing purposes). If the header is missing, the default value \nof `unknown-user` is assumed.\n\n    ", "version": "1.0"}, "paths": {"/concepts/odms/templates": {"get": {"tags": ["ODM Templates"], "summary": "Return every variable related to the selected status and version of the ODM Templates", "operationId": "get_all_odm_templates_concepts_odms_templates_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmTemplate_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["ODM Templates"], "summary": "Creates a new Template in 'Draft' status with version 0.1", "operationId": "create_odm_template_concepts_odms_templates_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmTemplatePostInput"}}}}, "responses": {"201": {"description": "Created - The odm item was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/templates/headers": {"get": {"tags": ["ODM Templates"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_templates_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Templates Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/templates/{uid}": {"get": {"tags": ["ODM Templates"], "summary": "Get details on a specific ODM Template (in a specific version)", "operationId": "get_odm_template_concepts_odms_templates__uid__get", "parameters": [{"description": "The unique id of the ODM Template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Template."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmTemplate"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["ODM Templates"], "summary": "Delete draft version of ODM Template", "operationId": "delete_odm_template_concepts_odms_templates__uid__delete", "parameters": [{"description": "The unique id of the ODM Template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Template."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM Template was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Template is not in draft status.\n- The ODM Template was already in final state or is in use.\n- The library does not allow to delete ODM Template.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM Template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["ODM Templates"], "summary": "Update odm item", "operationId": "edit_odm_template_concepts_odms_templates__uid__patch", "parameters": [{"description": "The unique id of the ODM Template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Template."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmTemplatePatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Template is not in draft status.\n- The ODM Template had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/templates/{uid}/relationships": {"get": {"tags": ["ODM Templates"], "summary": "Get UIDs of a specific ODM Template's relationships", "operationId": "get_active_relationships_concepts_odms_templates__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM Template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Template."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Templates  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/templates/{uid}/versions": {"get": {"tags": ["ODM Templates"], "summary": "List version history for ODM Templates", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM Templates.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_template_versions_concepts_odms_templates__uid__versions_get", "parameters": [{"description": "The unique id of the ODM Template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Template."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Template Versions Concepts Odms Templates  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmTemplate"}}}}}, "404": {"description": "Not Found - The ODM Template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/templates/{uid}/new-version": {"post": {"tags": ["ODM Templates"], "summary": " Create a new version of ODM Template", "description": "\nState before:\n - uid must exist and the ODM Template must be in status Final.\n\nBusiness logic:\n- The ODM Template is changed to a draft state.\n\nState after:\n - ODM Template changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_template_version_concepts_odms_templates__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM Template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Template."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM Templates.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM Template is not in final status.\n- The ODM Template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/templates/{uid}/approve": {"post": {"tags": ["ODM Templates"], "summary": "Approve draft version of ODM Template", "operationId": "approve_odm_template_concepts_odms_templates__uid__approve_post", "parameters": [{"description": "The unique id of the ODM Template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Template."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Template is not in draft status.\n- The library does not allow to approve ODM Template.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/templates/{uid}/inactivate": {"post": {"tags": ["ODM Templates"], "summary": " Inactivate final version of ODM Template", "operationId": "inactivate_odm_template_concepts_odms_templates__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM Template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Template."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Template is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/templates/{uid}/reactivate": {"post": {"tags": ["ODM Templates"], "summary": "Reactivate retired version of a ODM Template", "operationId": "reactivate_odm_template_concepts_odms_templates__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM Template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Template."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Template is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/templates/{uid}/add-forms": {"post": {"tags": ["ODM Templates"], "summary": "Adds forms to the ODM Template.", "operationId": "add_forms_to_odm_template_concepts_odms_templates__uid__add_forms_post", "parameters": [{"description": "The unique id of the ODM Template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Template."}, "name": "uid", "in": "path"}, {"description": "If true, all existing form relationships will be replaced with the provided form relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing form relationships will be replaced with the provided form relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Template Form Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmTemplateFormPostInput"}}}}}, "responses": {"201": {"description": "Created - The forms were successfully added to the ODM Template.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The forms with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms": {"get": {"tags": ["ODM Forms"], "summary": "Return every variable related to the selected status and version of the ODM Forms", "operationId": "get_all_odm_forms_concepts_odms_forms_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmForm_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/headers": {"get": {"tags": ["ODM Forms"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_forms_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Forms Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}": {"get": {"tags": ["ODM Forms"], "summary": "Get details on a specific ODM Form (in a specific version)", "operationId": "get_odm_form_concepts_odms_forms__uid__get", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["ODM Forms"], "summary": "Delete draft version of ODM Form", "operationId": "delete_odm_form_concepts_odms_forms__uid__delete", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM Form was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Form is not in draft status.\n- The ODM Form was already in final state or is in use.\n- The library does not allow to delete ODM Form.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM Form with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/relationships": {"get": {"tags": ["ODM Forms"], "summary": "Get UIDs of a specific ODM Form's relationships", "operationId": "get_active_relationships_concepts_odms_forms__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Forms  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/versions": {"get": {"tags": ["ODM Forms"], "summary": "List version history for ODM Forms", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM Forms.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_form_versions_concepts_odms_forms__uid__versions_get", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Form Versions Concepts Odms Forms  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmForm"}}}}}, "404": {"description": "Not Found - The ODM Form with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/select": {"post": {"tags": ["ODM Forms"], "summary": "Creates a new Form in 'Draft' status with version 0.1", "operationId": "create_odm_form_concepts_odms_forms_select_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormPostInput"}}}}, "responses": {"201": {"description": "Created - The odm form was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/create": {"post": {"tags": ["ODM Forms"], "summary": "Creates an ODM Form with relationships", "operationId": "create_odm_form_with_relations_concepts_odms_forms_create_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormWithRelationsPostInput"}}}}, "responses": {"201": {"description": "Created - The odm form was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/select": {"patch": {"tags": ["ODM Forms"], "summary": "Update odm form", "operationId": "edit_odm_form_concepts_odms_forms__uid__select_patch", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Form is not in draft status.\n- The ODM Form had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Form with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/update": {"patch": {"tags": ["ODM Forms"], "summary": "Updates an ODM Form with relationships", "operationId": "edit_odm_form_with_relations_concepts_odms_forms__uid__update_patch", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormWithRelationsPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Form is not in draft status.\n- The ODM Form had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Form with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/new-version": {"post": {"tags": ["ODM Forms"], "summary": " Create a new version of ODM Form", "description": "\nState before:\n - uid must exist and the ODM Form must be in status Final.\n\nBusiness logic:\n- The ODM Form is changed to a draft state.\n\nState after:\n - ODM Form changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_form_version_concepts_odms_forms__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM Forms.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM Form is not in final status.\n- The ODM Form with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/approve": {"post": {"tags": ["ODM Forms"], "summary": "Approve draft version of ODM Form", "operationId": "approve_odm_form_concepts_odms_forms__uid__approve_post", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Form is not in draft status.\n- The library does not allow to approve ODM Form.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Form with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/inactivate": {"post": {"tags": ["ODM Forms"], "summary": " Inactivate final version of ODM Form", "operationId": "inactivate_odm_form_concepts_odms_forms__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Form is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Form with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/reactivate": {"post": {"tags": ["ODM Forms"], "summary": "Reactivate retired version of a ODM Form", "operationId": "reactivate_odm_form_concepts_odms_forms__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Form is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Form with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/add-activity-groups": {"post": {"tags": ["ODM Forms"], "summary": "Adds activity groups to the ODM Form.", "operationId": "add_activity_groups_to_odm_form_concepts_odms_forms__uid__add_activity_groups_post", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}, {"description": "If true, all existing activity group relationships will be replaced with the provided activity group relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing activity group relationships will be replaced with the provided activity group relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Form Activity Group Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmFormActivityGroupPostInput"}}}}}, "responses": {"201": {"description": "Created - The activity groups were successfully added to the ODM Form.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity groups with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/add-item-groups": {"post": {"tags": ["ODM Forms"], "summary": "Adds item groups to the ODM Form.", "operationId": "add_item_groups_to_odm_form_concepts_odms_forms__uid__add_item_groups_post", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}, {"description": "If true, all existing item group relationships will be replaced with the provided item group relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing item group relationships will be replaced with the provided item group relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Form Item Group Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmFormItemGroupPostInput"}}}}}, "responses": {"201": {"description": "Created - The item groups were successfully added to the ODM Form.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The item groups with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/add-xml-extension-tags": {"post": {"tags": ["ODM Forms"], "summary": "Adds xml extension tags to the ODM Form.", "operationId": "add_xml_extension_tags_to_odm_form_concepts_odms_forms__uid__add_xml_extension_tags_post", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}, {"description": "If true, all existing xml extension tag relationships will be replaced with the provided xml extension tag relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing xml extension tag relationships will be replaced with the provided xml extension tag relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Xml Extension Relation Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionRelationPostInput"}}}}}, "responses": {"201": {"description": "Created - The xml extension tags were successfully added to the ODM Form.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The xml extension tags with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/add-xml-extension-attributes": {"post": {"tags": ["ODM Forms"], "summary": "Adds xml extension attributes to the ODM Form.", "operationId": "add_xml_extension_attributes_to_odm_form_concepts_odms_forms__uid__add_xml_extension_attributes_post", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}, {"description": "If true, all existing xml extension attribute relationships will\n        be replaced with the provided xml extension attribute relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing xml extension attribute relationships will\n        be replaced with the provided xml extension attribute relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Xml Extension Relation Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionRelationPostInput"}}}}}, "responses": {"201": {"description": "Created - The xml extension attributes were successfully added to the ODM Form.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The xml extension attributes with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/forms/{uid}/add-xml-extension-tag-attributes": {"post": {"tags": ["ODM Forms"], "summary": "Adds xml extension tag attributes to the ODM Form.", "operationId": "add_xml_extension_tag_attributes_to_odm_form_concepts_odms_forms__uid__add_xml_extension_tag_attributes_post", "parameters": [{"description": "The unique id of the ODM Form.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Form."}, "name": "uid", "in": "path"}, {"description": "If true, all existing xml extension tag attribute relationships\n        will be replaced with the provided xml extension tag attribute relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing xml extension tag attribute relationships\n        will be replaced with the provided xml extension tag attribute relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Xml Extension Relation Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionRelationPostInput"}}}}}, "responses": {"201": {"description": "Created - The xml extension tag attributes were successfully added to the ODM Form.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmForm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The xml extension tag attributes with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups": {"get": {"tags": ["ODM Item Groups"], "summary": "Return every variable related to the selected status and version of the ODM Item Groups", "operationId": "get_all_odm_item_groups_concepts_odms_item_groups_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmItemGroup_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/headers": {"get": {"tags": ["ODM Item Groups"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_item_groups_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Item Groups Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}": {"get": {"tags": ["ODM Item Groups"], "summary": "Get details on a specific ODM Item Group (in a specific version)", "operationId": "get_odm_item_group_concepts_odms_item_groups__uid__get", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["ODM Item Groups"], "summary": "Delete draft version of ODM Item Group", "operationId": "delete_odm_item_group_concepts_odms_item_groups__uid__delete", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM Item Group was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item Group is not in draft status.\n- The ODM Item Group was already in final state or is in use.\n- The library does not allow to delete ODM Item Group.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM Item Group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/relationships": {"get": {"tags": ["ODM Item Groups"], "summary": "Get UIDs of a specific ODM Item Group's relationships", "operationId": "get_active_relationships_concepts_odms_item_groups__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Item Groups  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/versions": {"get": {"tags": ["ODM Item Groups"], "summary": "List version history for ODM Item Groups", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM Item Groups.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_item_group_versions_concepts_odms_item_groups__uid__versions_get", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Item Group Versions Concepts Odms Item Groups  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemGroup"}}}}}, "404": {"description": "Not Found - The ODM Item Group with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/select": {"post": {"tags": ["ODM Item Groups"], "summary": "Creates a new Item Group in 'Draft' status with version 0.1", "operationId": "create_odm_item_group_concepts_odms_item_groups_select_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroupPostInput"}}}}, "responses": {"201": {"description": "Created - The odm item group was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/create": {"post": {"tags": ["ODM Item Groups"], "summary": "Creates an ODM Item Group with relationships", "operationId": "create_odm_item_group_with_relations_concepts_odms_item_groups_create_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroupWithRelationsPostInput"}}}}, "responses": {"201": {"description": "Created - The odm item group was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/select": {"patch": {"tags": ["ODM Item Groups"], "summary": "Update odm item group", "operationId": "edit_odm_item_group_concepts_odms_item_groups__uid__select_patch", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroupPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item Group is not in draft status.\n- The ODM Item Group had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Item Group with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/update": {"patch": {"tags": ["ODM Item Groups"], "summary": "Updates an ODM Item Group with relationships", "operationId": "edit_odm_item_group_with_relations_concepts_odms_item_groups__uid__update_patch", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroupWithRelationsPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item Group is not in draft status.\n- The ODM Item Group had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Item Group with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/new-version": {"post": {"tags": ["ODM Item Groups"], "summary": " Create a new version of ODM Item Group", "description": "\nState before:\n - uid must exist and the ODM Item Group must be in status Final.\n\nBusiness logic:\n- The ODM Item Group is changed to a draft state.\n\nState after:\n - ODM Item Group changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_item_group_version_concepts_odms_item_groups__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM Item Groups.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM Item Group is not in final status.\n- The ODM Item Group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/approve": {"post": {"tags": ["ODM Item Groups"], "summary": "Approve draft version of ODM Item Group", "operationId": "approve_odm_item_group_concepts_odms_item_groups__uid__approve_post", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item Group is not in draft status.\n- The library does not allow to approve ODM Item Group.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Item Group with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/inactivate": {"post": {"tags": ["ODM Item Groups"], "summary": " Inactivate final version of ODM Item Group", "operationId": "inactivate_odm_item_group_concepts_odms_item_groups__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item Group is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Item Group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/reactivate": {"post": {"tags": ["ODM Item Groups"], "summary": "Reactivate retired version of a ODM Item Group", "operationId": "reactivate_odm_item_group_concepts_odms_item_groups__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item Group is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Item Group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/add-activity-sub-groups": {"post": {"tags": ["ODM Item Groups"], "summary": "Adds activity sub groups to the ODM Item Group.", "operationId": "add_activity_sub_groups_to_odm_item_group_concepts_odms_item_groups__uid__add_activity_sub_groups_post", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}, {"description": "If true, all existing activity sub group relationships will be replaced with the provided activity sub group relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing activity sub group relationships will be replaced with the provided activity sub group relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Item Group Activity Sub Group Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemGroupActivitySubGroupPostInput"}}}}}, "responses": {"201": {"description": "Created - The activity sub groups were successfully added to the ODM Item Group.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity sub groups with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/add-items": {"post": {"tags": ["ODM Item Groups"], "summary": "Adds items to the ODM Item Group.", "operationId": "add_item_to_odm_item_group_concepts_odms_item_groups__uid__add_items_post", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}, {"description": "If true, all existing item relationships will be replaced with the provided item relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing item relationships will be replaced with the provided item relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Item Group Item Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemGroupItemPostInput"}}}}}, "responses": {"201": {"description": "Created - The items were successfully added to the ODM Item Group.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The items with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/add-xml-extension-tags": {"post": {"tags": ["ODM Item Groups"], "summary": "Adds xml extension tags to the ODM Item Group.", "operationId": "add_xml_extension_tags_to_odm_item_group_concepts_odms_item_groups__uid__add_xml_extension_tags_post", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}, {"description": "If true, all existing xml extension tag relationships will be replaced with the provided xml extension tag relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing xml extension tag relationships will be replaced with the provided xml extension tag relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Xml Extension Relation Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionRelationPostInput"}}}}}, "responses": {"201": {"description": "Created - The xml extension tags were successfully added to the ODM Item Group.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The xml extension tags with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/add-xml-extension-attributes": {"post": {"tags": ["ODM Item Groups"], "summary": "Adds xml extension attributes to the ODM Item Group.", "operationId": "add_xml_extension_attributes_to_odm_item_group_concepts_odms_item_groups__uid__add_xml_extension_attributes_post", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}, {"description": "If true, all existing xml extension attribute relationships will\n        be replaced with the provided xml extension attribute relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing xml extension attribute relationships will\n        be replaced with the provided xml extension attribute relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Xml Extension Relation Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionRelationPostInput"}}}}}, "responses": {"201": {"description": "Created - The xml extension attributes were successfully added to the ODM Item Group.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The xml extension attributes with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/item-groups/{uid}/add-xml-extension-tag-attributes": {"post": {"tags": ["ODM Item Groups"], "summary": "Adds xml extension tag attributes to the ODM Item Group.", "operationId": "add_xml_extension_tag_attributes_to_odm_item_group_concepts_odms_item_groups__uid__add_xml_extension_tag_attributes_post", "parameters": [{"description": "The unique id of the ODM Item Group.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item Group."}, "name": "uid", "in": "path"}, {"description": "If true, all existing xml extension tag attribute relationships will\n        be replaced with the provided xml extension tag attribute relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing xml extension tag attribute relationships will\n        be replaced with the provided xml extension tag attribute relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Xml Extension Relation Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionRelationPostInput"}}}}}, "responses": {"201": {"description": "Created - The xml extension tag attributes were successfully added to the ODM Item Group.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The xml extension tag attributes with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items": {"get": {"tags": ["ODM Item"], "summary": "Return every variable related to the selected status and version of the ODM Items", "operationId": "get_all_odm_items_concepts_odms_items_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmItem_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/headers": {"get": {"tags": ["ODM Item"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_items_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Items Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}": {"get": {"tags": ["ODM Item"], "summary": "Get details on a specific ODM Item (in a specific version)", "operationId": "get_odm_item_concepts_odms_items__uid__get", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["ODM Item"], "summary": "Delete draft version of ODM Item", "operationId": "delete_odm_item_concepts_odms_items__uid__delete", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM Item was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item is not in draft status.\n- The ODM Item was already in final state or is in use.\n- The library does not allow to delete ODM Item.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM Item with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/relationships": {"get": {"tags": ["ODM Item"], "summary": "Get UIDs of a specific ODM Item's relationships", "operationId": "get_active_relationships_concepts_odms_items__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Items  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/versions": {"get": {"tags": ["ODM Item"], "summary": "List version history for ODM Items", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM Items.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_item_versions_concepts_odms_items__uid__versions_get", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Item Versions Concepts Odms Items  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmItem"}}}}}, "404": {"description": "Not Found - The ODM Item with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/select": {"post": {"tags": ["ODM Item"], "summary": "Creates a new Item in 'Draft' status with version 0.1", "operationId": "create_odm_item_concepts_odms_items_select_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemPostInput"}}}}, "responses": {"201": {"description": "Created - The odm item was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/create": {"post": {"tags": ["ODM Item"], "summary": "Creates an ODM Item with relationships", "operationId": "create_odm_item_with_relations_concepts_odms_items_create_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemWithRelationsPostInput"}}}}, "responses": {"201": {"description": "Created - The odm item was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/select": {"patch": {"tags": ["ODM Item"], "summary": "Update odm item", "operationId": "edit_odm_item_concepts_odms_items__uid__select_patch", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item is not in draft status.\n- The ODM Item had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Item with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/update": {"patch": {"tags": ["ODM Item"], "summary": "Updates an ODM Item with relationships", "operationId": "edit_odm_item_with_relations_concepts_odms_items__uid__update_patch", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItemWithRelationsPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item is not in draft status.\n- The ODM Item had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Item with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/new-version": {"post": {"tags": ["ODM Item"], "summary": " Create a new version of ODM Item", "description": "\nState before:\n - uid must exist and the ODM Item must be in status Final.\n\nBusiness logic:\n- The ODM Item is changed to a draft state.\n\nState after:\n - ODM Item changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_item_version_concepts_odms_items__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM Items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM Item is not in final status.\n- The ODM Item with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/approve": {"post": {"tags": ["ODM Item"], "summary": "Approve draft version of ODM Item", "operationId": "approve_odm_item_concepts_odms_items__uid__approve_post", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item is not in draft status.\n- The library does not allow to approve ODM Item.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Item with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/inactivate": {"post": {"tags": ["ODM Item"], "summary": " Inactivate final version of ODM Item", "operationId": "inactivate_odm_item_concepts_odms_items__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Item with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/reactivate": {"post": {"tags": ["ODM Item"], "summary": "Reactivate retired version of a ODM Item", "operationId": "reactivate_odm_item_concepts_odms_items__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Item is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Item with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/add-activities": {"post": {"tags": ["ODM Item"], "summary": "Adds activities to the ODM Item.", "operationId": "add_activities_to_odm_item_concepts_odms_items__uid__add_activities_post", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}, {"description": "If true, all existing activity relationships will be replaced with the provided activity relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing activity relationships will be replaced with the provided activity relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Item Activity Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemActivityPostInput"}}}}}, "responses": {"201": {"description": "Created - The activities were successfully added to the ODM Item.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activities with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/add-xml-extension-tags": {"post": {"tags": ["ODM Item"], "summary": "Adds xml extension tags to the ODM Item.", "operationId": "add_xml_extension_tags_to_odm_item_concepts_odms_items__uid__add_xml_extension_tags_post", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}, {"description": "If true, all existing xml extension tag relationships will be replaced with the provided xml extension tag relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing xml extension tag relationships will be replaced with the provided xml extension tag relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Xml Extension Relation Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionRelationPostInput"}}}}}, "responses": {"201": {"description": "Created - The xml extension tags were successfully added to the ODM Item.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The xml extension tags with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/add-xml-extension-attributes": {"post": {"tags": ["ODM Item"], "summary": "Adds xml extension attributes to the ODM Item.", "operationId": "add_xml_extension_attributes_to_odm_item_concepts_odms_items__uid__add_xml_extension_attributes_post", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}, {"description": "If true, all existing xml extension attribute relationships will\n        be replaced with the provided xml extension attribute relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing xml extension attribute relationships will\n        be replaced with the provided xml extension attribute relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Xml Extension Relation Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionRelationPostInput"}}}}}, "responses": {"201": {"description": "Created - The xml extension attributes were successfully added to the ODM Item.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The xml extension attributes with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/items/{uid}/add-xml-extension-tag-attributes": {"post": {"tags": ["ODM Item"], "summary": "Adds xml extension tag attributes to the ODM Item.", "operationId": "add_xml_extension_tag_attributes_to_odm_item_concepts_odms_items__uid__add_xml_extension_tag_attributes_post", "parameters": [{"description": "The unique id of the ODM Item.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Item."}, "name": "uid", "in": "path"}, {"description": "If true, all existing xml extension tag attribute relationships will\n        be replaced with the provided xml extension tag attribute relationships.", "required": false, "schema": {"title": "Override", "type": "boolean", "description": "If true, all existing xml extension tag attribute relationships will\n        be replaced with the provided xml extension tag attribute relationships.", "default": false}, "name": "override", "in": "query"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Odm Xml Extension Relation Post Input", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionRelationPostInput"}}}}}, "responses": {"201": {"description": "Created - The xml extension tag attributes were successfully added to the ODM Item.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmItem"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The xml extension tag attributes with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions": {"get": {"tags": ["ODM Conditions"], "summary": "Return every variable related to the selected status and version of the ODM Conditions", "operationId": "get_all_odm_conditions_concepts_odms_conditions_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmCondition_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/headers": {"get": {"tags": ["ODM Conditions"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_conditions_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Conditions Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/{uid}": {"get": {"tags": ["ODM Conditions"], "summary": "Get details on a specific ODM Condition (in a specific version)", "operationId": "get_odm_condition_concepts_odms_conditions__uid__get", "parameters": [{"description": "The unique id of the ODM Condition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Condition."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmCondition"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["ODM Conditions"], "summary": "Delete draft version of ODM Condition", "operationId": "delete_odm_condition_concepts_odms_conditions__uid__delete", "parameters": [{"description": "The unique id of the ODM Condition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Condition."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM Condition was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Condition is not in draft status.\n- The ODM Condition was already in final state or is in use.\n- The library does not allow to delete ODM Condition.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM Condition with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/{uid}/relationships": {"get": {"tags": ["ODM Conditions"], "summary": "Get UIDs of a specific ODM Condition's relationships", "operationId": "get_active_relationships_concepts_odms_conditions__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM Condition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Condition."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Conditions  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/{uid}/versions": {"get": {"tags": ["ODM Conditions"], "summary": "List version history for ODM Conditions", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM Conditions.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_condition_versions_concepts_odms_conditions__uid__versions_get", "parameters": [{"description": "The unique id of the ODM Condition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Condition."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Condition Versions Concepts Odms Conditions  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmCondition"}}}}}, "404": {"description": "Not Found - The ODM Condition with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/select": {"post": {"tags": ["ODM Conditions"], "summary": "Creates a new Condition in 'Draft' status with version 0.1", "operationId": "create_odm_condition_concepts_odms_conditions_select_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmConditionPostInput"}}}}, "responses": {"201": {"description": "Created - The odm condition was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmCondition"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/create": {"post": {"tags": ["ODM Conditions"], "summary": "Creates an ODM Condition with relationships", "operationId": "create_odm_condition_with_relations_concepts_odms_conditions_create_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmConditionWithRelationsPostInput"}}}}, "responses": {"201": {"description": "Created - The odm condition was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmCondition"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/{uid}/select": {"patch": {"tags": ["ODM Conditions"], "summary": "Update odm condition", "operationId": "edit_odm_condition_concepts_odms_conditions__uid__select_patch", "parameters": [{"description": "The unique id of the ODM Condition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Condition."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmConditionPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmCondition"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Condition is not in draft status.\n- The ODM Condition had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Condition with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/{uid}/update": {"patch": {"tags": ["ODM Conditions"], "summary": "Updates an ODM Condition with relationships", "operationId": "edit_odm_condition_with_relations_concepts_odms_conditions__uid__update_patch", "parameters": [{"description": "The unique id of the ODM Condition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Condition."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmConditionWithRelationsPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmCondition"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Condition is not in draft status.\n- The ODM Condition had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Condition with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/{uid}/new-version": {"post": {"tags": ["ODM Conditions"], "summary": " Create a new version of ODM Condition", "description": "\nState before:\n - uid must exist and the ODM Condition must be in status Final.\n\nBusiness logic:\n- The ODM Condition is changed to a draft state.\n\nState after:\n - ODM Condition changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_condition_version_concepts_odms_conditions__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM Condition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Condition."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmCondition"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM Conditions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM Condition is not in final status.\n- The ODM Condition with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/{uid}/approve": {"post": {"tags": ["ODM Conditions"], "summary": "Approve draft version of ODM Condition", "operationId": "approve_odm_condition_concepts_odms_conditions__uid__approve_post", "parameters": [{"description": "The unique id of the ODM Condition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Condition."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmCondition"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Condition is not in draft status.\n- The library does not allow to approve ODM Condition.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Condition with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/{uid}/inactivate": {"post": {"tags": ["ODM Conditions"], "summary": " Inactivate final version of ODM Condition", "operationId": "inactivate_odm_condition_concepts_odms_conditions__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM Condition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Condition."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmCondition"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Condition is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Condition with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/conditions/{uid}/reactivate": {"post": {"tags": ["ODM Conditions"], "summary": "Reactivate retired version of a ODM Condition", "operationId": "reactivate_odm_condition_concepts_odms_conditions__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM Condition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Condition."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmCondition"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Condition is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Condition with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods": {"get": {"tags": ["ODM Methods"], "summary": "Return every variable related to the selected status and version of the ODM Methods", "operationId": "get_all_odm_methods_concepts_odms_methods_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmMethod_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/headers": {"get": {"tags": ["ODM Methods"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_methods_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Methods Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/{uid}": {"get": {"tags": ["ODM Methods"], "summary": "Get details on a specific ODM Method (in a specific version)", "operationId": "get_odm_method_concepts_odms_methods__uid__get", "parameters": [{"description": "The unique id of the ODM Method.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Method."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethod"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["ODM Methods"], "summary": "Delete draft version of ODM Method", "operationId": "delete_odm_method_concepts_odms_methods__uid__delete", "parameters": [{"description": "The unique id of the ODM Method.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Method."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM Method was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Method is not in draft status.\n- The ODM Method was already in final state or is in use.\n- The library does not allow to delete ODM Method.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM Method with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/{uid}/relationships": {"get": {"tags": ["ODM Methods"], "summary": "Get UIDs of a specific ODM Method's relationships", "operationId": "get_active_relationships_concepts_odms_methods__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM Method.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Method."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Methods  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/{uid}/versions": {"get": {"tags": ["ODM Methods"], "summary": "List version history for ODM Methods", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM Methods.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_method_versions_concepts_odms_methods__uid__versions_get", "parameters": [{"description": "The unique id of the ODM Method.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Method."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Method Versions Concepts Odms Methods  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmMethod"}}}}}, "404": {"description": "Not Found - The ODM Method with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/select": {"post": {"tags": ["ODM Methods"], "summary": "Creates a new Method in 'Draft' status with version 0.1", "operationId": "create_odm_method_concepts_odms_methods_select_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethodPostInput"}}}}, "responses": {"201": {"description": "Created - The odm method was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethod"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/create": {"post": {"tags": ["ODM Methods"], "summary": "Creates an ODM Method with relationships", "operationId": "create_odm_method_with_relations_concepts_odms_methods_create_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethodWithRelationsPostInput"}}}}, "responses": {"201": {"description": "Created - The odm method was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethod"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/{uid}/select": {"patch": {"tags": ["ODM Methods"], "summary": "Update odm method", "operationId": "edit_odm_method_concepts_odms_methods__uid__select_patch", "parameters": [{"description": "The unique id of the ODM Method.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Method."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethodPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethod"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Method is not in draft status.\n- The ODM Method had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Method with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/{uid}/update": {"patch": {"tags": ["ODM Methods"], "summary": "Updates an ODM Method with relationships", "operationId": "edit_odm_method_with_relations_concepts_odms_methods__uid__update_patch", "parameters": [{"description": "The unique id of the ODM Method.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Method."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethodWithRelationsPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethod"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Method is not in draft status.\n- The ODM Method had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Method with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/{uid}/new-version": {"post": {"tags": ["ODM Methods"], "summary": " Create a new version of ODM Method", "description": "\nState before:\n - uid must exist and the ODM Method must be in status Final.\n\nBusiness logic:\n- The ODM Method is changed to a draft state.\n\nState after:\n - ODM Method changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_method_version_concepts_odms_methods__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM Method.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Method."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethod"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM Methods.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM Method is not in final status.\n- The ODM Method with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/{uid}/approve": {"post": {"tags": ["ODM Methods"], "summary": "Approve draft version of ODM Method", "operationId": "approve_odm_method_concepts_odms_methods__uid__approve_post", "parameters": [{"description": "The unique id of the ODM Method.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Method."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethod"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Method is not in draft status.\n- The library does not allow to approve ODM Method.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Method with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/{uid}/inactivate": {"post": {"tags": ["ODM Methods"], "summary": " Inactivate final version of ODM Method", "operationId": "inactivate_odm_method_concepts_odms_methods__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM Method.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Method."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethod"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Method is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Method with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/methods/{uid}/reactivate": {"post": {"tags": ["ODM Methods"], "summary": "Reactivate retired version of a ODM Method", "operationId": "reactivate_odm_method_concepts_odms_methods__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM Method.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Method."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmMethod"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Method is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Method with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/formal-expressions": {"get": {"tags": ["ODM Formal Expressions"], "summary": "Return every variable related to the selected status and version of the ODM Formal Expressions", "operationId": "get_all_odm_formal_expressions_concepts_odms_formal_expressions_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmFormalExpression_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["ODM Formal Expressions"], "summary": "Creates a new Form in 'Draft' status with version 0.1", "operationId": "create_odm_formal_expression_concepts_odms_formal_expressions_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormalExpressionPostInput"}}}}, "responses": {"201": {"description": "Created - The odm formal expression was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormalExpression"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/formal-expressions/headers": {"get": {"tags": ["ODM Formal Expressions"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_formal_expressions_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Formal Expressions Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/formal-expressions/{uid}": {"get": {"tags": ["ODM Formal Expressions"], "summary": "Get details on a specific ODM Formal Expression (in a specific version)", "operationId": "get_odm_formal_expression_concepts_odms_formal_expressions__uid__get", "parameters": [{"description": "The unique id of the ODM Formal Expression.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Formal Expression."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormalExpression"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["ODM Formal Expressions"], "summary": "Delete draft version of ODM Formal Expression", "operationId": "delete_odm_formal_expression_concepts_odms_formal_expressions__uid__delete", "parameters": [{"description": "The unique id of the ODM Formal Expression.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Formal Expression."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM Formal Expression was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Formal Expression is not in draft status.\n- The ODM Formal Expression was already in final state or is in use.\n- The library does not allow to delete ODM Formal Expression.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM Formal Expression with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["ODM Formal Expressions"], "summary": "Update odm formal expression", "operationId": "edit_odm_formal_expression_concepts_odms_formal_expressions__uid__patch", "parameters": [{"description": "The unique id of the ODM Formal Expression.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Formal Expression."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormalExpressionPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormalExpression"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Formal Expression is not in draft status.\n- The ODM Formal Expression had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Formal Expression with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/formal-expressions/{uid}/relationships": {"get": {"tags": ["ODM Formal Expressions"], "summary": "Get UIDs of a specific ODM Formal Expression's relationships", "operationId": "get_active_relationships_concepts_odms_formal_expressions__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM Formal Expression.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Formal Expression."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Formal Expressions  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/formal-expressions/{uid}/versions": {"get": {"tags": ["ODM Formal Expressions"], "summary": "List version history for ODM Formal Expressions", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM Formal Expressions.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_formal_expression_versions_concepts_odms_formal_expressions__uid__versions_get", "parameters": [{"description": "The unique id of the ODM Formal Expression.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Formal Expression."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Formal Expression Versions Concepts Odms Formal Expressions  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmFormalExpression"}}}}}, "404": {"description": "Not Found - The ODM Formal Expression with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/formal-expressions/{uid}/new-version": {"post": {"tags": ["ODM Formal Expressions"], "summary": " Create a new version of ODM Formal Expression", "description": "\nState before:\n - uid must exist and the ODM Formal Expression must be in status Final.\n\nBusiness logic:\n- The ODM Formal Expression is changed to a draft state.\n\nState after:\n - ODM Formal Expression changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_formal_expression_version_concepts_odms_formal_expressions__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM Formal Expression.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Formal Expression."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormalExpression"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM Formal Expressions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM Formal Expression is not in final status.\n- The ODM Formal Expression with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/formal-expressions/{uid}/approve": {"post": {"tags": ["ODM Formal Expressions"], "summary": "Approve draft version of ODM Formal Expression", "operationId": "approve_odm_formal_expression_concepts_odms_formal_expressions__uid__approve_post", "parameters": [{"description": "The unique id of the ODM Formal Expression.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Formal Expression."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormalExpression"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Formal Expression is not in draft status.\n- The library does not allow to approve ODM Formal Expression.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Formal Expression with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/formal-expressions/{uid}/inactivate": {"post": {"tags": ["ODM Formal Expressions"], "summary": " Inactivate final version of ODM Formal Expression", "operationId": "inactivate_odm_formal_expression_concepts_odms_formal_expressions__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM Formal Expression.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Formal Expression."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormalExpression"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Formal Expression is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Formal Expression with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/formal-expressions/{uid}/reactivate": {"post": {"tags": ["ODM Formal Expressions"], "summary": "Reactivate retired version of a ODM Formal Expression", "operationId": "reactivate_odm_formal_expression_concepts_odms_formal_expressions__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM Formal Expression.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Formal Expression."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmFormalExpression"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Formal Expression is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Formal Expression with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/descriptions": {"get": {"tags": ["ODM Descriptions"], "summary": "Return a listing of ODM Descriptions", "operationId": "get_all_odm_descriptions_concepts_odms_descriptions_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmDescription_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["ODM Descriptions"], "summary": "Create a new ODM Description", "operationId": "create_odm_description_concepts_odms_descriptions_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmDescriptionPostInput"}}}}, "responses": {"201": {"description": "Created - The ODM Description was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmDescription"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/descriptions/headers": {"get": {"tags": ["ODM Descriptions"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_descriptions_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Descriptions Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/descriptions/{uid}/relationships": {"get": {"tags": ["ODM Descriptions"], "summary": "Get UIDs of a specific ODM Description's relationships", "operationId": "get_active_relationships_concepts_odms_descriptions__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM Description.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Description."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Descriptions  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/descriptions/{uid}/versions": {"get": {"tags": ["ODM Descriptions"], "summary": "Return a listing of versions of a specific ODM Description", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM Descriptions.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_description_versions_concepts_odms_descriptions__uid__versions_get", "parameters": [{"description": "The unique id of the ODM Description.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Description."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Description Versions Concepts Odms Descriptions  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmDescription"}}}}}, "404": {"description": "Not Found - The ODM Description with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/descriptions/batch": {"post": {"tags": ["ODM Descriptions"], "summary": "Batch operations (create, edit) for ODM Descriptions", "operationId": "odm_description_batch_operations_concepts_odms_descriptions_batch_post", "requestBody": {"content": {"application/json": {"schema": {"title": "Operations", "type": "array", "items": {"$ref": "#/components/schemas/OdmDescriptionBatchInput"}, "description": "List of operation to perform"}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Odm Description Batch Operations Concepts Odms Descriptions Batch Post", "type": "array", "items": {"$ref": "#/components/schemas/OdmDescriptionBatchOutput"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/descriptions/{uid}": {"delete": {"tags": ["ODM Descriptions"], "summary": "Delete draft version of ODM Description", "operationId": "delete_odm_description_concepts_odms_descriptions__uid__delete", "parameters": [{"description": "The unique id of the ODM Description.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Description."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM Description was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Description is not in draft status.\n- The ODM Description was already in final state or is in use.\n- The library does not allow to delete ODM Description.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM Description with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["ODM Descriptions"], "summary": "Update an ODM Description", "operationId": "edit_odm_description_concepts_odms_descriptions__uid__patch", "parameters": [{"description": "The unique id of the ODM Description.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Description."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmDescriptionPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmDescription"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Description is not in draft status.\n- The ODM Description had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Description with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/descriptions/{uid}/new-version": {"post": {"tags": ["ODM Descriptions"], "summary": "Create a new version of an ODM Description", "description": "\nState before:\n - uid must exist and the ODM Description must be in status Final.\n\nBusiness logic:\n- The ODM Description is changed to a draft state.\n\nState after:\n - ODM Description changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_description_version_concepts_odms_descriptions__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM Description.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Description."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmDescription"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM Descriptions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM Description is not in final status.\n- The ODM Description with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/descriptions/{uid}/approve": {"post": {"tags": ["ODM Descriptions"], "summary": "Approve an ODM Description", "operationId": "approve_odm_description_concepts_odms_descriptions__uid__approve_post", "parameters": [{"description": "The unique id of the ODM Description.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Description."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmDescription"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Description is not in draft status.\n- The library does not allow to approve ODM Description.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Description with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/descriptions/{uid}/inactivate": {"post": {"tags": ["ODM Descriptions"], "summary": " Inactivate an ODM Description", "operationId": "inactivate_odm_description_concepts_odms_descriptions__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM Description.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Description."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmDescription"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Description is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Description with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/descriptions/{uid}/reactivate": {"post": {"tags": ["ODM Descriptions"], "summary": "Reactivate an ODM Description", "operationId": "reactivate_odm_description_concepts_odms_descriptions__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM Description.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Description."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmDescription"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Description is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Description with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/aliases": {"get": {"tags": ["ODM Aliases"], "summary": "Return a listing of ODM Aliases", "operationId": "get_all_odm_aliases_concepts_odms_aliases_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmAlias_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["ODM Aliases"], "summary": "Create a new ODM Alias", "operationId": "create_odm_alias_concepts_odms_aliases_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmAliasPostInput"}}}}, "responses": {"201": {"description": "Created - The ODM Alias was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/aliases/headers": {"get": {"tags": ["ODM Aliases"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_aliases_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Aliases Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/aliases/{uid}/relationships": {"get": {"tags": ["ODM Aliases"], "summary": "Get UIDs of a specific ODM Alias' relationships", "operationId": "get_active_relationships_concepts_odms_aliases__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM Alias.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Alias."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Aliases  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/aliases/{uid}/versions": {"get": {"tags": ["ODM Aliases"], "summary": "Return a listing of versions of a specific ODM Alias", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM Aliases.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_alias_versions_concepts_odms_aliases__uid__versions_get", "parameters": [{"description": "The unique id of the ODM Alias.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Alias."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Alias Versions Concepts Odms Aliases  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmAlias"}}}}}, "404": {"description": "Not Found - The ODM Alias with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/aliases/batch": {"post": {"tags": ["ODM Aliases"], "summary": "Batch operations (create, edit) for ODM Aliases", "operationId": "odm_alias_batch_operations_concepts_odms_aliases_batch_post", "requestBody": {"content": {"application/json": {"schema": {"title": "Operations", "type": "array", "items": {"$ref": "#/components/schemas/OdmAliasBatchInput"}, "description": "List of operation to perform"}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Odm Alias Batch Operations Concepts Odms Aliases Batch Post", "type": "array", "items": {"$ref": "#/components/schemas/OdmAliasBatchOutput"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/aliases/{uid}": {"delete": {"tags": ["ODM Aliases"], "summary": "Delete draft version of ODM Alias", "operationId": "delete_odm_alias_concepts_odms_aliases__uid__delete", "parameters": [{"description": "The unique id of the ODM Alias.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Alias."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM Alias was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Alias is not in draft status.\n- The ODM Alias was already in final state or is in use.\n- The library does not allow to delete ODM Alias.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM Alias with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["ODM Aliases"], "summary": "Update an ODM Alias", "operationId": "edit_odm_alias_concepts_odms_aliases__uid__patch", "parameters": [{"description": "The unique id of the ODM Alias.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Alias."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmAliasPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Alias is not in draft status.\n- The ODM Alias had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Alias with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/aliases/{uid}/new-version": {"post": {"tags": ["ODM Aliases"], "summary": "Create a new version of an ODM Alias", "description": "\nState before:\n - uid must exist and the ODM Alias must be in status Final.\n\nBusiness logic:\n- The ODM Alias is changed to a draft state.\n\nState after:\n - ODM Alias changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_alias_version_concepts_odms_aliases__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM Alias.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Alias."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM Aliases.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM Alias is not in final status.\n- The ODM Alias with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/aliases/{uid}/approve": {"post": {"tags": ["ODM Aliases"], "summary": "Approve an ODM Alias", "operationId": "approve_odm_alias_concepts_odms_aliases__uid__approve_post", "parameters": [{"description": "The unique id of the ODM Alias.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Alias."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Alias is not in draft status.\n- The library does not allow to approve ODM Alias.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Alias with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/aliases/{uid}/inactivate": {"post": {"tags": ["ODM Aliases"], "summary": " Inactivate an ODM Alias", "operationId": "inactivate_odm_alias_concepts_odms_aliases__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM Alias.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Alias."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Alias is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Alias with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/aliases/{uid}/reactivate": {"post": {"tags": ["ODM Aliases"], "summary": "Reactivate an ODM Alias", "operationId": "reactivate_odm_alias_concepts_odms_aliases__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM Alias.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM Alias."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM Alias is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM Alias with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extensions": {"get": {"tags": ["ODM XML Extensions"], "summary": "Return every variable related to the selected status and version of the ODM XML Extensions", "operationId": "get_all_odm_xml_extensions_concepts_odms_xml_extensions_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmXmlExtension_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["ODM XML Extensions"], "summary": "Creates a new XML Extension in 'Draft' status with version 0.1", "operationId": "create_odm_xml_extension_concepts_odms_xml_extensions_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionPostInput"}}}}, "responses": {"201": {"description": "Created - The odm xml extension was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtension"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extensions/headers": {"get": {"tags": ["ODM XML Extensions"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_xml_extensions_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Xml Extensions Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extensions/{uid}": {"get": {"tags": ["ODM XML Extensions"], "summary": "Get details on a specific ODM XML Extension (in a specific version)", "operationId": "get_odm_xml_extension_concepts_odms_xml_extensions__uid__get", "parameters": [{"description": "The unique id of the ODM XML Extension.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtension"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["ODM XML Extensions"], "summary": "Delete draft version of ODM XML Extension", "operationId": "delete_odm_xml_extension_concepts_odms_xml_extensions__uid__delete", "parameters": [{"description": "The unique id of the ODM XML Extension.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM XML Extension was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension is not in draft status.\n- The ODM XML Extension was already in final state or is in use.\n- The library does not allow to delete ODM XML Extension.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM XML Extension with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["ODM XML Extensions"], "summary": "Update odm xml extension", "operationId": "edit_odm_xml_extension_concepts_odms_xml_extensions__uid__patch", "parameters": [{"description": "The unique id of the ODM XML Extension.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtension"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension is not in draft status.\n- The ODM XML Extension had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extensions/{uid}/relationships": {"get": {"tags": ["ODM XML Extensions"], "summary": "Get UIDs of a specific ODM XML Extension's relationships", "operationId": "get_active_relationships_concepts_odms_xml_extensions__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM XML Extension.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Xml Extensions  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extensions/{uid}/versions": {"get": {"tags": ["ODM XML Extensions"], "summary": "List version history for ODM XML Extensions", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM XML Extensions.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_xml_extension_versions_concepts_odms_xml_extensions__uid__versions_get", "parameters": [{"description": "The unique id of the ODM XML Extension.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Xml Extension Versions Concepts Odms Xml Extensions  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtension"}}}}}, "404": {"description": "Not Found - The ODM XML Extension with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extensions/{uid}/new-version": {"post": {"tags": ["ODM XML Extensions"], "summary": " Create a new version of ODM XML Extension", "description": "\nState before:\n - uid must exist and the ODM XML Extension must be in status Final.\n\nBusiness logic:\n- The ODM XML Extension is changed to a draft state.\n\nState after:\n - ODM XML Extension changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_xml_extension_version_concepts_odms_xml_extensions__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM XML Extension.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtension"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM XML Extensions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM XML Extension is not in final status.\n- The ODM XML Extension with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extensions/{uid}/approve": {"post": {"tags": ["ODM XML Extensions"], "summary": "Approve draft version of ODM XML Extension", "operationId": "approve_odm_xml_extension_concepts_odms_xml_extensions__uid__approve_post", "parameters": [{"description": "The unique id of the ODM XML Extension.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtension"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension is not in draft status.\n- The library does not allow to approve ODM XML Extension.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extensions/{uid}/inactivate": {"post": {"tags": ["ODM XML Extensions"], "summary": " Inactivate final version of ODM XML Extension", "operationId": "inactivate_odm_xml_extension_concepts_odms_xml_extensions__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM XML Extension.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtension"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extensions/{uid}/reactivate": {"post": {"tags": ["ODM XML Extensions"], "summary": "Reactivate retired version of a ODM XML Extension", "operationId": "reactivate_odm_xml_extension_concepts_odms_xml_extensions__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM XML Extension.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtension"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-attributes": {"get": {"tags": ["ODM XML Extension Attributes"], "summary": "Return every variable related to the selected status and version of the ODM XML Extension Attributes", "operationId": "get_all_odm_xml_extension_attributes_concepts_odms_xml_extension_attributes_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmXmlExtensionAttribute_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["ODM XML Extension Attributes"], "summary": "Creates a new XML Extension Attribute in 'Draft' status with version 0.1", "operationId": "create_odm_xml_extension_attribute_concepts_odms_xml_extension_attributes_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionAttributePostInput"}}}}, "responses": {"201": {"description": "Created - The odm xml extension attribute was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionAttribute"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-attributes/headers": {"get": {"tags": ["ODM XML Extension Attributes"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_xml_extension_attributes_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Xml Extension Attributes Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-attributes/{uid}": {"get": {"tags": ["ODM XML Extension Attributes"], "summary": "Get details on a specific ODM XML Extension Attribute (in a specific version)", "operationId": "get_odm_xml_extension_attribute_concepts_odms_xml_extension_attributes__uid__get", "parameters": [{"description": "The unique id of the ODM XML Extension Attribute.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Attribute."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionAttribute"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["ODM XML Extension Attributes"], "summary": "Delete draft version of ODM XML Extension Attribute", "operationId": "delete_odm_xml_extension_attribute_concepts_odms_xml_extension_attributes__uid__delete", "parameters": [{"description": "The unique id of the ODM XML Extension Attribute.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Attribute."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM XML Extension Attribute was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension Attribute is not in draft status.\n- The ODM XML Extension Attribute was already in final state or is in use.\n- The library does not allow to delete ODM XML Extension Attribute.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM XML Extension Attribute with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["ODM XML Extension Attributes"], "summary": "Update odm xml extension attribute", "operationId": "edit_odm_xml_extension_attribute_concepts_odms_xml_extension_attributes__uid__patch", "parameters": [{"description": "The unique id of the ODM XML Extension Attribute.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Attribute."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionAttributePatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionAttribute"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension Attribute is not in draft status.\n- The ODM XML Extension Attribute had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension Attribute with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-attributes/{uid}/relationships": {"get": {"tags": ["ODM XML Extension Attributes"], "summary": "Get UIDs of a specific ODM XML Extension Attribute's relationships", "operationId": "get_active_relationships_concepts_odms_xml_extension_attributes__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM XML Extension Attribute.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Attribute."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Xml Extension Attributes  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-attributes/{uid}/versions": {"get": {"tags": ["ODM XML Extension Attributes"], "summary": "List version history for ODM XML Extension Attributes", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM XML Extension Attributes.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_xml_extension_attribute_versions_concepts_odms_xml_extension_attributes__uid__versions_get", "parameters": [{"description": "The unique id of the ODM XML Extension Attribute.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Attribute."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Xml Extension Attribute Versions Concepts Odms Xml Extension Attributes  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionAttribute"}}}}}, "404": {"description": "Not Found - The ODM XML Extension Attribute with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-attributes/{uid}/new-version": {"post": {"tags": ["ODM XML Extension Attributes"], "summary": " Create a new version of ODM XML Extension Attribute", "description": "\nState before:\n - uid must exist and the ODM XML Extension Attribute must be in status Final.\n\nBusiness logic:\n- The ODM XML Extension Attribute is changed to a draft state.\n\nState after:\n - ODM XML Extension Attribute changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_xml_extension_attribute_version_concepts_odms_xml_extension_attributes__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM XML Extension Attribute.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Attribute."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionAttribute"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM XML Extension Attributes.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM XML Extension Attribute is not in final status.\n- The ODM XML Extension Attribute with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-attributes/{uid}/approve": {"post": {"tags": ["ODM XML Extension Attributes"], "summary": "Approve draft version of ODM XML Extension Attribute", "operationId": "approve_odm_xml_extension_attribute_concepts_odms_xml_extension_attributes__uid__approve_post", "parameters": [{"description": "The unique id of the ODM XML Extension Attribute.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Attribute."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionAttribute"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension Attribute is not in draft status.\n- The library does not allow to approve ODM XML Extension Attribute.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension Attribute with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-attributes/{uid}/inactivate": {"post": {"tags": ["ODM XML Extension Attributes"], "summary": " Inactivate final version of ODM XML Extension Attribute", "operationId": "inactivate_odm_xml_extension_attribute_concepts_odms_xml_extension_attributes__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM XML Extension Attribute.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Attribute."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionAttribute"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension Attribute is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension Attribute with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-attributes/{uid}/reactivate": {"post": {"tags": ["ODM XML Extension Attributes"], "summary": "Reactivate retired version of a ODM XML Extension Attribute", "operationId": "reactivate_odm_xml_extension_attribute_concepts_odms_xml_extension_attributes__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM XML Extension Attribute.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Attribute."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionAttribute"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension Attribute is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension Attribute with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-tags": {"get": {"tags": ["ODM XML Extension Tags"], "summary": "Return every variable related to the selected status and version of the ODM XML Extension Tag Tags", "operationId": "get_all_odm_xml_extension_tags_concepts_odms_xml_extension_tags_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_OdmXmlExtensionTag_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["ODM XML Extension Tags"], "summary": "Creates a new XML Extension Tag in 'Draft' status with version 0.1", "operationId": "create_odm_xml_extension_tag_concepts_odms_xml_extension_tags_post", "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionTagPostInput"}}}}, "responses": {"201": {"description": "Created - The odm xml extension tag was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionTag"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-tags/headers": {"get": {"tags": ["ODM XML Extension Tags"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_odms_xml_extension_tags_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Odms Xml Extension Tags Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-tags/{uid}": {"get": {"tags": ["ODM XML Extension Tags"], "summary": "Get details on a specific ODM XML Extension Tag (in a specific version)", "operationId": "get_odm_xml_extension_tag_concepts_odms_xml_extension_tags__uid__get", "parameters": [{"description": "The unique id of the ODM XML Extension Tag.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Tag."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionTag"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["ODM XML Extension Tags"], "summary": "Delete draft version of ODM XML Extension Tag", "operationId": "delete_odm_xml_extension_tag_concepts_odms_xml_extension_tags__uid__delete", "parameters": [{"description": "The unique id of the ODM XML Extension Tag.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Tag."}, "name": "uid", "in": "path"}], "responses": {"204": {"description": "No Content - The ODM XML Extension Tag was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension Tag is not in draft status.\n- The ODM XML Extension Tag was already in final state or is in use.\n- The library does not allow to delete ODM XML Extension Tag.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An ODM XML Extension Tag with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["ODM XML Extension Tags"], "summary": "Update odm xml extension tag", "operationId": "edit_odm_xml_extension_tag_concepts_odms_xml_extension_tags__uid__patch", "parameters": [{"description": "The unique id of the ODM XML Extension Tag.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Tag."}, "name": "uid", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionTagPatchInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionTag"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension Tag is not in draft status.\n- The ODM XML Extension Tag had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension Tag with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-tags/{uid}/relationships": {"get": {"tags": ["ODM XML Extension Tags"], "summary": "Get UIDs of a specific ODM XML Extension Tag's relationships", "operationId": "get_active_relationships_concepts_odms_xml_extension_tags__uid__relationships_get", "parameters": [{"description": "The unique id of the ODM XML Extension Tag.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Tag."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Active Relationships Concepts Odms Xml Extension Tags  Uid  Relationships Get", "type": "object"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-tags/{uid}/versions": {"get": {"tags": ["ODM XML Extension Tags"], "summary": "List version history for ODM XML Extension Tag Tags", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for ODM XML Extension Tag Tags.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_odm_xml_extension_tag_versions_concepts_odms_xml_extension_tags__uid__versions_get", "parameters": [{"description": "The unique id of the ODM XML Extension Tag.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Tag."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Odm Xml Extension Tag Versions Concepts Odms Xml Extension Tags  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionTag"}}}}}, "404": {"description": "Not Found - The ODM XML Extension Tag with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-tags/{uid}/new-version": {"post": {"tags": ["ODM XML Extension Tags"], "summary": " Create a new version of ODM XML Extension Tag", "description": "\nState before:\n - uid must exist and the ODM XML Extension Tag must be in status Final.\n\nBusiness logic:\n- The ODM XML Extension Tag is changed to a draft state.\n\nState after:\n - ODM XML Extension Tag changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_odm_xml_extension_tag_version_concepts_odms_xml_extension_tags__uid__new_version_post", "parameters": [{"description": "The unique id of the ODM XML Extension Tag.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Tag."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionTag"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create ODM XML Extension Tag Tags.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The ODM XML Extension Tag is not in final status.\n- The ODM XML Extension Tag with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-tags/{uid}/approve": {"post": {"tags": ["ODM XML Extension Tags"], "summary": "Approve draft version of ODM XML Extension Tag", "operationId": "approve_odm_xml_extension_tag_concepts_odms_xml_extension_tags__uid__approve_post", "parameters": [{"description": "The unique id of the ODM XML Extension Tag.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Tag."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionTag"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension Tag is not in draft status.\n- The library does not allow to approve ODM XML Extension Tag.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension Tag with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-tags/{uid}/inactivate": {"post": {"tags": ["ODM XML Extension Tags"], "summary": " Inactivate final version of ODM XML Extension Tag", "operationId": "inactivate_odm_xml_extension_tag_concepts_odms_xml_extension_tags__uid__inactivate_post", "parameters": [{"description": "The unique id of the ODM XML Extension Tag.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Tag."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionTag"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension Tag is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension Tag with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/xml-extension-tags/{uid}/reactivate": {"post": {"tags": ["ODM XML Extension Tags"], "summary": "Reactivate retired version of a ODM XML Extension Tag", "operationId": "reactivate_odm_xml_extension_tag_concepts_odms_xml_extension_tags__uid__reactivate_post", "parameters": [{"description": "The unique id of the ODM XML Extension Tag.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ODM XML Extension Tag."}, "name": "uid", "in": "path"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/OdmXmlExtensionTag"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The ODM XML Extension Tag is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The ODM XML Extension Tag with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/metadata/xmls": {"get": {"tags": ["ODM Metadata Import/Export"], "summary": "Export ODM XML", "operationId": "get_odm_xml_concepts_odms_metadata_xmls_get", "parameters": [{"required": true, "schema": {"title": "Targetuid", "type": "string"}, "name": "targetUid", "in": "query"}, {"required": true, "schema": {"$ref": "#/components/schemas/TargetType"}, "name": "targetType", "in": "query"}, {"required": true, "schema": {"$ref": "#/components/schemas/OdmExportTo"}, "name": "exportTo", "in": "query"}, {"required": false, "schema": {"title": "Allowedextensions", "type": "array", "items": {"type": "string"}}, "name": "allowedExtensions", "in": "query"}, {"required": false, "schema": {"title": "Stylesheet", "type": "string"}, "name": "stylesheet", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["ODM Metadata Import/Export"], "summary": "Import ODM XML", "operationId": "store_odm_xml_concepts_odms_metadata_xmls_post", "requestBody": {"content": {"application/json": {"schema": {"title": "Xml", "type": "string", "description": "The ODM to store as an xml string."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/odms/metadata/csvs": {"get": {"tags": ["ODM Metadata Import/Export"], "summary": "Export ODM CSV", "operationId": "get_odm_csv_concepts_odms_metadata_csvs_get", "parameters": [{"required": true, "schema": {"title": "Targetuid", "type": "string"}, "name": "targetUid", "in": "query"}, {"required": true, "schema": {"$ref": "#/components/schemas/TargetType"}, "name": "targetType", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates": {"get": {"tags": ["Activity Description Templates"], "summary": "Returns all activity description templates in their latest/newest version.", "description": "Allowed parameters include : filter on fields, sort by field name with sort direction, pagination", "operationId": "get_activity_description_templates_activity_description_templates_get", "parameters": [{"description": "If specified, only those activity description templates will be returned that are currently in the specified status. This may be particularly useful if the activity description template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those activity description templates will be returned that are currently in the specified status. This may be particularly useful if the activity description template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_ActivityDescriptionTemplate_"}}, "text/csv": {"example": "\n\"library\",\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<root>\n    <data type=\"list\">\n        <item type=\"dict\">\n            <uid type=\"str\">e9117175-918f-489e-9a6e-65e0025233a6</uid>\n            <name type=\"str\">\"First  [ComparatorIntervention]</name>\n            <startDate type=\"str\">2020-11-19T11:51:43.000Z</startDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.2</version>\n            <changeDescription type=\"str\">Test</changeDescription>\n            <userInitials type=\"str\">TODO Initials</userInitials>\n        </item>\n  </data>\n</root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Activity Description Templates"], "summary": "Creates a new activity description template in 'Draft' status.", "description": "This request is only valid if the activity description template\n* belongs to a library that allows creating (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n* The activity description template will be linked to a library.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an activity description template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an activity description is created out of the activity description template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe activity description template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same activity description template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "create_activity_description_template_activity_description_templates_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Activity Description Template", "allOf": [{"$ref": "#/components/schemas/ActivityDescriptionTemplateCreateInput"}], "description": "The activity description template that shall be created."}}}}, "responses": {"201": {"description": "Created - The activity template was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity description template name is not valid.\n- The library does not allow to create activity description templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The library with the specified 'libraryName' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/headers": {"get": {"tags": ["Activity Description Templates"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_activity_description_templates_headers_get", "parameters": [{"description": "If specified, only those activity description templates will be returned that are currently in the specified status. This may be particularly useful if the activity description template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those activity description templates will be returned that are currently in the specified status. This may be particularly useful if the activity description template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Activity Description Templates Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}": {"get": {"tags": ["Activity Description Templates"], "summary": "Returns the latest/newest version of a specific activity description template identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_activity_description_template_activity_description_templates__uid__get", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "if specified counts data will be returned along object", "required": false, "schema": {"title": "Return Instantiation Counts", "type": "boolean", "description": "if specified counts data will be returned along object", "default": false}, "name": "return_instantiation_counts", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityDescriptionTemplateWithCount"}}}}, "404": {"description": "Not Found - The activity description template with the\n            specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Activity Description Templates"], "summary": "Deletes the activity description template identified by 'uid'.", "description": "This request is only valid if \n\n* the activity description template is in 'Draft' status and\n* the activity description template has never been in 'Final' status and\n* the activity description template has no references to any activity description and\n* the activity description template belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_activity_description_template_activity_description_templates__uid__delete", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The activity description template was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity description template is not in draft status.\n- The activity description template was already in final state or is in use.\n- The library does not allow to delete activity description templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An activity description template with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Activity Description Templates"], "summary": "Updates the activity description template identified by 'uid'.", "description": "This request is only valid if the activity description template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\nParameters in the 'name' property can only be changed if the activity description template has never been approved.\nOnce the activity description template has been approved, only the surrounding text (excluding the parameters) can be changed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an activity description template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an activity description is created out of the activity description template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe activity description template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same activity description template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "edit_activity_description_templates__uid__patch", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Activity Description Template", "allOf": [{"$ref": "#/components/schemas/ActivityDescriptionTemplateEditInput"}], "description": "The new content of the activity description template including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity description template is not in draft status.\n- The activity description template name is not valid.\n- The library does not allow to edit draft versions.\n- The change of parameters of previously approved activity description templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity description template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}/versions": {"get": {"tags": ["Activity Description Templates"], "summary": "Returns the version history of a specific activity description template identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_activity_description_template_versions_activity_description_templates__uid__versions_get", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Activity Description Template Versions Activity Description Templates  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/ActivityDescriptionTemplateVersion"}}}, "text/csv": {"example": "\n\"library\",\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<root>\n    <data type=\"list\">\n        <item type=\"dict\">\n            <name type=\"str\">First  [ComparatorIntervention]</name>\n            <startDate type=\"str\">2020-11-19 11:51:43+00:00</startDate>\n            <endDate type=\"str\">None</endDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.2</version>\n            <changeDescription type=\"str\">Test</changeDescription>\n            <userInitials type=\"str\">TODO Initials</userInitials>\n        </item>\n        <item type=\"dict\">\n            <name type=\"str\">First  [ComparatorIntervention]</name>\n            <startDate type=\"str\">2020-11-19 11:51:07+00:00</startDate>\n            <endDate type=\"str\">2020-11-19 11:51:43+00:00</endDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.1</version>\n            <changeDescription type=\"str\">Initial version</changeDescription>\n            <userInitials type=\"str\">TODO user initials</userInitials>\n        </item>\n    </data>\n</root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "404": {"description": "Not Found - The activity description template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}/versions/{version}": {"get": {"tags": ["Activity Description Templates"], "summary": "Returns a specific version of a specific activity description template identified by 'uid' and 'version'.", "description": "**Multiple versions**:\n\nTechnically, there can be multiple versions of the activity description template with the same version number. This is due to the fact, that the version number remains the same when inactivating or reactivating an activity description template (switching between 'Final' and 'Retired' status). \n\nIn that case the latest/newest representation is returned.", "operationId": "get_activity_description_template_version_activity_description_templates__uid__versions__version__get", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A specific version number of the activity description template. The version number is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits.\nE.g. '0.1', '0.2', '1.0', ...", "required": true, "schema": {"title": "Version", "type": "string", "description": "A specific version number of the activity description template. The version number is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits.\nE.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}}}, "404": {"description": "Not Found - The activity description template with the specified 'uid' and 'version' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}/releases": {"get": {"tags": ["Activity Description Templates"], "summary": "List all final versions of a template identified by 'uid', including number of studies using a specific version", "operationId": "get_activity_description_template_releases_activity_description_templates__uid__releases_get", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Activity Description Template Releases Activity Description Templates  Uid  Releases Get", "type": "array", "items": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}}}}, "404": {"description": "Not Found - The activity description template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}/groupings": {"patch": {"tags": ["Activity Description Templates"], "summary": "Updates the groupings of the activity description template identified by 'uid'.", "description": "This request is only valid if the template\n    * belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n    \n    This is version independent : it won't trigger a status or a version change.\n    ", "operationId": "patch_groupings_activity_description_templates__uid__groupings_patch", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Groupings", "allOf": [{"$ref": "#/components/schemas/ActivityDescriptionTemplateEditGroupingsInput"}], "description": "The lists of UIDs for the new groupings to be set, grouped by groupings to be updated."}}}}, "responses": {"200": {"description": "No content - The groupings for this template were successfully updated.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}}}, "404": {"description": "Not Found - The template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}/default-parameter-values": {"patch": {"tags": ["Activity Description Templates"], "summary": "Edit the default parameter values of the activity description template identified by 'uid'.", "description": "This request is only valid if the activity description template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\nThis endpoint can be used to either :\n* Create a new set of default parameter values\n* Edit an existing set of default parameter values\n\n", "operationId": "patch_default_parameter_values_activity_description_templates__uid__default_parameter_values_patch", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Body_patch_default_parameter_values_activity_description_templates__uid__default_parameter_values_patch"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity description template is not in draft status.\n- The activity description template name is not valid.\n- The library does not allow to edit draft versions.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity description template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}/new-version": {"post": {"tags": ["Activity Description Templates"], "summary": "Creates a new version of the activity description template identified by 'uid'.", "description": "This request is only valid if the activity description template\n* is in 'Final' or 'Retired' status only (so no latest 'Draft' status exists) and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The latest 'Final' or 'Retired' version will remain the same as before.\n* The status of the new version will be automatically set to 'Draft'.\n* The 'version' property of the new version will be automatically set to the version of the latest 'Final' or 'Retired' version increased by +0.1.\n\nParameters in the 'name' property cannot be changed with this request.\nOnly the surrounding text (excluding the parameters) can be changed.\n", "operationId": "create_new_version_activity_description_templates__uid__new_version_post", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Activity Description Template", "allOf": [{"$ref": "#/components/schemas/ActivityDescriptionTemplateEditInput"}], "description": "The content of the activity description template for the new 'Draft' version including the change description."}}}}, "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity description template is not in final or retired status or has a draft status.\n- The activity description template name is not valid.\n- The library does not allow to create a new version.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity description template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}/approve": {"post": {"tags": ["Activity Description Templates"], "summary": "Approves the activity description template identified by 'uid'.", "description": "This request is only valid if the activity description template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_activity_description_templates__uid__approve_post", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"required": false, "schema": {"title": "Cascade", "type": "boolean", "default": false}, "name": "cascade", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity description template is not in draft status.\n- The library does not allow to approve drafts.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity description template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "409": {"description": "Conflict - there are activity description created from template and cascade is false", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}/inactivate": {"post": {"tags": ["Activity Description Templates"], "summary": "Inactivates/deactivates the activity description template identified by 'uid'.", "description": "This request is only valid if the activity description template\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_activity_description_templates__uid__inactivate_post", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity description template is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity description template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}/reactivate": {"post": {"tags": ["Activity Description Templates"], "summary": "Reactivates the activity description template identified by 'uid'.", "description": "This request is only valid if the activity description template\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_activity_description_templates__uid__reactivate_post", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity description template is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity description template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/{uid}/parameters": {"get": {"tags": ["Activity Description Templates"], "summary": "Returns all parameters used in the activity description template identified by 'uid'. Includes the available values per parameter.", "description": "The returned parameters are ordered\n0. as they occur in the activity description template\n\nPer parameter, the parameter.values are ordered by\n0. value.name ascending\n\nNote that parameters may be used multiple times in templates.\nIn that case, the same parameter (with the same values) is included multiple times in the response.\n    ", "operationId": "get_parameters_activity_description_templates__uid__parameters_get", "parameters": [{"description": "The unique id of the activity description template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameters Activity Description Templates  Uid  Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/activity-description-templates/pre-validate": {"post": {"tags": ["Activity Description Templates"], "summary": "Validates the content of an activity description template without actually processing it.", "description": "Be aware that - even if this request is accepted - there is no guarantee that\na following request to e.g. *[POST] /activity-description-templates* or *[PATCH] /activity-description-templates/{uid}*\nwith the same content will succeed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an activity description template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an activity description is created out of the activity description template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe activity description template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same activity description template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "pre_validate_activity_description_templates_pre_validate_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Activity Description Template", "allOf": [{"$ref": "#/components/schemas/ActivityDescriptionTemplateNameInput"}], "description": "The content of the activity description template that shall be validated."}}}}, "responses": {"202": {"description": "Accepted. The content is valid and may be submitted in another request.", "content": {"application/json": {"schema": {}}}}, "403": {"description": "Forbidden. The content is invalid - Reasons include e.g.: \n- The syntax of the 'name' is not valid.\n- One of the parameters wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates": {"get": {"tags": ["Criteria Templates"], "summary": "Returns all criteria templates in their latest/newest version.", "description": "Allowed parameters include : filter on fields, sort by field name with sort direction, pagination", "operationId": "get_criteria_templates_criteria_templates_get", "parameters": [{"description": "If specified, only those criteria templates will be returned that are currently in the specified status. This may be particularly useful if the criteria template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those criteria templates will be returned that are currently in the specified status. This may be particularly useful if the criteria template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CriteriaTemplate_"}}, "text/csv": {"example": "\n\"library\",\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<root>\n    <data type=\"list\">\n        <item type=\"dict\">\n            <uid type=\"str\">e9117175-918f-489e-9a6e-65e0025233a6</uid>\n            <name type=\"str\">\"First  [ComparatorIntervention]</name>\n            <startDate type=\"str\">2020-11-19T11:51:43.000Z</startDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.2</version>\n            <changeDescription type=\"str\">Test</changeDescription>\n            <userInitials type=\"str\">TODO Initials</userInitials>\n        </item>\n  </data>\n</root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Criteria Templates"], "summary": "Creates a new criteria template in 'Draft' status.", "description": "This request is only valid if the criteria template\n* belongs to a library that allows creating (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n* The criteria template will be linked to a library.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an criteria template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an criteria is created out of the criteria template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe criteria template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same criteria template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "create_criteria_template_criteria_templates_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Criteria Template", "allOf": [{"$ref": "#/components/schemas/CriteriaTemplateCreateInput"}], "description": "The criteria template that shall be created."}}}}, "responses": {"201": {"description": "Created - The criteria template was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CriteriaTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria template name is not valid.\n- The library does not allow to create criteria templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The library with the specified 'libraryName' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/headers": {"get": {"tags": ["Criteria Templates"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_criteria_templates_headers_get", "parameters": [{"description": "If specified, only those criteria templates will be returned that are currently in the specified status. This may be particularly useful if the criteria template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those criteria templates will be returned that are currently in the specified status. This may be particularly useful if the criteria template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Criteria Templates Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}": {"get": {"tags": ["Criteria Templates"], "summary": "Returns the latest/newest version of a specific criteria template identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_criteria_template_criteria_templates__uid__get", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "if specified counts data will be returned along object", "required": false, "schema": {"title": "Return Instantiation Counts", "type": "boolean", "description": "if specified counts data will be returned along object", "default": false}, "name": "return_instantiation_counts", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CriteriaTemplateWithCount"}}}}, "404": {"description": "Not Found - The criteria template with the specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Criteria Templates"], "summary": "Deletes the criteria template identified by 'uid'.", "description": "This request is only valid if \n\n* the criteria template is in 'Draft' status and\n* the criteria template has never been in 'Final' status and\n* the criteria template has no references to any criteria and\n* the criteria template belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_criteria_template_criteria_templates__uid__delete", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The criteria template was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria template is not in draft status.\n- The criteria template was already in final state or is in use.\n- The library does not allow to delete criteria templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An criteria template with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Criteria Templates"], "summary": "Updates the criteria template identified by 'uid'.", "description": "This request is only valid if the criteria template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\nParameters in the 'name' property can only be changed if the criteria template has never been approved.\nOnce the criteria template has been approved, only the surrounding text (excluding the parameters) can be changed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an criteria template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an criteria is created out of the criteria template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe criteria template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same criteria template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "edit_criteria_templates__uid__patch", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Criteria Template", "allOf": [{"$ref": "#/components/schemas/CriteriaTemplateEditInput"}], "description": "The new content of the criteria template including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CriteriaTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria template is not in draft status.\n- The criteria template name is not valid.\n- The library does not allow to edit draft versions.\n- The change of parameters of previously approved criteria templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The criteria template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}/versions": {"get": {"tags": ["Criteria Templates"], "summary": "Returns the version history of a specific criteria template identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_criteria_template_versions_criteria_templates__uid__versions_get", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Criteria Template Versions Criteria Templates  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/CriteriaTemplateVersion"}}}, "text/csv": {"example": "\n\"library\",\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<root>\n    <data type=\"list\">\n        <item type=\"dict\">\n            <name type=\"str\">First  [ComparatorIntervention]</name>\n            <startDate type=\"str\">2020-11-19 11:51:43+00:00</startDate>\n            <endDate type=\"str\">None</endDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.2</version>\n            <changeDescription type=\"str\">Test</changeDescription>\n            <userInitials type=\"str\">TODO Initials</userInitials>\n        </item>\n        <item type=\"dict\">\n            <name type=\"str\">First  [ComparatorIntervention]</name>\n            <startDate type=\"str\">2020-11-19 11:51:07+00:00</startDate>\n            <endDate type=\"str\">2020-11-19 11:51:43+00:00</endDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.1</version>\n            <changeDescription type=\"str\">Initial version</changeDescription>\n            <userInitials type=\"str\">TODO user initials</userInitials>\n        </item>\n    </data>\n</root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "404": {"description": "Not Found - The criteria template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}/versions/{version}": {"get": {"tags": ["Criteria Templates"], "summary": "Returns a specific version of a specific criteria template identified by 'uid' and 'version'.", "description": "**Multiple versions**:\n\nTechnically, there can be multiple versions of the criteria template with the same version number. This is due to the fact, that the version number remains the same when inactivating or reactivating an criteria template (switching between 'Final' and 'Retired' status). \n\nIn that case the latest/newest representation is returned.", "operationId": "get_criteria_template_version_criteria_templates__uid__versions__version__get", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A specific version number of the criteria template. The version number is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits.\nE.g. '0.1', '0.2', '1.0', ...", "required": true, "schema": {"title": "Version", "type": "string", "description": "A specific version number of the criteria template. The version number is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits.\nE.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CriteriaTemplate"}}}}, "404": {"description": "Not Found - The criteria template with the specified 'uid' and 'version' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}/releases": {"get": {"tags": ["Criteria Templates"], "summary": "List all final versions of a template identified by 'uid', including number of studies using a specific version", "operationId": "get_criteria_template_releases_criteria_templates__uid__releases_get", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Criteria Template Releases Criteria Templates  Uid  Releases Get", "type": "array", "items": {"$ref": "#/components/schemas/CriteriaTemplate"}}}}}, "404": {"description": "Not Found - The criteria template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}/groupings": {"patch": {"tags": ["Criteria Templates"], "summary": "Updates the groupings of the criteria template identified by 'uid'.", "description": "This request is only valid if the template\n    * belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n    \n    This is version independent : it won't trigger a status or a version change.\n    ", "operationId": "patch_groupings_criteria_templates__uid__groupings_patch", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Groupings", "allOf": [{"$ref": "#/components/schemas/CriteriaTemplateEditGroupingsInput"}], "description": "The lists of UIDs for the new groupings to be set, grouped by groupings to be updated."}}}}, "responses": {"200": {"description": "No content - The groupings for this template were successfully updated.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CriteriaTemplate"}}}}, "404": {"description": "Not Found - The template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}/default-parameter-values": {"patch": {"tags": ["Criteria Templates"], "summary": "Edit the default parameter values of the criteria template identified by 'uid'.", "description": "This request is only valid if the criteria template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\nThis endpoint can be used to either :\n* Create a new set of default parameter values\n* Edit an existing set of default parameter values\n\n", "operationId": "patch_default_parameter_values_criteria_templates__uid__default_parameter_values_patch", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Body_patch_default_parameter_values_criteria_templates__uid__default_parameter_values_patch"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CriteriaTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria template is not in draft status.\n- The criteria template name is not valid.\n- The library does not allow to edit draft versions.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The criteria template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}/new-version": {"post": {"tags": ["Criteria Templates"], "summary": "Creates a new version of the criteria template identified by 'uid'.", "description": "This request is only valid if the criteria template\n* is in 'Final' or 'Retired' status only (so no latest 'Draft' status exists) and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The latest 'Final' or 'Retired' version will remain the same as before.\n* The status of the new version will be automatically set to 'Draft'.\n* The 'version' property of the new version will be automatically set to the version of the latest 'Final' or 'Retired' version increased by +0.1.\n\nParameters in the 'name' property cannot be changed with this request.\nOnly the surrounding text (excluding the parameters) can be changed.\n", "operationId": "create_new_version_criteria_templates__uid__new_version_post", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Criteria Template", "allOf": [{"$ref": "#/components/schemas/CriteriaTemplateEditInput"}], "description": "The content of the criteria template for the new 'Draft' version including the change description."}}}}, "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CriteriaTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria template is not in final or retired status or has a draft status.\n- The criteria template name is not valid.\n- The library does not allow to create a new version.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The criteria template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}/approve": {"post": {"tags": ["Criteria Templates"], "summary": "Approves the criteria template identified by 'uid'.", "description": "This request is only valid if the criteria template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_criteria_templates__uid__approve_post", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"required": false, "schema": {"title": "Cascade", "type": "boolean", "default": false}, "name": "cascade", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CriteriaTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria template is not in draft status.\n- The library does not allow to approve drafts.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The criteria template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "409": {"description": "Conflict - there are criteria created from template and cascade is false", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}/inactivate": {"post": {"tags": ["Criteria Templates"], "summary": "Inactivates/deactivates the criteria template identified by 'uid'.", "description": "This request is only valid if the criteria template\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_criteria_templates__uid__inactivate_post", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CriteriaTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria template is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The criteria template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}/reactivate": {"post": {"tags": ["Criteria Templates"], "summary": "Reactivates the criteria template identified by 'uid'.", "description": "This request is only valid if the criteria template\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_criteria_templates__uid__reactivate_post", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CriteriaTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria template is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The criteria template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/{uid}/parameters": {"get": {"tags": ["Criteria Templates"], "summary": "Returns all parameters used in the criteria template identified by 'uid'. Includes the available values per parameter.", "description": "The returned parameters are ordered\n0. as they occur in the criteria template\n\nPer parameter, the parameter.values are ordered by\n0. value.name ascending\n\nNote that parameters may be used multiple times in templates.\nIn that case, the same parameter (with the same values) is included multiple times in the response.\n    ", "operationId": "get_parameters_criteria_templates__uid__parameters_get", "parameters": [{"description": "The unique id of the criteria template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameters Criteria Templates  Uid  Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria-templates/pre-validate": {"post": {"tags": ["Criteria Templates"], "summary": "Validates the content of an criteria template without actually processing it.", "description": "Be aware that - even if this request is accepted - there is no guarantee that\na following request to e.g. *[POST] /criteria-templates* or *[PATCH] /criteria-templates/{uid}*\nwith the same content will succeed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an criteria template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an criteria is created out of the criteria template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe criteria template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same criteria template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "pre_validate_criteria_templates_pre_validate_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Criteria Template", "allOf": [{"$ref": "#/components/schemas/CriteriaTemplateNameInput"}], "description": "The content of the criteria template that shall be validated."}}}}, "responses": {"202": {"description": "Accepted. The content is valid and may be submitted in another request.", "content": {"application/json": {"schema": {}}}}, "403": {"description": "Forbidden. The content is invalid - Reasons include e.g.: \n- The syntax of the 'name' is not valid.\n- One of the parameters wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria": {"get": {"tags": ["Criteria"], "summary": "Returns all final versions of criteria referenced by any study.", "operationId": "get_all_criteria_get", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Criteria Get", "type": "array", "items": {"$ref": "#/components/schemas/Criteria"}}}, "text/csv": {"example": "\n\"library\",\"uid\",\"objective\",\"criteriaTemplate\",\"criteria\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"Objective\",\"First [ComparatorIntervention]\",\"First Intervention\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}, "text/xml": {"example": "\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<root>\n    <data type=\"list\">\n        <item type=\"dict\">\n            <library type=\"str\">Sponsor</library>\n            <uid type=\"str\">682d7003-8dcc-480d-b07b-878e659b8697</uid>\n            <objective type=\"str\">Test template new [glucose metabolism] [MACE+] totot</objective>\n            <criteriaTemplate type=\"str\">Criteria using [Activity] and [Indication]</criteriaTemplate>\n            <criteria type=\"str\">Criteria using [body weight] and [type 2 diabetes]</criteria>\n            <startDate type=\"str\">2020-11-26T13:43:23.000Z</startDate>\n            <endDate type=\"str\"></endDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.2</version>\n            <changeDescription type=\"str\">Changed indication</changeDescription>\n            <userInitials type=\"str\">TODO Initials</userInitials>\n        </item>\n    </data>\n</root>\n"}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria/{uid}": {"get": {"tags": ["Criteria"], "summary": "Returns the latest/newest version of a specific criteria identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_criteria__uid__get", "parameters": [{"description": "The unique id of the criteria.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria."}, "name": "uid", "in": "path"}, {"description": "If specified, the latest/newest representation of the criteria at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified, the latest/newest representation of the criteria at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified, the representation of the criteria in that status is returned (if existent). This may be particularly useful if the criteria has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, the representation of the criteria in that status is returned (if existent). This may be particularly useful if the criteria has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "If specified, the latest/newest representation of the criteria in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ...", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified, the latest/newest representation of the criteria in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Criteria"}}}}, "404": {"description": "Not Found - The criteria with the specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Criteria"], "summary": "Deletes the criteria identified by 'uid'.", "description": "This request is only valid if \n\n* the criteria is in 'Draft' status and\n* the criteria has never been in 'Final' status and\n* the criteria belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_criteria__uid__delete", "parameters": [{"description": "The unique id of the criteria.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The criteria was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria is not in draft status.\n- The criteria was already in final state or is in use.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An criteria with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Criteria"], "summary": "Updates the criteria identified by 'uid'.", "description": "This request is only valid if the criteria\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n", "operationId": "edit_criteria__uid__patch", "parameters": [{"description": "The unique id of the criteria.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Criteria", "allOf": [{"$ref": "#/components/schemas/CriteriaEditInput"}], "description": "The new parameter values for the criteria including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Criteria"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria is not in draft status.\n- The criteria had been in 'Final' status before.\n- The provided list of parameters is invalid.\n- The library does not allow to edit draft versions.\n- The criteria does already exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The criteria with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria/get-by-name/{name}": {"get": {"tags": ["Criteria"], "summary": "Returns the latest/newest version of a specific criteria identified by 'name'.", "description": "Gets an object by name - uses LATEST_DRAFT and LATEST_FINAL relations", "operationId": "get_by_name_criteria_get_by_name__name__get", "parameters": [{"required": true, "schema": {"title": "Name", "type": "string"}, "name": "name", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Criteria"}}}}, "404": {"description": "Not Found - The criteria with the specified 'name' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria/{uid}/versions": {"get": {"tags": ["Criteria"], "summary": "Returns the version history of a specific criteria identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_versions_criteria__uid__versions_get", "parameters": [{"description": "The unique id of the criteria.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Criteria  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/CriteriaVersion"}}}}}, "404": {"description": "Not Found - The criteria with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria/{uid}/approve": {"post": {"tags": ["Criteria"], "summary": "Approves the criteria identified by 'uid'.", "description": "This request is only valid if the criteria\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_criteria__uid__approve_post", "parameters": [{"description": "The unique id of the criteria.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Criteria"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria is not in draft status.\n- The library does not allow to approve criteria.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The criteria with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria/{uid}/inactivate": {"post": {"tags": ["Criteria"], "summary": "Inactivates/deactivates the criteria identified by 'uid'.", "description": "This request is only valid if the criteria\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_criteria__uid__inactivate_post", "parameters": [{"description": "The unique id of the criteria.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Criteria"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The criteria with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria/{uid}/reactivate": {"post": {"tags": ["Criteria"], "summary": "Reactivates the criteria identified by 'uid'.", "description": "This request is only valid if the criteria\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_criteria__uid__reactivate_post", "parameters": [{"description": "The unique id of the criteria.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Criteria"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The criteria is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The criteria with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria/{uid}/studies": {"get": {"tags": ["Criteria"], "summary": "Get Studies", "operationId": "get_studies_criteria__uid__studies_get", "parameters": [{"description": "The unique id of the criteria.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria."}, "name": "uid", "in": "path"}, {"description": "Parameter specifies which parts of the whole Study Definition representation to retrieve. In the form of comma separated name of the fields prefixed by (optional) `+`  if the client wishes to retrieve the field or `-` if the client wants to skip the field. If not specified identification metadata and version metadata are retrieved. If value starts with `+` or `-` above default is extended or reduced by the specified fields otherwise (if not started with `+` or `-`) provided fields specification replaces the default. Currently supported fields are `currentMetadata.identificationMetadata`, `currentMetadata.highLevelStudyDesign` , `currentMetadata.studyPopulation` and `currentMetadata.studyIntervention` , `currentMetadata.studyDescription`.", "required": false, "schema": {"title": "Fields", "type": "string", "description": "Parameter specifies which parts of the whole Study Definition representation to retrieve. In the form of comma separated name of the fields prefixed by (optional) `+`  if the client wishes to retrieve the field or `-` if the client wants to skip the field. If not specified identification metadata and version metadata are retrieved. If value starts with `+` or `-` above default is extended or reduced by the specified fields otherwise (if not started with `+` or `-`) provided fields specification replaces the default. Currently supported fields are `currentMetadata.identificationMetadata`, `currentMetadata.highLevelStudyDesign` , `currentMetadata.studyPopulation` and `currentMetadata.studyIntervention` , `currentMetadata.studyDescription`."}, "name": "fields", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Studies Criteria  Uid  Studies Get", "type": "array", "items": {"$ref": "#/components/schemas/Study"}}}}}, "404": {"description": "Not Found - The criteria with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/criteria/{uid}/parameters": {"get": {"tags": ["Criteria"], "summary": "Returns all template parameters available for the criteria identified by 'uid'. Includes the available values per parameter.", "description": "Returns all template parameters used in the criteria template\nthat is the basis for the criteria identified by 'uid'. \nIncludes the available values per parameter.\n\nThe returned parameters are ordered\n0. as they occur in the criteria template\n\nPer parameter, the parameter.values are ordered by\n0. value.name ascending\n\nNote that parameters may be used multiple times in templates.\nIn that case, the same parameter (with the same values) is included multiple times in the response.\n    ", "operationId": "get_parameters_criteria__uid__parameters_get", "parameters": [{"description": "The unique id of the criteria.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the criteria."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameters Criteria  Uid  Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates": {"get": {"tags": ["Objective Templates"], "summary": "Returns all objective templates in their latest/newest version.", "description": "Allowed parameters include : filter on fields, sort by field name with sort direction, pagination", "operationId": "get_objective_templates_objective_templates_get", "parameters": [{"description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_ObjectiveTemplate_"}}, "text/csv": {"example": "\n\"library\",\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n                    <?xml version=\"1.0\" encoding=\"UTF-8\" ?><root><data type=\"list\"><item type=\"dict\"><uid type=\"str\">e9117175-918f-489e-9a6e-65e0025233a6</uid><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19T11:51:43.000Z</startDate><status type=\"str\">Draft</status><version type=\"str\">0.2</version><changeDescription type=\"str\">Test</changeDescription><userInitials type=\"str\">TODO Initials</userInitials></item></data></root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Objective Templates"], "summary": "Creates a new objective template in 'Draft' status.", "description": "This request is only valid if the objective template\n* belongs to a library that allows creating (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n* The objective template will be linked to a library.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an objective template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an objective is created out of the objective template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe objective template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same objective template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "create_objective_template_objective_templates_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Objective Template", "allOf": [{"$ref": "#/components/schemas/ObjectiveTemplateCreateInput"}], "description": "The objective template that shall be created."}}}}, "responses": {"201": {"description": "Created - The objective template was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective template name is not valid.\n- The library does not allow to create objective templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The library with the specified 'libraryName' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/headers": {"get": {"tags": ["Objective Templates"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_objective_templates_headers_get", "parameters": [{"description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Objective Templates Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}": {"get": {"tags": ["Objective Templates"], "summary": "Returns the latest/newest version of a specific objective template identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_objective_template_objective_templates__uid__get", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "If specified, the representation of the objective template in that status is returned (if existent). This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, the representation of the objective template in that status is returned (if existent). This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "If specified, the latest/newest representation of the objective template in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ...", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified, the latest/newest representation of the objective template in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "query"}, {"description": "if specified counts data will be returned along object", "required": false, "schema": {"title": "Return Instantiation Counts", "type": "boolean", "description": "if specified counts data will be returned along object", "default": false}, "name": "return_instantiation_counts", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ObjectiveTemplateWithCount"}}}}, "404": {"description": "Not Found - The objective template with the specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Objective Templates"], "summary": "Deletes the objective template identified by 'uid'.", "description": "This request is only valid if \n\n* the objective template is in 'Draft' status and\n* the objective template has never been in 'Final' status and\n* the objective template has no references to any objectives and\n* the objective template belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_objective_template_objective_templates__uid__delete", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The objective template was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective template is not in draft status.\n- The objective template was already in final state or is in use.\n- The library does not allow to delete objective templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An objective template with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Objective Templates"], "summary": "Updates the objective template identified by 'uid'.", "description": "This request is only valid if the objective template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\nParameters in the 'name' property can only be changed if the objective template has never been approved.\nOnce the objective template has been approved, only the surrounding text (excluding the parameters) can be changed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an objective template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an objective is created out of the objective template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe objective template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same objective template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "edit_objective_templates__uid__patch", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Objective Template", "allOf": [{"$ref": "#/components/schemas/ObjectiveTemplateEditInput"}], "description": "The new content of the objective template including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective template is not in draft status.\n- The objective template name is not valid.\n- The library does not allow to edit draft versions.\n- The change of parameters of previously approved objective templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The objective template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}/versions": {"get": {"tags": ["Objective Templates"], "summary": "Returns the version history of a specific objective template identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_objective_template_versions_objective_templates__uid__versions_get", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Objective Template Versions Objective Templates  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/ObjectiveTemplateVersion"}}}, "text/csv": {"example": "\n\"library\";\"uid\";\"name\";\"startDate\";\"endDate\";\"status\";\"version\";\"changeDescription\";\"userInitials\"\n\"Sponsor\";\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\";\"First  [ComparatorIntervention]\";\"2020-10-22T10:19:29+00:00\";;\"Draft\";\"0.1\";\"Initial version\";\"NdSJ\"\n"}, "text/xml": {"example": "\n                    <?xml version=\"1.0\" encoding=\"UTF-8\" ?><root><data type=\"list\"><item type=\"dict\"><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19 11:51:43+00:00</startDate><endDate type=\"str\">None</endDate><status type=\"str\">Draft</status><version type=\"str\">0.2</version><changeDescription type=\"str\">Test</changeDescription><userInitials type=\"str\">TODO Initials</userInitials></item><item type=\"dict\"><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19 11:51:07+00:00</startDate><endDate type=\"str\">2020-11-19 11:51:43+00:00</endDate><status type=\"str\">Draft</status><version type=\"str\">0.1</version><changeDescription type=\"str\">Initial version</changeDescription><userInitials type=\"str\">TODO user initials</userInitials></item></data></root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "404": {"description": "Not Found - The objective template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}/versions/{version}": {"get": {"tags": ["Objective Templates"], "summary": "Returns a specific version of a specific objective template identified by 'uid' and 'version'.", "description": "**Multiple versions**:\n\nTechnically, there can be multiple versions of the objective template with the same version number. This is due to the fact, that the version number remains the same when inactivating or reactivating an objective template (switching between 'Final' and 'Retired' status). \n\nIn that case the latest/newest representation is returned.", "operationId": "get_objective_template_version_objective_templates__uid__versions__version__get", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "A specific version number of the objective template. The version number is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits.\nE.g. '0.1', '0.2', '1.0', ...", "required": true, "schema": {"title": "Version", "type": "string", "description": "A specific version number of the objective template. The version number is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits.\nE.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}, "404": {"description": "Not Found - The objective template with the specified 'uid' and 'version' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}/releases": {"get": {"tags": ["Objective Templates"], "summary": "List all final versions of a template identified by 'uid', including number of studies using a specific version", "operationId": "get_objective_template_releases_objective_templates__uid__releases_get", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Objective Template Releases Objective Templates  Uid  Releases Get", "type": "array", "items": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}}, "404": {"description": "Not Found - The objective template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}/groupings": {"patch": {"tags": ["Objective Templates"], "summary": "Updates the groupings of the objective template identified by 'uid'.", "description": "This request is only valid if the template\n    * belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n    \n    This is version independent : it won't trigger a status or a version change.\n    ", "operationId": "patch_groupings_objective_templates__uid__groupings_patch", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Groupings", "allOf": [{"$ref": "#/components/schemas/ObjectiveTemplateEditGroupingsInput"}], "description": "The lists of UIDs for the new groupings to be set, grouped by groupings to be updated."}}}}, "responses": {"200": {"description": "No content - The groupings for this template were successfully updated.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}, "404": {"description": "Not Found - The template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}/default-parameter-values": {"patch": {"tags": ["Objective Templates"], "summary": "Edit the default parameter values of the objective template identified by 'uid'.", "description": "This request is only valid if the objective template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\nThis endpoint can be used to either :\n* Create a new set of default parameter values\n* Edit an existing set of default parameter values\n\n", "operationId": "patch_default_parameter_values_objective_templates__uid__default_parameter_values_patch", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Body_patch_default_parameter_values_objective_templates__uid__default_parameter_values_patch"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective template is not in draft status.\n- The objective template name is not valid.\n- The library does not allow to edit draft versions.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The objective template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}/new-version": {"post": {"tags": ["Objective Templates"], "summary": "Creates a new version of the objective template identified by 'uid'.", "description": "This request is only valid if the objective template\n* is in 'Final' or 'Retired' status only (so no latest 'Draft' status exists) and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The latest 'Final' or 'Retired' version will remain the same as before.\n* The status of the new version will be automatically set to 'Draft'.\n* The 'version' property of the new version will be automatically set to the version of the latest 'Final' or 'Retired' version increased by +0.1.\n\nParameters in the 'name' property cannot be changed with this request.\nOnly the surrounding text (excluding the parameters) can be changed.\n", "operationId": "create_new_version_objective_templates__uid__new_version_post", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Objective Template", "allOf": [{"$ref": "#/components/schemas/ObjectiveTemplateEditInput"}], "description": "The content of the objective template for the new 'Draft' version including the change description."}}}}, "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective template is not in final or retired status or has a draft status.\n- The objective template name is not valid.\n- The library does not allow to create a new version.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The objective template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}/approve": {"post": {"tags": ["Objective Templates"], "summary": "Approves the objective template identified by 'uid'.", "description": "This request is only valid if the objective template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_objective_templates__uid__approve_post", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"required": false, "schema": {"title": "Cascade", "type": "boolean", "default": false}, "name": "cascade", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective template is not in draft status.\n- The library does not allow to approve drafts.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The objective template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "409": {"description": "Conflict - there are objectives created from template and cascade is false", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}/inactivate": {"post": {"tags": ["Objective Templates"], "summary": "Inactivates/deactivates the objective template identified by 'uid'.", "description": "This request is only valid if the objective template\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_objective_templates__uid__inactivate_post", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective template is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The objective template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}/reactivate": {"post": {"tags": ["Objective Templates"], "summary": "Reactivates the objective template identified by 'uid'.", "description": "This request is only valid if the objective template\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_objective_templates__uid__reactivate_post", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective template is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The objective template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/{uid}/parameters": {"get": {"tags": ["Objective Templates"], "summary": "Returns all parameters used in the objective template identified by 'uid'. Includes the available values per parameter.", "description": "The returned parameters are ordered\n0. as they occur in the objective template\n\nPer parameter, the parameter.values are ordered by\n0. value.name ascending\n\nNote that parameters may be used multiple times in templates.\nIn that case, the same parameter (with the same values) is included multiple times in the response.\n    ", "operationId": "get_parameters_objective_templates__uid__parameters_get", "parameters": [{"description": "The unique id of the objective template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "name": "uid", "in": "path"}, {"description": "Optionally, the uid of the study to subset the parameters to (e.g. for StudyEndpoints parameters)", "required": false, "schema": {"title": "Study Uid", "type": "string", "description": "Optionally, the uid of the study to subset the parameters to (e.g. for StudyEndpoints parameters)"}, "name": "study_uid", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameters Objective Templates  Uid  Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objective-templates/pre-validate": {"post": {"tags": ["Objective Templates"], "summary": "Validates the content of an objective template without actually processing it.", "description": "Be aware that - even if this request is accepted - there is no guarantee that\na following request to e.g. *[POST] /objective-templates* or *[PATCH] /objective-templates/{uid}*\nwith the same content will succeed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an objective template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an objective is created out of the objective template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe objective template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same objective template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "pre_validate_objective_templates_pre_validate_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Objective Template", "allOf": [{"$ref": "#/components/schemas/ObjectiveTemplateNameInput"}], "description": "The content of the objective template that shall be validated."}}}}, "responses": {"202": {"description": "Accepted. The content is valid and may be submitted in another request.", "content": {"application/json": {"schema": {}}}}, "403": {"description": "Forbidden. The content is invalid - Reasons include e.g.: \n- The syntax of the 'name' is not valid.\n- One of the parameters wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives": {"get": {"tags": ["Objectives"], "summary": "Returns all final versions of objectives referenced by any study.", "operationId": "get_all_objectives_get", "parameters": [{"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_Objective_"}}, "text/csv": {"example": "\n\"library\",\"objectiveTemplate\",\"uid\",\"objective\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"First  [ComparatorIntervention]\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",First Intervention,\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Objectives"], "summary": "Creates a new objective in 'Draft' status.", "description": "This request is only valid if\n* the specified objective template is in 'Final' status and\n* the specified library allows creating objectives (the 'isEditable' property of the library needs to be true) and\n* the objective does not yet exist (no objective with the same content in 'Final' or 'Draft' status).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n", "operationId": "create_objectives_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Objective", "allOf": [{"$ref": "#/components/schemas/ObjectiveCreateInput"}], "description": "Related parameters of the objective that shall be created."}}}}, "responses": {"201": {"description": "Created - The objective was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Objective"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The provided list of parameters is invalid.\n- The library does not allow to create objectives.\n- The objective does already exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The library with the specified 'libraryName' could not be found.\n- The objective template with the specified 'objectiveTemplateUid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives/headers": {"get": {"tags": ["Objectives"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_objectives_headers_get", "parameters": [{"description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Objectives Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives/{uid}": {"get": {"tags": ["Objectives"], "summary": "Returns the latest/newest version of a specific objective identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_objectives__uid__get", "parameters": [{"description": "The unique id of the objective.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective."}, "name": "uid", "in": "path"}, {"description": "If specified, the latest/newest representation of the objective at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified, the latest/newest representation of the objective at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified, the representation of the objective in that status is returned (if existent). This may be particularly useful if the objective has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, the representation of the objective in that status is returned (if existent). This may be particularly useful if the objective has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "If specified, the latest/newest representation of the objective in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ...", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified, the latest/newest representation of the objective in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Objective"}}}}, "404": {"description": "Not Found - The objective with the specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Objectives"], "summary": "Deletes the objective identified by 'uid'.", "description": "This request is only valid if \n\n* the objective is in 'Draft' status and\n* the objective has never been in 'Final' status and\n* the objective belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_objectives__uid__delete", "parameters": [{"description": "The unique id of the objective.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The objective was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective is not in draft status.\n- The objective was already in final state or is in use.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An objective with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Objectives"], "summary": "Updates the objective identified by 'uid'.", "description": "This request is only valid if the objective\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n", "operationId": "edit_objectives__uid__patch", "parameters": [{"description": "The unique id of the objective.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Objective", "allOf": [{"$ref": "#/components/schemas/ObjectiveEditInput"}], "description": "The new parameter values for the objective including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Objective"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective is not in draft status.\n- The objective had been in 'Final' status before.\n- The provided list of parameters is invalid.\n- The library does not allow to edit draft versions.\n- The objective does already exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The objective with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives/get-by-name/{name}": {"get": {"tags": ["Objectives"], "summary": "Returns the latest/newest version of a specific objective identified by 'name'.", "description": "Gets an object by name - uses LATEST_DRAFT and LATEST_FINAL relations", "operationId": "get_by_name_objectives_get_by_name__name__get", "parameters": [{"required": true, "schema": {"title": "Name", "type": "string"}, "name": "name", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Objective"}}}}, "404": {"description": "Not Found - objective with the specified 'name' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives/{uid}/versions": {"get": {"tags": ["Objectives"], "summary": "Returns the version history of a specific objective identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_versions_objectives__uid__versions_get", "parameters": [{"description": "The unique id of the objective.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Objectives  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/ObjectiveVersion"}}}}}, "404": {"description": "Not Found - The objective with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives/{uid}/studies": {"get": {"tags": ["Objectives"], "summary": "Get Studies", "operationId": "get_studies_objectives__uid__studies_get", "parameters": [{"description": "The unique id of the objective.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective."}, "name": "uid", "in": "path"}, {"description": "Parameter specifies which parts of the whole Study Definition representation to retrieve. In the form of comma separated name of the fields prefixed by (optional) `+`  if the client wishes to retrieve the field or `-` if the client wants to skip the field. If not specified identification metadata and version metadata are retrieved. If value starts with `+` or `-` above default is extended or reduced by the specified fields otherwise (if not started with `+` or `-`) provided fields specification replaces the default. Currently supported fields are `currentMetadata.identificationMetadata`, `currentMetadata.highLevelStudyDesign` , `currentMetadata.studyPopulation` and `currentMetadata.studyIntervention` , `currentMetadata.studyDescription`.", "required": false, "schema": {"title": "Fields", "type": "string", "description": "Parameter specifies which parts of the whole Study Definition representation to retrieve. In the form of comma separated name of the fields prefixed by (optional) `+`  if the client wishes to retrieve the field or `-` if the client wants to skip the field. If not specified identification metadata and version metadata are retrieved. If value starts with `+` or `-` above default is extended or reduced by the specified fields otherwise (if not started with `+` or `-`) provided fields specification replaces the default. Currently supported fields are `currentMetadata.identificationMetadata`, `currentMetadata.highLevelStudyDesign` , `currentMetadata.studyPopulation` and `currentMetadata.studyIntervention` , `currentMetadata.studyDescription`."}, "name": "fields", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Studies Objectives  Uid  Studies Get", "type": "array", "items": {"$ref": "#/components/schemas/Study"}}}}}, "404": {"description": "Not Found - The objective with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives/preview": {"post": {"tags": ["Objectives"], "summary": "Previews the creation of a new objective.", "description": "This request is only valid if\n* the specified objective template is in 'Final' status and\n* the specified library allows creating objectives (the 'isEditable' property of the library needs to be true) and\n* the objective does not yet exist (no objective with the same content in 'Final' or 'Draft' status).\n\nIf the request succeeds:\n* No objective will be created, but the result of the request will show what the objective will look like.\n", "operationId": "preview_objectives_preview_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Objective", "allOf": [{"$ref": "#/components/schemas/ObjectiveCreateInput"}], "description": "Related parameters of the objective that shall be previewed."}}}}, "responses": {"200": {"description": "Success - The objective is able to be created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Objective"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The provided list of parameters is invalid.\n- The library does not allow to create objectives.\n- The objective does already exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The library with the specified 'libraryName' could not be found.\n- The objective template with the specified 'objectiveTemplateUid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives/{uid}/approve": {"post": {"tags": ["Objectives"], "summary": "Approves the objective identified by 'uid'.", "description": "This request is only valid if the objective\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_objectives__uid__approve_post", "parameters": [{"description": "The unique id of the objective.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Objective"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective is not in draft status.\n- The library does not allow to approve objective.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The objective with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives/{uid}/inactivate": {"post": {"tags": ["Objectives"], "summary": "Inactivates/deactivates the objective identified by 'uid'.", "description": "This request is only valid if the objective\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_objectives__uid__inactivate_post", "parameters": [{"description": "The unique id of the objective.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Objective"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The objective with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives/{uid}/reactivate": {"post": {"tags": ["Objectives"], "summary": "Reactivates the objective identified by 'uid'.", "description": "This request is only valid if the objective\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_objectives__uid__reactivate_post", "parameters": [{"description": "The unique id of the objective.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Objective"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The objective is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The objective with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/objectives/{uid}/parameters": {"get": {"tags": ["Objectives"], "summary": "Returns all template parameters available for the objective identified by 'uid'. Includes the available values per parameter.", "description": "Returns all template parameters used in the objective template that is the basis for the objective identified by 'uid'. Includes the available values per parameter.", "operationId": "get_parameters_objectives__uid__parameters_get", "parameters": [{"description": "The unique id of the objective.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the objective."}, "name": "uid", "in": "path"}, {"description": "Optionally, the uid of the study to subset the parameters to (e.g. for StudyEndpoints parameters)", "required": false, "schema": {"title": "Study Uid", "type": "string", "description": "Optionally, the uid of the study to subset the parameters to (e.g. for StudyEndpoints parameters)"}, "name": "study_uid", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameters Objectives  Uid  Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates": {"get": {"tags": ["Endpoint Templates"], "summary": "Returns all endpoint templates in their latest/newest version.", "description": "Allowed parameters include : filter on fields, sort by field name with sort direction, pagination", "operationId": "get_endpoint_templates_endpoint_templates_get", "parameters": [{"description": "If specified, only those endpoint templates will be returned that are currently in the specified status. This may be particularly useful if the endpoint template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those endpoint templates will be returned that are currently in the specified status. This may be particularly useful if the endpoint template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_EndpointTemplate_"}}, "text/csv": {"example": "\n\"library\",\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\", <>\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<root>\n    <data type=\"list\">\n        <item type=\"dict\">\n            <uid type=\"str\">e9117175-918f-489e-9a6e-65e0025233a6</uid>\n            <name type=\"str\">\"First  [ComparatorIntervention]</name>\n            <startDate type=\"str\">2020-11-19T11:51:43.000Z</startDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.2</version>\n            <changeDescription type=\"str\">Test</changeDescription>\n            <userInitials type=\"str\">TODO Initials</userInitials>\n        </item>\n  </data>\n</root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Endpoint Templates"], "summary": "Creates a new endpoint template in 'Draft' status.", "description": "This request is only valid if the endpoint template\n* belongs to a library that allows creating (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n* The endpoint template will be linked to a library.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an endpoint template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an endpoint is created out of the endpoint template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /template-parameters/* endpoint for available parameters and their values.\n\nThe endpoint template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same endpoint template 'name'.\n\n*Example*:\n\nname='This is my endpoint for [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "create_endpoint_template_endpoint_templates_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Endpoint Template", "allOf": [{"$ref": "#/components/schemas/EndpointTemplateCreateInput"}], "description": "The endpoint template that shall be created."}}}}, "responses": {"201": {"description": "Created - The endpoint template was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EndpointTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint template name is not valid.\n- The library does not allow to create endpoint templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The library with the specified 'libraryName' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/headers": {"get": {"tags": ["Endpoint Templates"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_endpoint_templates_headers_get", "parameters": [{"description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Endpoint Templates Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/{uid}": {"get": {"tags": ["Endpoint Templates"], "summary": "Returns the latest/newest version of a specific endpoint template identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_endpoint_template_endpoint_templates__uid__get", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "if specified counts data will be returned along object", "required": false, "schema": {"title": "Return Instantiation Counts", "type": "boolean", "description": "if specified counts data will be returned along object", "default": false}, "name": "return_instantiation_counts", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EndpointTemplateWithCount"}}}}, "404": {"description": "Not Found - The endpoint template with the specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Endpoint Templates"], "summary": "Deletes the endpoint template identified by 'uid'.", "description": "This request is only valid if \n\n* the endpoint template is in 'Draft' status and\n* the endpoint template has never been in 'Final' status and\n* the endpoint template has no references to any endpoints and\n* the endpoint template belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_endpoint_template_endpoint_templates__uid__delete", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The endpoint template was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint template is not in draft status.\n- The endpoint template was already in final state or is in use.\n- The library does not allow to delete endpoint templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An endpoint template with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Endpoint Templates"], "summary": "Updates the endpoint template identified by 'uid'.", "description": "This request is only valid if the endpoint template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\nParameters in the 'name' property can only be changed if the endpoint template has never been approved.\nOnce the endpoint template has been approved, only the surrounding text (excluding the parameters) can be changed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an endpoint template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an endpoint is created out of the endpoint template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /template-parameters/* endpoint for available parameters and their values.\n\nThe endpoint template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same endpoint template 'name'.\n\n*Example*:\n\nname='This is my endpoint for [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "edit_endpoint_templates__uid__patch", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Endpoint Template", "allOf": [{"$ref": "#/components/schemas/EndpointTemplateEditInput"}], "description": "The new content of the endpoint template including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EndpointTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint template is not in draft status.\n- The endpoint template name is not valid.\n- The library does not allow to edit draft versions.\n- The change of parameters of previously approved endpoint templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The endpoint template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/{uid}/versions": {"get": {"tags": ["Endpoint Templates"], "summary": "Returns the version history of a specific endpoint template identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_endpoint_template_versions_endpoint_templates__uid__versions_get", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Endpoint Template Versions Endpoint Templates  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/EndpointTemplateVersion"}}}, "text/csv": {"example": "\n\"library\",\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<root>\n    <data type=\"list\">\n        <item type=\"dict\">\n            <name type=\"str\">First  [ComparatorIntervention]</name>\n            <startDate type=\"str\">2020-11-19 11:51:43+00:00</startDate>\n            <endDate type=\"str\">None</endDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.2</version>\n            <changeDescription type=\"str\">Test</changeDescription>\n            <userInitials type=\"str\">TODO Initials</userInitials>\n        </item>\n        <item type=\"dict\">\n            <name type=\"str\">First  [ComparatorIntervention]</name>\n            <startDate type=\"str\">2020-11-19 11:51:07+00:00</startDate>\n            <endDate type=\"str\">2020-11-19 11:51:43+00:00</endDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.1</version>\n            <changeDescription type=\"str\">Initial version</changeDescription>\n            <userInitials type=\"str\">TODO user initials</userInitials>\n        </item>\n    </data>\n</root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "404": {"description": "Not Found - The endpoint template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/{uid}/releases": {"get": {"tags": ["Endpoint Templates"], "summary": "List all final versions of a template identified by 'uid', including number of studies using a specific version", "operationId": "get_objective_template_releases_endpoint_templates__uid__releases_get", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Objective Template Releases Endpoint Templates  Uid  Releases Get", "type": "array", "items": {"$ref": "#/components/schemas/ObjectiveTemplate"}}}}}, "404": {"description": "Not Found - The endpoint template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/{uid}/groupings": {"patch": {"tags": ["Endpoint Templates"], "summary": "Updates the groupings of the endpoint template identified by 'uid'.", "description": "This request is only valid if the template\n    * belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n    \n    This is version independent : it won't trigger a status or a version change.\n    ", "operationId": "patch_groupings_endpoint_templates__uid__groupings_patch", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Groupings", "allOf": [{"$ref": "#/components/schemas/EndpointTemplateEditGroupingsInput"}], "description": "The lists of UIDs for the new groupings to be set, grouped by groupings to be updated."}}}}, "responses": {"200": {"description": "No content - The groupings for this template were successfully updated.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EndpointTemplate"}}}}, "404": {"description": "Not Found - The template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/{uid}/default-parameter-values": {"patch": {"tags": ["Endpoint Templates"], "summary": "Edit the default parameter values of the endpoint template identified by 'uid'.", "description": "This request is only valid if the endpoint template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\nThis endpoint can be used to either :\n* Create a new set of default parameter values\n* Edit an existing set of default parameter values\n\n", "operationId": "patch_default_parameter_values_endpoint_templates__uid__default_parameter_values_patch", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Body_patch_default_parameter_values_endpoint_templates__uid__default_parameter_values_patch"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EndpointTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint template is not in draft status.\n- The endpoint template name is not valid.\n- The library does not allow to edit draft versions.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The endpoint template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/{uid}/new-version": {"post": {"tags": ["Endpoint Templates"], "summary": "Creates a new version of the endpoint template identified by 'uid'.", "description": "This request is only valid if the endpoint template\n* is in 'Final' or 'Retired' status only (so no latest 'Draft' status exists) and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The latest 'Final' or 'Retired' version will remain the same as before.\n* The status of the new version will be automatically set to 'Draft'.\n* The 'version' property of the new version will be automatically set to the version of the latest 'Final' or 'Retired' version increased by +0.1.\n\nParameters in the 'name' property cannot be changed with this request.\nOnly the surrounding text (excluding the parameters) can be changed.\n", "operationId": "create_new_version_endpoint_templates__uid__new_version_post", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Endpoint Template", "allOf": [{"$ref": "#/components/schemas/EndpointTemplateEditInput"}], "description": "The content of the endpoint template for the new 'Draft' version including the change description."}}}}, "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EndpointTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint template is not in final or retired status or has a draft status.\n- The endpoint template name is not valid.\n- The library does not allow to create a new version.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The endpoint template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/{uid}/approve": {"post": {"tags": ["Endpoint Templates"], "summary": "Approves the endpoint template identified by 'uid'.", "description": "This request is only valid if the endpoint template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_endpoint_templates__uid__approve_post", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"required": false, "schema": {"title": "Cascade", "type": "boolean", "default": false}, "name": "cascade", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EndpointTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint template is not in draft status.\n- The library does not allow to approve drafts.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The endpoint template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "409": {"description": "Conflict - there are objectives created from template and cascade is false", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/{uid}/inactivate": {"post": {"tags": ["Endpoint Templates"], "summary": "Inactivates/deactivates the endpoint template identified by 'uid'.", "description": "This request is only valid if the endpoint template\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_endpoint_templates__uid__inactivate_post", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EndpointTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint template is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The endpoint template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/{uid}/reactivate": {"post": {"tags": ["Endpoint Templates"], "summary": "Reactivates the endpoint template identified by 'uid'.", "description": "This request is only valid if the endpoint template\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_endpoint_templates__uid__reactivate_post", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EndpointTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint template is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The endpoint template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/{uid}/parameters": {"get": {"tags": ["Endpoint Templates"], "summary": "Returns all parameters used in the endpoint template identified by 'uid'. Includes the available values per parameter.", "description": "The returned parameters are ordered\n0. as they occur in the endpoint template\n\nPer parameter, the parameter.values are ordered by\n0. value.name ascending\n\nNote that parameters may be used multiple times in templates.\nIn that case, the same parameter (with the same values) is included multiple times in the response.\n    ", "operationId": "get_parameters_endpoint_templates__uid__parameters_get", "parameters": [{"description": "The unique id of the endpoint template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameters Endpoint Templates  Uid  Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoint-templates/pre-validate": {"post": {"tags": ["Endpoint Templates"], "summary": "Validates the content of an endpoint template without actually processing it.", "description": "Be aware that - even if this request is accepted - there is no guarantee that\na following request to e.g. *[POST] /endpoint-templates* or *[PATCH] /endpoint-templates/{uid}*\nwith the same content will succeed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an endpoint template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an endpoint is created out of the endpoint template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /template-parameters/* endpoint for available parameters and their values.\n\nThe endpoint template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same endpoint template 'name'.\n\n*Example*:\n\nname='This is my endpoint for [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "pre_validate_endpoint_templates_pre_validate_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Endpoint Template", "allOf": [{"$ref": "#/components/schemas/EndpointTemplateNameInput"}], "description": "The content of the endpoint template that shall be validated."}}}}, "responses": {"202": {"description": "Accepted. The content is valid and may be submitted in another request.", "content": {"application/json": {"schema": {}}}}, "403": {"description": "Forbidden. The content is invalid - Reasons include e.g.: \n- The syntax of the 'name' is not valid.\n- One of the parameters wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints": {"get": {"tags": ["Endpoints"], "summary": "Returns all final versions of objectives referenced by any study.", "operationId": "get_all_endpoints_get", "parameters": [{"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_Endpoint_"}}, "text/csv": {"example": "\n\"library\",\"uid\",\"objective\",\"endpointTemplate\",\"endpoint\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"Objective\",\"First [ComparatorIntervention]\",\"First Intervention\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}, "text/xml": {"example": "\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<root>\n    <data type=\"list\">\n        <item type=\"dict\">\n            <library type=\"str\">Sponsor</library>\n            <uid type=\"str\">682d7003-8dcc-480d-b07b-878e659b8697</uid>\n            <objective type=\"str\">Test template new [glucose metabolism] [MACE+] totot</objective>\n            <endpointTemplate type=\"str\">Endpoint using [Activity] and [Indication]</endpointTemplate>\n            <endpoint type=\"str\">Endpoint using [body weight] and [type 2 diabetes]</endpoint>\n            <startDate type=\"str\">2020-11-26T13:43:23.000Z</startDate>\n            <endDate type=\"str\"></endDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.2</version>\n            <changeDescription type=\"str\">Changed indication</changeDescription>\n            <userInitials type=\"str\">TODO Initials</userInitials>\n        </item>\n    </data>\n</root>\n"}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Endpoints"], "summary": "Creates a new endpoint in 'Draft' status.", "description": "This request is only valid if\n* the specified endpoint template is in 'Final' status and\n* the specified objective is in 'Final' status and\n* the specified library allows creating endpoints (the 'isEditable' property of the library needs to be true) and\n* the endpoint does not yet exist (no endpoint with the same content in 'Final' or 'Draft' status).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n", "operationId": "create_endpoints_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Endpoint", "allOf": [{"$ref": "#/components/schemas/EndpointCreateInput"}], "description": "Related parameters of the endpoint that shall be created."}}}}, "responses": {"201": {"description": "Created - The endpoint was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Endpoint"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The provided list of parameters is invalid.\n- The objective wasn't found or it is not in 'Final' status.\n- The library does not allow to create endpoints.\n- The endpoint does already exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The library with the specified 'libraryName' could not be found.\n- The endpoint template with the specified 'endpointTemplateUid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints/headers": {"get": {"tags": ["Endpoints"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_endpoints_headers_get", "parameters": [{"description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Endpoints Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints/{uid}": {"get": {"tags": ["Endpoints"], "summary": "Returns the latest/newest version of a specific endpoint identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_endpoints__uid__get", "parameters": [{"description": "The unique id of the endpoint.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint."}, "name": "uid", "in": "path"}, {"description": "If specified, the latest/newest representation of the endpoint at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified, the latest/newest representation of the endpoint at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified, the representation of the endpoint in that status is returned (if existent). This may be particularly useful if the endpoint has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, the representation of the endpoint in that status is returned (if existent). This may be particularly useful if the endpoint has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "If specified, the latest/newest representation of the endpoint in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ...", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified, the latest/newest representation of the endpoint in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Endpoint"}}}}, "404": {"description": "Not Found - The endpoint with the specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Endpoints"], "summary": "Deletes the endpoint identified by 'uid'.", "description": "This request is only valid if \n\n* the endpoint is in 'Draft' status and\n* the endpoint has never been in 'Final' status and\n* the endpoint belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_endpoints__uid__delete", "parameters": [{"description": "The unique id of the endpoint.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The endpoint was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint is not in draft status.\n- The endpoint was already in final state or is in use.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An endpoint with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Endpoints"], "summary": "Updates the endpoint identified by 'uid'.", "description": "This request is only valid if the endpoint\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n* The link to the objective will remain as is.\n", "operationId": "edit_endpoints__uid__patch", "parameters": [{"description": "The unique id of the endpoint.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Endpoint", "allOf": [{"$ref": "#/components/schemas/EndpointEditInput"}], "description": "The new parameter values for the endpoint including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Endpoint"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint is not in draft status.\n- The endpoint had been in 'Final' status before.\n- The provided list of parameters is invalid.\n- The library does not allow to edit draft versions.\n- The endpoint does already exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The endpoint with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints/get-by-name/{name}": {"get": {"tags": ["Endpoints"], "summary": "Returns the latest/newest version of a specific endpoint identified by 'name'.", "description": "Gets an object by name - uses LATEST_DRAFT and LATEST_FINAL relations", "operationId": "get_by_name_endpoints_get_by_name__name__get", "parameters": [{"required": true, "schema": {"title": "Name", "type": "string"}, "name": "name", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Endpoint"}}}}, "404": {"description": "Not Found - The endpoint with the specified 'name' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints/{uid}/versions": {"get": {"tags": ["Endpoints"], "summary": "Returns the version history of a specific endpoint identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_versions_endpoints__uid__versions_get", "parameters": [{"description": "The unique id of the endpoint.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Endpoints  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/EndpointVersion"}}}, "text/csv": {"example": "\n\"library\",\"endpointTemplate\",\"objective\",\"uid\",\"endpoint\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"First [ComparatorIntervention]\",\"Objective\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First Intervention\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}, "text/xml": {"example": "\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<root>\n    <data type=\"list\">\n        <item type=\"dict\">\n            <library type=\"str\">Sponsor</library>\n            <endpointTemplate type=\"str\">Endpoint using [Activity] and [Indication]</endpointTemplate>\n            <objective type=\"str\">Test template new [glucose metabolism] [MACE+] totot</objective>\n            <uid type=\"str\">682d7003-8dcc-480d-b07b-878e659b8697</uid>\n            <endpoint type=\"str\">Endpoint using [body weight] and [type 2 diabetes]</endpoint>\n            <startDate type=\"str\">2020-11-26T13:43:23.000Z</startDate>\n            <endDate type=\"str\"></endDate>\n            <status type=\"str\">Draft</status>\n            <version type=\"str\">0.2</version>\n            <changeDescription type=\"str\">Changed indication</changeDescription>\n            <userInitials type=\"str\">TODO Initials</userInitials>\n        </item>\n    </data>\n</root>\n"}}}, "404": {"description": "Not Found - The endpoint with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints/{uid}/studies": {"get": {"tags": ["Endpoints"], "summary": "Get Studies", "operationId": "get_studies_endpoints__uid__studies_get", "parameters": [{"description": "The unique id of the endpoint.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint."}, "name": "uid", "in": "path"}, {"description": "Parameter specifies which parts of the whole Study Definition representation to retrieve. In the form of comma separated name of the fields prefixed by (optional) `+`  if the client wishes to retrieve the field or `-` if the client wants to skip the field. If not specified identification metadata and version metadata are retrieved. If value starts with `+` or `-` above default is extended or reduced by the specified fields otherwise (if not started with `+` or `-`) provided fields specification replaces the default. Currently supported fields are `currentMetadata.identificationMetadata`, `currentMetadata.highLevelStudyDesign` , `currentMetadata.studyPopulation` and `currentMetadata.studyIntervention` , `currentMetadata.studyDescription`.", "required": false, "schema": {"title": "Fields", "type": "string", "description": "Parameter specifies which parts of the whole Study Definition representation to retrieve. In the form of comma separated name of the fields prefixed by (optional) `+`  if the client wishes to retrieve the field or `-` if the client wants to skip the field. If not specified identification metadata and version metadata are retrieved. If value starts with `+` or `-` above default is extended or reduced by the specified fields otherwise (if not started with `+` or `-`) provided fields specification replaces the default. Currently supported fields are `currentMetadata.identificationMetadata`, `currentMetadata.highLevelStudyDesign` , `currentMetadata.studyPopulation` and `currentMetadata.studyIntervention` , `currentMetadata.studyDescription`."}, "name": "fields", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Studies Endpoints  Uid  Studies Get", "type": "array", "items": {"$ref": "#/components/schemas/Study"}}}}}, "404": {"description": "Not Found - The endpoint with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints/preview": {"post": {"tags": ["Endpoints"], "summary": "Previews the creation of a new endpoint.", "description": "This request is only valid if\n* the specified endpoint template is in 'Final' status and\n* the specified library allows creating endpoints (the 'isEditable' property of the library needs to be true) and\n* the endpoint does not yet exist (no endpoint with the same content in 'Final' or 'Draft' status).\n\nIf the request succeeds:\n* No endpoint will be created, but the result of the request will show what the endpoint will look like.\n", "operationId": "preview_endpoints_preview_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Endpoint", "allOf": [{"$ref": "#/components/schemas/EndpointCreateInput"}], "description": "Related parameters of the endpoint that shall be previewed."}}}}, "responses": {"200": {"description": "Success - The endpoint is able to be created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Endpoint"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The provided list of parameters is invalid.\n- The library does not allow to create endpoints.\n- The endpoint does already exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The library with the specified 'libraryName' could not be found.\n- The endpoint template with the specified 'endpointTemplateUid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints/{uid}/approve": {"post": {"tags": ["Endpoints"], "summary": "Approves the endpoint identified by 'uid'.", "description": "This request is only valid if the endpoint\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_endpoints__uid__approve_post", "parameters": [{"description": "The unique id of the endpoint.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Endpoint"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint is not in draft status.\n- The library does not allow to approve endpoints.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The endpoint with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints/{uid}/inactivate": {"post": {"tags": ["Endpoints"], "summary": "Inactivates/deactivates the endpoint identified by 'uid'.", "description": "This request is only valid if the endpoint\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_endpoints__uid__inactivate_post", "parameters": [{"description": "The unique id of the endpoint.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Endpoint"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The endpoint with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints/{uid}/reactivate": {"post": {"tags": ["Endpoints"], "summary": "Reactivates the endpoint identified by 'uid'.", "description": "This request is only valid if the endpoint\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_endpoints__uid__reactivate_post", "parameters": [{"description": "The unique id of the endpoint.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Endpoint"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The endpoint is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The endpoint with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/endpoints/{uid}/parameters": {"get": {"tags": ["Endpoints"], "summary": "Returns all template parameters available for the endpoint identified by 'uid'. Includes the available values per parameter.", "description": "Returns all template parameters used in the endpoint template\nthat is the basis for the endpoint identified by 'uid'. \nIncludes the available values per parameter.\n\nThe returned parameters are ordered\n0. as they occur in the endpoint template\n\nPer parameter, the parameter.values are ordered by\n0. value.name ascending\n\nNote that parameters may be used multiple times in templates.\nIn that case, the same parameter (with the same values) is included multiple times in the response.\n    ", "operationId": "get_parameters_endpoints__uid__parameters_get", "parameters": [{"description": "The unique id of the endpoint.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameters Endpoints  Uid  Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates": {"get": {"tags": ["Timeframe templates"], "summary": "Returns all timeframe templates in their latest/newest version.", "operationId": "get_timeframe_templates_timeframe_templates_get", "parameters": [{"description": "If specified, only those timeframe templates will be returned that are currently in the specified status. This may be particularly useful if the timeframe template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those timeframe templates will be returned that are currently in the specified status. This may be particularly useful if the timeframe template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_TimeframeTemplate_"}}, "text/csv": {"example": "\n\"library\",\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n                    <?xml version=\"1.0\" encoding=\"UTF-8\" ?><root><data type=\"list\"><item type=\"dict\"><uid type=\"str\">e9117175-918f-489e-9a6e-65e0025233a6</uid><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19T11:51:43.000Z</startDate><status type=\"str\">Draft</status><version type=\"str\">0.2</version><changeDescription type=\"str\">Test</changeDescription><userInitials type=\"str\">TODO Initials</userInitials></item></data></root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Timeframe templates"], "summary": "Creates a new timeframe template in 'Draft' status.", "description": "This request is only valid if the timeframe template\n* belongs to a library that allows creating (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n* The timeframe template will be linked to a library.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an timeframe template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an timeframe is created out of the timeframe template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe timeframe template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same timeframe template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "create_timeframe_template_timeframe_templates_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Timeframe Template", "allOf": [{"$ref": "#/components/schemas/TimeframeTemplateCreateInput"}], "description": "The timeframe template that shall be created."}}}}, "responses": {"201": {"description": "Created - The timeframe template was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimeframeTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe template name is not valid.\n- The library does not allow to create timeframe templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The library with the specified 'libraryName' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/headers": {"get": {"tags": ["Timeframe templates"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_timeframe_templates_headers_get", "parameters": [{"description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Timeframe Templates Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/{uid}": {"get": {"tags": ["Timeframe templates"], "summary": "Returns the latest/newest version of a specific timeframe template identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_timeframe_template_timeframe_templates__uid__get", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"description": "If specified, the latest/newest representation of the timeframe template at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified, the latest/newest representation of the timeframe template at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified, the representation of the timeframe template in that status is returned (if existent). This may be particularly useful if the timeframe template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, the representation of the timeframe template in that status is returned (if existent). This may be particularly useful if the timeframe template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "If specified, the latest/newest representation of the timeframe template in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ...", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified, the latest/newest representation of the timeframe template in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "query"}, {"description": "if specified counts data will be returned along object", "required": false, "schema": {"title": "Return Instantiation Counts", "type": "boolean", "description": "if specified counts data will be returned along object"}, "name": "return_instantiation_counts", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimeframeTemplateWithCount"}}}}, "404": {"description": "Not Found - The timeframe template with the specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Timeframe templates"], "summary": "Deletes the timeframe template identified by 'uid'.", "description": "This request is only valid if \n\n* the timeframe template is in 'Draft' status and\n* the timeframe template has never been in 'Final' status and\n* the timeframe template has no references to any timeframes and\n* the timeframe template belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_timeframe_template_timeframe_templates__uid__delete", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The timeframe template was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe template is not in draft status.\n- The timeframe template was already in final state or is in use.\n- The library does not allow to delete timeframe templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An timeframe template with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Timeframe templates"], "summary": "Updates the timeframe template identified by 'uid'.", "description": "This request is only valid if the timeframe template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\nParameters in the 'name' property can only be changed if the timeframe template has never been approved.\nOnce the timeframe template has been approved, only the surrounding text (excluding the parameters) can be changed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an timeframe template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an timeframe is created out of the timeframe template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe timeframe template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same timeframe template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "edit_timeframe_templates__uid__patch", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Timeframe Template", "allOf": [{"$ref": "#/components/schemas/TimeframeTemplateEditInput"}], "description": "The new content of the timeframe template including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimeframeTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe template is not in draft status.\n- The timeframe template name is not valid.\n- The library does not allow to edit draft versions.\n- The change of parameters of previously approved timeframe templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The timeframe template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/{uid}/versions": {"get": {"tags": ["Timeframe templates"], "summary": "Returns the version history of a specific timeframe template identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_timeframe_template_versions_timeframe_templates__uid__versions_get", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Timeframe Template Versions Timeframe Templates  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/TimeframeTemplateVersion"}}}, "text/csv": {"example": "\n\"library\";\"uid\";\"name\";\"startDate\";\"endDate\";\"status\";\"version\";\"changeDescription\";\"userInitials\"\n\"Sponsor\";\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\";\"First  [ComparatorIntervention]\";\"2020-10-22T10:19:29+00:00\";;\"Draft\";\"0.1\";\"Initial version\";\"NdSJ\"\n"}, "text/xml": {"example": "\n                    <?xml version=\"1.0\" encoding=\"UTF-8\" ?><root><data type=\"list\"><item type=\"dict\"><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19 11:51:43+00:00</startDate><endDate type=\"str\">None</endDate><status type=\"str\">Draft</status><version type=\"str\">0.2</version><changeDescription type=\"str\">Test</changeDescription><userInitials type=\"str\">TODO Initials</userInitials></item><item type=\"dict\"><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19 11:51:07+00:00</startDate><endDate type=\"str\">2020-11-19 11:51:43+00:00</endDate><status type=\"str\">Draft</status><version type=\"str\">0.1</version><changeDescription type=\"str\">Initial version</changeDescription><userInitials type=\"str\">TODO user initials</userInitials></item></data></root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "404": {"description": "Not Found - The timeframe template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/{uid}/versions/{version}": {"get": {"tags": ["Timeframe templates"], "summary": "Returns a specific version of a specific timeframe template identified by 'uid' and 'version'.", "description": "**Multiple versions**:\n\nTechnically, there can be multiple versions of the timeframe template with the same version number. This is due to the fact, that the version number remains the same when inactivating or reactivating an timeframe template (switching between 'Final' and 'Retired' status). \n\nIn that case the latest/newest representation is returned.", "operationId": "get_timeframe_template_version_timeframe_templates__uid__versions__version__get", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"description": "A specific version number of the timeframe template. The version number is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits.\nE.g. '0.1', '0.2', '1.0', ...", "required": true, "schema": {"title": "Version", "type": "string", "description": "A specific version number of the timeframe template. The version number is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits.\nE.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimeframeTemplate"}}}}, "404": {"description": "Not Found - The timeframe template with the specified 'uid' and 'version' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/{uid}/new-version": {"post": {"tags": ["Timeframe templates"], "summary": "Creates a new version of the timeframe template identified by 'uid'.", "description": "This request is only valid if the timeframe template\n* is in 'Final' or 'Retired' status only (so no latest 'Draft' status exists) and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The latest 'Final' or 'Retired' version will remain the same as before.\n* The status of the new version will be automatically set to 'Draft'.\n* The 'version' property of the new version will be automatically set to the version of the latest 'Final' or 'Retired' version increased by +0.1.\n\nParameters in the 'name' property cannot be changed with this request.\nOnly the surrounding text (excluding the parameters) can be changed.\n", "operationId": "create_new_version_timeframe_templates__uid__new_version_post", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Timeframe Template", "allOf": [{"$ref": "#/components/schemas/TimeframeTemplateEditInput"}], "description": "The content of the timeframe template for the new 'Draft' version including the change description."}}}}, "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimeframeTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe template is not in final or retired status or has a draft status.\n- The timeframe template name is not valid.\n- The library does not allow to create a new version.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The timeframe template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/{uid}/approve": {"post": {"tags": ["Timeframe templates"], "summary": "Approves the timeframe template identified by 'uid'.", "description": "This request is only valid if the timeframe template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\nIf timeframe template has any related objects status will not be updated but item will be extended with \nrelated item counts.\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_timeframe_templates__uid__approve_post", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"required": false, "schema": {"title": "Cascade", "type": "boolean", "default": false}, "name": "cascade", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimeframeTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe template is not in draft status.\n- The library does not allow to approve drafts.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The timeframe template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "409": {"description": "Conflict - there are timeframes created from template and cascade is false", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/{uid}/approve_cascading": {"post": {"tags": ["Timeframe templates"], "summary": "Approves the timeframe template identified by 'uid'. Updates all related items", "description": "This request is only valid if the timeframe template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_cascading_timeframe_templates__uid__approve_cascading_post", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimeframeTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe template is not in draft status.\n- The library does not allow to approve drafts.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The timeframe template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/{uid}/inactivate": {"post": {"tags": ["Timeframe templates"], "summary": "Inactivates/deactivates the timeframe template identified by 'uid'.", "description": "This request is only valid if the timeframe template\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_timeframe_templates__uid__inactivate_post", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimeframeTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe template is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The timeframe template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/{uid}/reactivate": {"post": {"tags": ["Timeframe templates"], "summary": "Reactivates the timeframe template identified by 'uid'.", "description": "This request is only valid if the timeframe template\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_timeframe_templates__uid__reactivate_post", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimeframeTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe template is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The timeframe template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/{uid}/parameters": {"get": {"tags": ["Timeframe templates"], "summary": "Returns all parameters used in the timeframe template identified by 'uid'. Includes the available values per parameter.", "description": "The returned parameters are ordered\n0. as they occur in the timeframe template\n\nPer parameter, the parameter.values are ordered by\n0. value.name ascending\n\nNote that parameters may be used multiple times in templates.\nIn that case, the same parameter (with the same values) is included multiple times in the response.\n    ", "operationId": "get_parameters_timeframe_templates__uid__parameters_get", "parameters": [{"description": "The unique id of the timeframe template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "name": "uid", "in": "path"}, {"description": "if specified only valida parameters for a given study will be returned.", "required": false, "schema": {"title": "Study Uid", "type": "string", "description": "if specified only valida parameters for a given study will be returned."}, "name": "study_uid", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameters Timeframe Templates  Uid  Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/ComplexTemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframe-templates/pre-validate": {"post": {"tags": ["Timeframe templates"], "summary": "Validates the content of an timeframe template without actually processing it.", "description": "Be aware that - even if this request is accepted - there is no guarantee that\na following request to e.g. *[POST] /timeframe-templates* or *[PATCH] /timeframe-templates/{uid}*\nwith the same content will succeed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an timeframe template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an timeframe is created out of the timeframe template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe timeframe template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same timeframe template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [Timeframe].'\n\n'Intervention', 'Activity' and 'Timeframe' are parameters.", "operationId": "pre_validate_timeframe_templates_pre_validate_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Timeframe Template", "allOf": [{"$ref": "#/components/schemas/TimeframeTemplateNameInput"}], "description": "The content of the timeframe template that shall be validated."}}}}, "responses": {"202": {"description": "Accepted. The content is valid and may be submitted in another request.", "content": {"application/json": {"schema": {}}}}, "403": {"description": "Forbidden. The content is invalid - Reasons include e.g.: \n- The syntax of the 'name' is not valid.\n- One of the parameters wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframes": {"get": {"tags": ["Timeframes"], "summary": "Returns all timeframes in their latest/newest version.", "operationId": "get_all_timeframes_get", "parameters": [{"description": "If specified, only those timeframes will be returned that are currently in the specified status. This may be particularly useful if the timeframe has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those timeframes will be returned that are currently in the specified status. This may be particularly useful if the timeframe has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_Timeframe_"}}, "text/csv": {"example": "\n\"library\",\"timeframeTemplate\",\"uid\",\"timeframe\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"First  [ComparatorIntervention]\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",First Intervention,\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Timeframes"], "summary": "Creates a new timeframe in 'Draft' status.", "description": "This request is only valid if\n* the specified timeframe template is in 'Final' status and\n* the specified library allows creating timeframes (the 'isEditable' property of the library needs to be true) and\n* the timeframe does not yet exist (no timeframe with the same content in 'Final' or 'Draft' status).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n", "operationId": "create_timeframes_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Timeframe", "allOf": [{"$ref": "#/components/schemas/TimeframeCreateInput"}], "description": "Related parameters of the timeframe that shall be created."}}}}, "responses": {"201": {"description": "Created - The timeframe was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Timeframe"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The provided list of parameters is invalid.\n- The library does not allow to create timeframes.\n- The timeframe does already exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The library with the specified 'libraryName' could not be found.\n- The timeframe template with the specified 'timeframeTemplateUid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframes/headers": {"get": {"tags": ["Timeframes"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_timeframes_headers_get", "parameters": [{"description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those objective templates will be returned that are currently in the specified status. This may be particularly useful if the objective template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Timeframes Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframes/{uid}": {"get": {"tags": ["Timeframes"], "summary": "Returns the latest/newest version of a specific timeframe identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_timeframes__uid__get", "parameters": [{"description": "The unique id of the timeframe.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe."}, "name": "uid", "in": "path"}, {"description": "If specified, the latest/newest representation of the timeframe at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified, the latest/newest representation of the timeframe at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified, the representation of the timeframe in that status is returned (if existent). This may be particularly useful if the timeframe has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, the representation of the timeframe in that status is returned (if existent). This may be particularly useful if the timeframe has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "If specified, the latest/newest representation of the timeframe in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ...", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified, the latest/newest representation of the timeframe in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Timeframe"}}}}, "404": {"description": "Not Found - The timeframe with the specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Timeframes"], "summary": "Deletes the timeframe identified by 'uid'.", "description": "This request is only valid if \n\n* the timeframe is in 'Draft' status and\n* the timeframe has never been in 'Final' status and\n* the timeframe belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_timeframes__uid__delete", "parameters": [{"description": "The unique id of the timeframe.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The timeframe was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe is not in draft status.\n- The timeframe was already in final state or is in use.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An timeframe with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Timeframes"], "summary": "Updates the timeframe identified by 'uid'.", "description": "This request is only valid if the timeframe\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n", "operationId": "edit_timeframes__uid__patch", "parameters": [{"description": "The unique id of the timeframe.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Timeframe", "allOf": [{"$ref": "#/components/schemas/TimeframeEditInput"}], "description": "The new parameter values for the timeframe including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Timeframe"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe is not in draft status.\n- The timeframe had been in 'Final' status before.\n- The provided list of parameters is invalid.\n- The library does not allow to edit draft versions.\n- The timeframe does already exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The timeframe with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframes/get-by-name/{name}": {"get": {"tags": ["Timeframes"], "summary": "Returns the latest/newest version of a specific timeframe identified by 'name'.", "description": "Gets an object by name - uses LATEST_DRAFT and LATEST_FINAL relations", "operationId": "get_by_name_timeframes_get_by_name__name__get", "parameters": [{"required": true, "schema": {"title": "Name", "type": "string"}, "name": "name", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Timeframe"}}}}, "404": {"description": "Not Found - The timeframe with the specified 'name' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframes/{uid}/versions": {"get": {"tags": ["Timeframes"], "summary": "Returns the version history of a specific timeframe identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_versions_timeframes__uid__versions_get", "parameters": [{"description": "The unique id of the timeframe.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Timeframes  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/TimeframeVersion"}}}}}, "404": {"description": "Not Found - The timeframe with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframes/preview": {"post": {"tags": ["Timeframes"], "summary": "Previews the creation of a new timeframe.", "description": "This request is only valid if\n* the specified timeframe template is in 'Final' status and\n* the specified library allows creating timeframe (the 'isEditable' property of the library needs to be true) and\n* the timeframe does not yet exist (no timeframe with the same content in 'Final' or 'Draft' status).\n\nIf the request succeeds:\n* No timeframe will be created, but the result of the request will show what the timeframe will look like.\n", "operationId": "preview_timeframes_preview_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Timeframe", "allOf": [{"$ref": "#/components/schemas/TimeframeCreateInput"}], "description": "Related parameters of the timeframe that shall be previewed."}}}}, "responses": {"200": {"description": "Success - The timeframe is able to be created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Timeframe"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The provided list of parameters is invalid.\n- The library does not allow to create timeframes.\n- The timeframe does already exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The library with the specified 'libraryName' could not be found.\n- The timeframe template with the specified 'timeframeTemplateUid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframes/{uid}/approve": {"post": {"tags": ["Timeframes"], "summary": "Approves the timeframe identified by 'uid'.", "description": "This request is only valid if the timeframe\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_timeframes__uid__approve_post", "parameters": [{"description": "The unique id of the timeframe.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Timeframe"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe is not in draft status.\n- The library does not allow to approve timeframe.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The timeframe with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframes/{uid}/inactivate": {"post": {"tags": ["Timeframes"], "summary": "Inactivates/deactivates the timeframe identified by 'uid'.", "description": "This request is only valid if the timeframe\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_timeframes__uid__inactivate_post", "parameters": [{"description": "The unique id of the timeframe.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Timeframe"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The timeframe with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframes/{uid}/reactivate": {"post": {"tags": ["Timeframes"], "summary": "Reactivates the timeframe identified by 'uid'.", "description": "This request is only valid if the timeframe\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_timeframes__uid__reactivate_post", "parameters": [{"description": "The unique id of the timeframe.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Timeframe"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The timeframe is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The timeframe with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/timeframes/{uid}/parameters": {"get": {"tags": ["Timeframes"], "summary": "Returns all template parameters available for the timeframe identified by 'uid'. Includes the available values per parameter.", "description": "Returns all template parameters used in the timeframe template that is the basis for the timeframe identified by 'uid'. Includes the available values per parameter.", "operationId": "get_parameters_timeframes__uid__parameters_get", "parameters": [{"description": "The unique id of the timeframe.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe."}, "name": "uid", "in": "path"}, {"description": "if specified only valid parameters for a given study will be returned.", "required": false, "schema": {"title": "Study Uid", "type": "string", "description": "if specified only valid parameters for a given study will be returned."}, "name": "study_uid", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameters Timeframes  Uid  Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/ComplexTemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/libraries": {"get": {"tags": ["Libraries"], "summary": "Returns all libraries", "operationId": "get_libraries_libraries_get", "parameters": [{"description": "If specified, only those libraries are returned that are editable. \nValid values are: 'true' or 'false'.", "required": false, "schema": {"title": "Iseditable", "type": "boolean", "description": "If specified, only those libraries are returned that are editable. \nValid values are: 'true' or 'false'."}, "name": "isEditable", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Libraries Libraries Get", "type": "array", "items": {"$ref": "#/components/schemas/Library"}}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Libraries"], "summary": "Creates a new library.", "operationId": "create_library_libraries_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/Library"}}}}, "responses": {"201": {"description": "Created - The library was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Library"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/catalogues": {"get": {"tags": ["CT catalogues"], "summary": "Returns all controlled terminology catalogues.", "operationId": "get_catalogues_ct_catalogues_get", "parameters": [{"description": "If specified, only catalogues from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only catalogues from given library are returned."}, "name": "library", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Catalogues Ct Catalogues Get", "type": "array", "items": {"$ref": "#/components/schemas/CTCatalogue"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/catalogues/changes": {"get": {"tags": ["CT catalogues"], "summary": "List changes between codelists and terms in CT Catalogues.", "operationId": "get_catalogues_changes_ct_catalogues_changes_get", "parameters": [{"description": "If specified, only codelists and terms from given library_name are compared.", "required": false, "schema": {"title": "Library Name", "type": "string", "description": "If specified, only codelists and terms from given library_name are compared."}, "name": "library_name", "in": "query"}, {"description": "If specified, only codelists and terms from given catalogue_name are compared.", "required": false, "schema": {"title": "Catalogue Name", "type": "string", "description": "If specified, only codelists and terms from given catalogue_name are compared."}, "name": "catalogue_name", "in": "query"}, {"description": "The type of the comparison.\nValid types are 'attributes' or 'sponsor'", "required": true, "schema": {"title": "Comparison Type", "type": "string", "description": "The type of the comparison.\nValid types are 'attributes' or 'sponsor'"}, "name": "comparison_type", "in": "query"}, {"description": "The start datetime to perform comparison, for instance '2020-03-27T00:00:00'", "required": true, "schema": {"title": "Start Datetime", "type": "string", "description": "The start datetime to perform comparison, for instance '2020-03-27T00:00:00'", "format": "date-time"}, "name": "start_datetime", "in": "query"}, {"description": "The end datetime to perform comparison, for instance '2020-06-26T00:00:00'\nIf it is not passed, then the current datetime is assigned.", "required": false, "schema": {"title": "End Datetime", "type": "string", "description": "The end datetime to perform comparison, for instance '2020-06-26T00:00:00'\nIf it is not passed, then the current datetime is assigned.", "format": "date-time"}, "name": "end_datetime", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCatalogueChanges"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/packages": {"get": {"tags": ["CT packages"], "summary": "Returns all controlled terminology packages.", "operationId": "get_packages_ct_packages_get", "parameters": [{"description": "If specified, only packages from given catalogue are returned.", "required": false, "schema": {"title": "Catalogue Name", "type": "string", "description": "If specified, only packages from given catalogue are returned."}, "name": "catalogue_name", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Packages Ct Packages Get", "type": "array", "items": {"$ref": "#/components/schemas/CTPackage"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/packages/changes": {"get": {"tags": ["CT packages"], "summary": "Returns changes between codelists and terms inside two different packages.", "operationId": "get_packages_changes_between_codelists_and_terms_ct_packages_changes_get", "parameters": [{"required": true, "schema": {"title": "Catalogue Name", "type": "string"}, "name": "catalogue_name", "in": "query"}, {"description": "The date for the old package, for instance '2020-03-27'\nThe possible dates for given catalogue_name can be retrieved by the /ct/packages/dates endpoint", "required": true, "schema": {"title": "Old Package Date", "type": "string", "description": "The date for the old package, for instance '2020-03-27'\nThe possible dates for given catalogue_name can be retrieved by the /ct/packages/dates endpoint", "format": "date"}, "name": "old_package_date", "in": "query"}, {"description": "The datetime for the new package, for instance '2020-06-26'\nThe possible dates for given catalogue_name can be retrieved by the /ct/packages/dates endpoint", "required": true, "schema": {"title": "New Package Date", "type": "string", "description": "The datetime for the new package, for instance '2020-06-26'\nThe possible dates for given catalogue_name can be retrieved by the /ct/packages/dates endpoint", "format": "date"}, "name": "new_package_date", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTPackageChanges"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/packages/{codelistuid}/changes": {"get": {"tags": ["CT packages"], "summary": "Returns changes from given codelist and all associated terms inside two different packages.", "operationId": "get_packages_changes_between_codelist_and_all_associated_terms_ct_packages__codelistuid__changes_get", "parameters": [{"description": "The unique id of the CTCodelist", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelist"}, "name": "codelistuid", "in": "path"}, {"required": true, "schema": {"title": "Catalogue Name", "type": "string"}, "name": "catalogue_name", "in": "query"}, {"description": "The date for the old package, for instance '2020-03-27'\nThe possible dates for given catalogue_name can be retrieved by the /ct/packages/dates endpoint", "required": true, "schema": {"title": "Old Package Date", "type": "string", "description": "The date for the old package, for instance '2020-03-27'\nThe possible dates for given catalogue_name can be retrieved by the /ct/packages/dates endpoint", "format": "date"}, "name": "old_package_date", "in": "query"}, {"description": "The date for the new package, for instance '2020-06-26'\nThe possible dates for given catalogue_name can be retrieved by the /ct/packages/dates endpoint", "required": true, "schema": {"title": "New Package Date", "type": "string", "description": "The date for the new package, for instance '2020-06-26'\nThe possible dates for given catalogue_name can be retrieved by the /ct/packages/dates endpoint", "format": "date"}, "name": "new_package_date", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTPackageChangesSpecificCodelist"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/packages/dates": {"get": {"tags": ["CT packages"], "summary": "Returns all effective dates for packages in a given catalogue.", "operationId": "get_package_dates_ct_packages_dates_get", "parameters": [{"required": true, "schema": {"title": "Catalogue Name", "type": "string"}, "name": "catalogue_name", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTPackageDates"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists": {"get": {"tags": ["CT codelists"], "summary": "Returns all codelists names and attributes.", "operationId": "get_codelists_ct_codelists_get", "parameters": [{"description": "If specified, only codelists from given catalogue are returned.", "required": false, "schema": {"title": "Cataloguename", "type": "string", "description": "If specified, only codelists from given catalogue are returned."}, "name": "cataloguename", "in": "query"}, {"description": "If specified, only codelists from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only codelists from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only codelists from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only codelists from given package are returned."}, "name": "package", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CTCodelistNameAndAttributes_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["CT codelists"], "summary": "Creates new codelist.", "description": "The following nodes are created\n* CTCodelistRoot\n  * CTCodelistAttributesRoot\n  * CTCodelistAttributesValue\n  * CTCodelistNameRoot\n  * CTCodelistNameValue\n", "operationId": "create_ct_codelists_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Codelist Input", "allOf": [{"$ref": "#/components/schemas/CTCodelistCreateInput"}], "description": "Properties to create CTCodelistAttributes and CTCodelistName."}}}}, "responses": {"201": {"description": "Created - The codelist was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelist"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The catalogue does not exist.\n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistUid}/sub-codelists": {"get": {"tags": ["CT codelists"], "summary": "Returns all sub codelists names and attributes that only have the provided terms.", "operationId": "get_sub_codelists_that_have_given_terms_ct_codelists__codelistUid__sub_codelists_get", "parameters": [{"description": "The unique id of the CTCodelistRoot", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistRoot"}, "name": "codelistUid", "in": "path"}, {"description": "A list of term uids", "required": true, "schema": {"title": "Termuids", "type": "array", "items": {"type": "string"}, "description": "A list of term uids"}, "name": "termUids", "in": "query"}, {"description": "If specified, only codelists from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only codelists from given library are returned."}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CTCodelistNameAndAttributes_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/headers": {"get": {"tags": ["CT codelists"], "summary": "Returns possibles values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_ct_codelists_headers_get", "parameters": [{"description": "If specified, only codelists from given catalogue are returned.", "required": false, "schema": {"title": "Cataloguename", "type": "string", "description": "If specified, only codelists from given catalogue are returned."}, "name": "cataloguename", "in": "query"}, {"description": "If specified, only terms from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only terms from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only terms from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only terms from given package are returned."}, "name": "package", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Ct Codelists Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistuid}/add-term": {"post": {"tags": ["CT codelists"], "summary": "Adds new CTTerm to CTCodelist.", "operationId": "add_term_ct_codelists__codelistuid__add_term_post", "parameters": [{"description": "The unique id of the CTCodelistRoot", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistRoot"}, "name": "codelistuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Term Input", "allOf": [{"$ref": "#/components/schemas/CTCodelistTermInput"}], "description": "UID of the CTTermRoot node."}}}}, "responses": {"201": {"description": "The HAS_TERM relationship was successfully created.\nThe TemplateParameter labels and HAS_VALUE relationship were successfully added if codelist identified by codelist_uid is a TemplateParameter.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelist"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The codelist does not exist.\n- The term does not exist.\n- The codelist is not extensible.\n- The codelist already has passed term.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistuid}/remove-term": {"post": {"tags": ["CT codelists"], "summary": "Removes given CTTerm from CTCodelist.", "operationId": "remove_term_ct_codelists__codelistuid__remove_term_post", "parameters": [{"description": "The unique id of the CTCodelistRoot", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistRoot"}, "name": "codelistuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Term Input", "allOf": [{"$ref": "#/components/schemas/CTCodelistTermInput"}], "description": "UID of the CTTermRoot node."}}}}, "responses": {"201": {"description": "The HAS_TERM relationship was successfully deleted and HAD_TERM relationship was successfully created.\nThe HAS_VALUE relationship was successfully deleted if codelist identified by codelist_uid is a TemplateParameter", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelist"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The codelist does not exist.\n- The term does not exist.\n- The codelist is not extensible.\n- The codelist doesn't have passed term.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/attributes": {"get": {"tags": ["CT codelists"], "summary": "Returns all codelists attributes.", "operationId": "get_codelists_ct_codelists_attributes_get", "parameters": [{"description": "If specified, only codelists from given catalogue are returned.", "required": false, "schema": {"title": "Cataloguename", "type": "string", "description": "If specified, only codelists from given catalogue are returned."}, "name": "cataloguename", "in": "query"}, {"description": "If specified, only codelists from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only codelists from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only codelists from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only codelists from given package are returned."}, "name": "package", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CTCodelistAttributes_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/attributes/headers": {"get": {"tags": ["CT codelists"], "summary": "Returns possibles values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_ct_codelists_attributes_headers_get", "parameters": [{"description": "If specified, only codelists from given catalogue are returned.", "required": false, "schema": {"title": "Cataloguename", "type": "string", "description": "If specified, only codelists from given catalogue are returned."}, "name": "cataloguename", "in": "query"}, {"description": "If specified, only terms from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only terms from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only terms from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only terms from given package are returned."}, "name": "package", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Ct Codelists Attributes Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistuid}/attributes": {"get": {"tags": ["CT codelists"], "summary": "Returns the latest/newest version of a specific codelist identified by 'uid'", "operationId": "get_codelist_attributes_ct_codelists__codelistuid__attributes_get", "parameters": [{"description": "The unique id of the CTCodelistAttributes", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistAttributes"}, "name": "codelistuid", "in": "path"}, {"description": "If specified then the latest/newest representation of the sponsor defined name for CTCodelistAttributesValue at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is omitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified then the latest/newest representation of the sponsor defined name for CTCodelistAttributesValue at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is omitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified then the representation of the sponsor defined name for CTCodelistAttributesValue in that status is returned (if existent).\nThis is useful if the CTCodelistAttributesValue has a status 'Draft' and a status 'Final'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified then the representation of the sponsor defined name for CTCodelistAttributesValue in that status is returned (if existent).\nThis is useful if the CTCodelistAttributesValue has a status 'Draft' and a status 'Final'."}, "name": "status", "in": "query"}, {"description": "If specified then the latest/newest representation of the sponsor defined name for CTCodelistAttributesValue in that version is returned.\nOnly exact matches are considered. The version is specified in the following format:<major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0',", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified then the latest/newest representation of the sponsor defined name for CTCodelistAttributesValue in that version is returned.\nOnly exact matches are considered. The version is specified in the following format:<major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0',"}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelistAttributes"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["CT codelists"], "summary": "Updates the codelist identified by 'codelistuid'.", "description": "This request is only valid if the codelist\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n", "operationId": "edit_ct_codelists__codelistuid__attributes_patch", "parameters": [{"description": "The unique id of the CTCodelistAttributes", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistAttributes"}, "name": "codelistuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Codelist Input", "allOf": [{"$ref": "#/components/schemas/CTCodelistAttributesEditInput"}], "description": "The new parameter values for the codelist including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelistAttributes"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The codelist is not in draft status.\n- The codelist had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The codelist with the specified 'codelistuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistuid}/attributes/versions": {"get": {"tags": ["CT codelists"], "summary": "Returns the version history of a specific CTCodelistAttributes identified by 'codelistuid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_versions_ct_codelists__codelistuid__attributes_versions_get", "parameters": [{"description": "The unique id of the CTCodelistAttributes", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistAttributes"}, "name": "codelistuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Ct Codelists  Codelistuid  Attributes Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/CTCodelistAttributesVersion"}}}}}, "404": {"description": "Not Found - The codelist with the specified 'codelistuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistuid}/attributes/new-version": {"post": {"tags": ["CT codelists"], "summary": "Creates a new codelist in 'Draft' status.", "description": "This request is only valid if\n* the specified codelist is in 'Final' status and\n* the specified library allows creating codelists (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically to 'new-version'.\n* The 'version' property will be increased by '0.1'.\n", "operationId": "create_ct_codelists__codelistuid__attributes_new_version_post", "parameters": [{"description": "The unique id of the CTCodelistAttributes", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistAttributes"}, "name": "codelistuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "Created - The codelist was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelistAttributes"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create codelists.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The codelist is not in final status.\n- The codelist with the specified 'codelistuid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistuid}/attributes/approve": {"post": {"tags": ["CT codelists"], "summary": "Approves the codelist identified by 'codelistuid'.", "description": "This request is only valid if the codelist\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically to 'Approved version'.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_ct_codelists__codelistuid__attributes_approve_post", "parameters": [{"description": "The unique id of the CTCodelistAttributes", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistAttributes"}, "name": "codelistuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelistAttributes"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The codelist is not in draft status.\n- The library does not allow to approve codelist.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The codelist with the specified 'codelistuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/names": {"get": {"tags": ["CT codelists"], "summary": "Returns all codelists names.", "operationId": "get_codelists_ct_codelists_names_get", "parameters": [{"description": "If specified, only codelists from given catalogue are returned.", "required": false, "schema": {"title": "Cataloguename", "type": "string", "description": "If specified, only codelists from given catalogue are returned."}, "name": "cataloguename", "in": "query"}, {"description": "If specified, only codelists from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only codelists from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only codelists from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only codelists from given package are returned."}, "name": "package", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CTCodelistName_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/names/headers": {"get": {"tags": ["CT codelists"], "summary": "Returns possibles values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_ct_codelists_names_headers_get", "parameters": [{"description": "If specified, only codelists from given catalogue are returned.", "required": false, "schema": {"title": "Cataloguename", "type": "string", "description": "If specified, only codelists from given catalogue are returned."}, "name": "cataloguename", "in": "query"}, {"description": "If specified, only terms from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only terms from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only terms from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only terms from given package are returned."}, "name": "package", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Ct Codelists Names Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistuid}/names": {"get": {"tags": ["CT codelists"], "summary": "Returns the latest/newest version of a specific codelist identified by 'uid'", "operationId": "get_codelist_names_ct_codelists__codelistuid__names_get", "parameters": [{"description": "The unique id of the CTCodelistName", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistName"}, "name": "codelistuid", "in": "path"}, {"description": "If specified then the latest/newest representation of the sponsor defined name for CTCodelistNameValue at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is omitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified then the latest/newest representation of the sponsor defined name for CTCodelistNameValue at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is omitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified then the representation of the sponsor defined name for CTCodelistNameValue in that status is returned (if existent).\nThis is useful if the CTCodelistNameValue has a status 'Draft' and a status 'Final'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified then the representation of the sponsor defined name for CTCodelistNameValue in that status is returned (if existent).\nThis is useful if the CTCodelistNameValue has a status 'Draft' and a status 'Final'."}, "name": "status", "in": "query"}, {"description": "If specified then the latest/newest representation of the sponsor defined name for CTCodelistNameValue in that version is returned.\nOnly exact matches are considered. The version is specified in the following format:<major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0',", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified then the latest/newest representation of the sponsor defined name for CTCodelistNameValue in that version is returned.\nOnly exact matches are considered. The version is specified in the following format:<major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0',"}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelistName"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["CT codelists"], "summary": "Updates the codelist identified by 'codelistuid'.", "description": "This request is only valid if the codelist\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n", "operationId": "edit_ct_codelists__codelistuid__names_patch", "parameters": [{"description": "The unique id of the CTCodelistName", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistName"}, "name": "codelistuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Codelist Input", "allOf": [{"$ref": "#/components/schemas/CTCodelistNameEditInput"}], "description": "The new parameter values for the codelist including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelistName"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The codelist is not in draft status.\n- The codelist had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The codelist with the specified 'codelistuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistuid}/names/versions": {"get": {"tags": ["CT codelists"], "summary": "Returns the version history of a specific CTCodelistName identified by 'codelistuid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_versions_ct_codelists__codelistuid__names_versions_get", "parameters": [{"description": "The unique id of the CTCodelistName", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistName"}, "name": "codelistuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Ct Codelists  Codelistuid  Names Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/CTCodelistNameVersion"}}}}}, "404": {"description": "Not Found - The codelist with the specified 'codelistuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistuid}/names/new-version": {"post": {"tags": ["CT codelists"], "summary": "Creates a new codelist in 'Draft' status.", "description": "This request is only valid if\n* the specified codelist is in 'Final' status and\n* the specified library allows creating codelists (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically to 'new-version'.\n* The 'version' property will be increased by '0.1'.\n", "operationId": "create_ct_codelists__codelistuid__names_new_version_post", "parameters": [{"description": "The unique id of the CTCodelistName", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistName"}, "name": "codelistuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "Created - The codelist was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelistName"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create codelists.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The codelist is not in final status.\n- The codelist with the specified 'codelistuid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/codelists/{codelistuid}/names/approve": {"post": {"tags": ["CT codelists"], "summary": "Approves the codelist identified by 'codelistuid'.", "description": "This request is only valid if the codelist\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically to 'Approved version'.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_ct_codelists__codelistuid__names_approve_post", "parameters": [{"description": "The unique id of the CTCodelistName", "required": true, "schema": {"title": "Codelistuid", "type": "string", "description": "The unique id of the CTCodelistName"}, "name": "codelistuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTCodelistName"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The codelist is not in draft status.\n- The library does not allow to approve codelist.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The codelist with the specified 'codelistuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms": {"get": {"tags": ["CT terms"], "summary": "Returns all terms names and attributes.", "operationId": "get_all_terms_ct_terms_get", "parameters": [{"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Uid", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_uid", "in": "query"}, {"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Name", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_name", "in": "query"}, {"description": "If specified, only terms from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only terms from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only terms from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only terms from given package are returned."}, "name": "package", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CTTermNameAndAttributes_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["CT terms"], "summary": "Creates new ct term.", "description": "The following nodes are created\n* CTTermRoot\n  * CTTermAttributesRoot\n  * CTTermAttributesValue\n  * CTTermNameRoot\n  * CTTermNameValue\n", "operationId": "create_ct_terms_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Term Input", "allOf": [{"$ref": "#/components/schemas/CTTermCreateInput"}], "description": "Properties to create CTTermAttributes and CTTermName."}}}}, "responses": {"201": {"description": "Created - The term was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTerm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The catalogue does not exist.\n- The library does not exist..\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/headers": {"get": {"tags": ["CT terms"], "summary": "Returns possibles values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_ct_terms_headers_get", "parameters": [{"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Uid", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_uid", "in": "query"}, {"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Name", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_name", "in": "query"}, {"description": "If specified, only terms from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only terms from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only terms from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only terms from given package are returned."}, "name": "package", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Ct Terms Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{term_uid}/add-parent": {"post": {"tags": ["CT terms"], "summary": "Adds a CT Term Root node as a parent to the selected term node.", "operationId": "add_parent_ct_terms__term_uid__add_parent_post", "parameters": [{"description": "The unique id of the ct term.", "required": true, "schema": {"title": "Term Uid", "type": "string", "description": "The unique id of the ct term."}, "name": "term_uid", "in": "path"}, {"description": "The unique id for the parent node.", "required": true, "schema": {"title": "Parent Uid", "type": "string", "description": "The unique id for the parent node."}, "name": "parent_uid", "in": "query"}, {"description": "The type of the parent relationship.\nValid types are 'type' or 'subtype', 'valid_for_epoch'", "required": true, "schema": {"title": "Relationship Type", "type": "string", "description": "The type of the parent relationship.\nValid types are 'type' or 'subtype', 'valid_for_epoch'"}, "name": "relationship_type", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "Created - The term was successfully added as a parent to the term identified by term-uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTerm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term already has a defined parent of the same type.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'term-uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{term_uid}/remove-parent": {"post": {"tags": ["CT terms"], "summary": "Removes a parent term from the selected term node", "operationId": "remove_parent_ct_terms__term_uid__remove_parent_post", "parameters": [{"description": "The unique id of the ct term.", "required": true, "schema": {"title": "Term Uid", "type": "string", "description": "The unique id of the ct term."}, "name": "term_uid", "in": "path"}, {"description": "The unique id for the parent node.", "required": true, "schema": {"title": "Parent Uid", "type": "string", "description": "The unique id for the parent node."}, "name": "parent_uid", "in": "query"}, {"description": "The type of the parent relationship.\nValid types are 'type' or 'subtype'", "required": true, "schema": {"title": "Relationship Type", "type": "string", "description": "The type of the parent relationship.\nValid types are 'type' or 'subtype'"}, "name": "relationship_type", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "Created - The term was successfully removed as a parent to the term identified by term-uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTerm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term already has no defined parent with given parent-uid and relationship type.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'term-uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{term_uid}/order": {"patch": {"tags": ["CT terms"], "summary": "Change an order of codelist-term relationship", "description": "Reordering will create new HAS_TERM relationship.", "operationId": "patch_new_term_order_ct_terms__term_uid__order_patch", "parameters": [{"description": "The unique id of the ct term.", "required": true, "schema": {"title": "Term Uid", "type": "string", "description": "The unique id of the ct term."}, "name": "term_uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "New Order Input", "allOf": [{"$ref": "#/components/schemas/CTTermNewOrder"}], "description": "Parameters needed for the reorder action."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTerm"}}}}, "403": {"description": "Forbidden - Order is larger than the number of selections", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - When there exist no study endpoint with the study endpoint uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/attributes": {"get": {"tags": ["CT terms"], "summary": "Returns all terms attributes.", "operationId": "get_terms_ct_terms_attributes_get", "parameters": [{"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Uid", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_uid", "in": "query"}, {"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Name", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_name", "in": "query"}, {"description": "If specified, only terms from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only terms from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only terms from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only terms from given package are returned."}, "name": "package", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CTTermAttributes_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/attributes/headers": {"get": {"tags": ["CT terms"], "summary": "Returns possibles values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_ct_terms_attributes_headers_get", "parameters": [{"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Uid", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_uid", "in": "query"}, {"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Name", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_name", "in": "query"}, {"description": "If specified, only terms from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only terms from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only terms from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only terms from given package are returned."}, "name": "package", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Ct Terms Attributes Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/attributes": {"get": {"tags": ["CT terms"], "summary": "Returns the latest/newest version of a specific ct term identified by 'termuid'", "operationId": "get_term_attributes_ct_terms__termuid__attributes_get", "parameters": [{"description": "The unique id of the CTTermAttributes", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermAttributes"}, "name": "termuid", "in": "path"}, {"description": "If specified then the latest/newest representation of the CTTermAttributesValue at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is omitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified then the latest/newest representation of the CTTermAttributesValue at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is omitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified then the representation of the CTTermAttributesValue in that status is returned (if existent).\nThis is useful if the CTTermAttributesValue has a status 'Draft' and a status 'Final'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified then the representation of the CTTermAttributesValue in that status is returned (if existent).\nThis is useful if the CTTermAttributesValue has a status 'Draft' and a status 'Final'."}, "name": "status", "in": "query"}, {"description": "If specified then the latest/newest representation of the for CTTermAttributesValue in that version is returned.\nOnly exact matches are considered. The version is specified in the following format:<major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0',", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified then the latest/newest representation of the for CTTermAttributesValue in that version is returned.\nOnly exact matches are considered. The version is specified in the following format:<major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0',"}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermAttributes"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["CT terms"], "summary": "Deletes the term identified by 'termuid'.", "description": "This request is only valid if \n\n* the term is in 'Draft' status and\n* the term has never been in 'Final' status and\n* the term belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_ct_term_ct_terms__termuid__attributes_delete", "parameters": [{"description": "The unique id of the CTTermAttributes", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermAttributes"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The term was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in draft status.\n- The term was already in final state or is in use.\n- The library does not allow to delete term.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An term with the specified 'termuid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["CT terms"], "summary": "Updates the term identified by 'termuid'.", "description": "This request is only valid if the term\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n", "operationId": "edit_ct_terms__termuid__attributes_patch", "parameters": [{"description": "The unique id of the CTTermAttributes", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermAttributes"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Term Input", "allOf": [{"$ref": "#/components/schemas/CTTermAttributesEditInput"}], "description": "The new parameter values for the term including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermAttributes"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in draft status.\n- The term had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'termuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/attributes/versions": {"get": {"tags": ["CT terms"], "summary": "Returns the version history of a specific CTTermAttributes identified by 'termuid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_versions_ct_terms__termuid__attributes_versions_get", "parameters": [{"description": "The unique id of the CTTermAttributes", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermAttributes"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Ct Terms  Termuid  Attributes Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/CTTermAttributesVersion"}}}}}, "404": {"description": "Not Found - The codelist with the specified 'codelistuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/attributes/new-version": {"post": {"tags": ["CT terms"], "summary": "Creates a new term in 'Draft' status.", "description": "This request is only valid if\n* the specified term is in 'Final' status and\n* the specified library allows creating term (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically to 'new-version'.\n* The 'version' property will be increased by '0.1'.\n", "operationId": "create_ct_terms__termuid__attributes_new_version_post", "parameters": [{"description": "The unique id of the CTTermAttributes", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermAttributes"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "Created - The term was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermAttributes"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create tterm.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The term is not in final status.\n- The term with the specified 'codelistuid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/attributes/approve": {"post": {"tags": ["CT terms"], "summary": "Approves the term identified by 'termuid'.", "description": "This request is only valid if the term\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically to 'Approved version'.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_ct_terms__termuid__attributes_approve_post", "parameters": [{"description": "The unique id of the CTTermAttributes", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermAttributes"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermAttributes"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in draft status.\n- The library does not allow to approve term.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'termuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/attributes/inactivate": {"post": {"tags": ["CT terms"], "summary": "Inactivates/deactivates the term identified by 'termuid'.", "description": "This request is only valid if the term\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_ct_terms__termuid__attributes_inactivate_post", "parameters": [{"description": "The unique id of the CTTermAttributes", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermAttributes"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermAttributes"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'termuid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/attributes/reactivate": {"post": {"tags": ["CT terms"], "summary": "Reactivates the term identified by 'termuid'.", "description": "This request is only valid if the term\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_ct_terms__termuid__attributes_reactivate_post", "parameters": [{"description": "The unique id of the CTTermAttributes", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermAttributes"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermAttributes"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'termuid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/names": {"get": {"tags": ["CT terms"], "summary": "Returns all terms names.", "operationId": "get_terms_ct_terms_names_get", "parameters": [{"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Uid", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_uid", "in": "query"}, {"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Name", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_name", "in": "query"}, {"description": "If specified, only terms from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only terms from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only terms from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only terms from given package are returned."}, "name": "package", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CTTermName_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/names/headers": {"get": {"tags": ["CT terms"], "summary": "Returns possibles values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_ct_terms_names_headers_get", "parameters": [{"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Uid", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_uid", "in": "query"}, {"description": "If specified, only terms from given codelist are returned.", "required": false, "schema": {"title": "Codelist Name", "type": "string", "description": "If specified, only terms from given codelist are returned."}, "name": "codelist_name", "in": "query"}, {"description": "If specified, only terms from given library are returned.", "required": false, "schema": {"title": "Library", "type": "string", "description": "If specified, only terms from given library are returned."}, "name": "library", "in": "query"}, {"description": "If specified, only terms from given package are returned.", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only terms from given package are returned."}, "name": "package", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Ct Terms Names Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/names": {"get": {"tags": ["CT terms"], "summary": "Returns the latest/newest version of a specific ct term identified by 'termuid'", "operationId": "get_term_names_ct_terms__termuid__names_get", "parameters": [{"description": "The unique id of the CTTermNames", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermNames"}, "name": "termuid", "in": "path"}, {"description": "If specified then the latest/newest representation of the CTTermNameValue at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is omitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified then the latest/newest representation of the CTTermNameValue at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is omitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified then the representation of the CTTermNameValue in that status is returned (if existent).\nThis is useful if the CTTermNameValue has a status 'Draft' and a status 'Final'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified then the representation of the CTTermNameValue in that status is returned (if existent).\nThis is useful if the CTTermNameValue has a status 'Draft' and a status 'Final'."}, "name": "status", "in": "query"}, {"description": "If specified then the latest/newest representation of the for CTTermNameValue in that version is returned.\nOnly exact matches are considered. The version is specified in the following format:<major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0',", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified then the latest/newest representation of the for CTTermNameValue in that version is returned.\nOnly exact matches are considered. The version is specified in the following format:<major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0',"}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermName"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["CT terms"], "summary": "Deletes the term identified by 'termuid'.", "description": "This request is only valid if \n\n* the term is in 'Draft' status and\n* the term has never been in 'Final' status and\n* the term belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_ct_term_ct_terms__termuid__names_delete", "parameters": [{"description": "The unique id of the CTTermNames", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermNames"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The term was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in draft status.\n- The term was already in final state or is in use.\n- The library does not allow to delete term.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An term with the specified 'termuid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["CT terms"], "summary": "Updates the term identified by 'termuid'.", "description": "This request is only valid if the term\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true). \n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n", "operationId": "edit_ct_terms__termuid__names_patch", "parameters": [{"description": "The unique id of the CTTermNames", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermNames"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Term Input", "allOf": [{"$ref": "#/components/schemas/CTTermNameEditInput"}], "description": "The new parameter values for the term including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermName"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in draft status.\n- The term had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'termuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/names/versions": {"get": {"tags": ["CT terms"], "summary": "Returns the version history of a specific CTTermName identified by 'termuid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_versions_ct_terms__termuid__names_versions_get", "parameters": [{"description": "The unique id of the CTTermNames", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermNames"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Ct Terms  Termuid  Names Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameVersion"}}}}}, "404": {"description": "Not Found - The codelist with the specified 'codelistuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/names/new-version": {"post": {"tags": ["CT terms"], "summary": "Creates a new term in 'Draft' status.", "description": "This request is only valid if\n* the specified term is in 'Final' status and\n* the specified library allows creating term (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically to 'new-version'.\n* The 'version' property will be increased by '0.1'.\n", "operationId": "create_ct_terms__termuid__names_new_version_post", "parameters": [{"description": "The unique id of the CTTermNames", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermNames"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "Created - The term was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermName"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create tterm.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The term is not in final status.\n- The term with the specified 'codelistuid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/names/approve": {"post": {"tags": ["CT terms"], "summary": "Approves the term identified by 'termuid'.", "description": "This request is only valid if the term\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically to 'Approved version'.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_ct_terms__termuid__names_approve_post", "parameters": [{"description": "The unique id of the CTTermNames", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermNames"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermName"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in draft status.\n- The library does not allow to approve term.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'termuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/names/inactivate": {"post": {"tags": ["CT terms"], "summary": "Inactivates/deactivates the term identified by 'termuid'.", "description": "This request is only valid if the term\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_ct_terms__termuid__names_inactivate_post", "parameters": [{"description": "The unique id of the CTTermNames", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermNames"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermName"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'termuid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/terms/{termuid}/names/reactivate": {"post": {"tags": ["CT terms"], "summary": "Reactivates the term identified by 'termuid'.", "description": "This request is only valid if the term\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically. \n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_ct_terms__termuid__names_reactivate_post", "parameters": [{"description": "The unique id of the CTTermNames", "required": true, "schema": {"title": "Termuid", "type": "string", "description": "The unique id of the CTTermNames"}, "name": "termuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTTermName"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'termuid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/ct/stats": {"get": {"tags": ["CT stats"], "summary": "Returns stats about Catalogues, Packages and Terms", "operationId": "get_stats_ct_stats_get", "parameters": [{"description": "Optional, number of latest codelists to return", "required": false, "schema": {"title": "Latestcount", "type": "integer", "description": "Optional, number of latest codelists to return", "default": 3}, "name": "latestCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTStats"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/codelists/{library}": {"get": {"tags": ["Dictionary codelists"], "summary": "List all dictionary codelists.", "description": "\nState before:\n - The library must exist.\n \nBusiness logic:\n - List all dictionary codelists (in their latest versions).\n \nState after:\n - No change\n\nPossible errors:\n - Invalid library name.", "operationId": "get_codelists_dictionaries_codelists__library__get", "parameters": [{"description": "The Library from which the dictionaries codelists should be retrieved", "required": true, "schema": {"title": "Library", "type": "string", "description": "The Library from which the dictionaries codelists should be retrieved"}, "name": "library", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_DictionaryCodelist_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/codelists/{library}/headers": {"get": {"tags": ["Dictionary codelists"], "summary": "Returns possibles values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_dictionaries_codelists__library__headers_get", "parameters": [{"description": "The Library from which the dictionaries codelists should be retrieved", "required": true, "schema": {"title": "Library", "type": "string", "description": "The Library from which the dictionaries codelists should be retrieved"}, "name": "library", "in": "path"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Dictionaries Codelists  Library  Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/codelists": {"post": {"tags": ["Dictionary codelists"], "summary": "Creates new dictionary codelist.", "description": "The following nodes are created\n  * DictionaryCodelistRoot\n  * DictionaryCodelistValue\n", "operationId": "create_dictionaries_codelists_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Dictionary Codelist Input", "allOf": [{"$ref": "#/components/schemas/DictionaryCodelistCreateInput"}], "description": "Properties to create DictionaryCodelistValue node."}}}}, "responses": {"201": {"description": "Created - The dictionary codelist was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryCodelist"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/codelists/{uid}": {"get": {"tags": ["Dictionary codelists"], "summary": "List details on the dictionary codelist with {uid}", "description": "\nState before:\n - The selected codelist must exist.\n \nBusiness logic:\n - List details of the selected codelist (in a given version, if specified)\n\nState after:\n - No change", "operationId": "get_codelist_dictionaries_codelists__uid__get", "parameters": [{"description": "The unique id of the DictionaryCodelist", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryCodelist"}, "name": "uid", "in": "path"}, {"description": "If specified then the latest/newest representation of the dictionary codelist for DictionaryCodelistValue in that version is returned.\nOnly exact matches are considered. The version is specified in the following format:<major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0',", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified then the latest/newest representation of the dictionary codelist for DictionaryCodelistValue in that version is returned.\nOnly exact matches are considered. The version is specified in the following format:<major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0',"}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryCodelist"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Dictionary codelists"], "summary": " Update name or template parameter flag for dictionary codelist", "description": "\nState before:\n - codelistuid must exist and the dictionary codelist must exist in status draft.\n \nBusiness logic:\n - If the dictionary codelist related to codelistuid exist in status draft then name attribute and Template Parameter node label are updated.\n - If Template Parameter have been set to 'Y' then it cannot be set back to 'N' (i.e. when the Template Parameter node label have been added it cannot be removed).\n \nState after:\n - name attribute and Template Parameter node label are updated for the dictionary codelist.\n - Audit trail entry must be made with update of name attribute or Template Parameter flag.\n \nPossible errors:\n - Invalid codelistuid.\n", "operationId": "edit_dictionaries_codelists__uid__patch", "parameters": [{"description": "The unique id of the DictionaryCodelist", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryCodelist"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Dictionary Codelist Input", "allOf": [{"$ref": "#/components/schemas/DictionaryCodelistEditInput"}], "description": "The new parameter values for the dictionary codelist including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryCodelist"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The dictionary codelist is not in draft status.\n- The dictionary codelist had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The codelist with the specified 'codelistuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/codelists/{uid}/versions": {"get": {"tags": ["Dictionary codelists"], "summary": "List version history for a dictionary codelist", "description": "\nState before:\n - codelistuid must exist.\n \nBusiness logic:\n - List version history for the representation of the dictionary codelist, including the use as template parameter.\n - The returned versions are ordered by startDate descending (newest entries first).\n \nState after:\n - No change\n \nPossible errors:\n - Invalid codelistuid.\n    ", "operationId": "get_versions_dictionaries_codelists__uid__versions_get", "parameters": [{"description": "The unique id of the DictionaryCodelist", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryCodelist"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Dictionaries Codelists  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryCodelistVersion"}}}}}, "404": {"description": "Not Found - The dictionary codelist with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/codelists/{uid}/new-version": {"post": {"tags": ["Dictionary codelists"], "summary": " Create a new version of the dictionary codelist", "description": "\nState before:\n - codelistuid must exist and the dictionary codelist must be in status Final.\n \nBusiness logic:\n - The latest 'Final' version will remain the same as before.\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to the version of the latest 'Final' or 'Retired' version increased by +0.1.\n - The 'changeDescription' property will be set automatically to 'New version'.\n \nState after:\n - Dictionary codelist changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating new Draft version.\n \nPossible errors:\n - Invalid codelistuid or status not Final.\n \n", "operationId": "create_new_version_dictionaries_codelists__uid__new_version_post", "parameters": [{"description": "The unique id of the DictionaryCodelist", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryCodelist"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "Created - The dictionary codelist was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryCodelist"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create codelists.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The dictionary codelist is not in final status.\n- The dictionary codelist with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/codelists/{uid}/approve": {"post": {"tags": ["Dictionary codelists"], "summary": "Approve draft version of the dictionary codelist", "description": "\nState before:\n - codelistuid must exist and the dictionary codelist must be in status Draft.\n \nBusiness logic:\n - The latest 'Draft' version will remain the same as before.\n - The status of the new approved version will be automatically set to 'Final'.\n - The 'version' property of the new version will be automatically set to the version of the latest 'Final' version increased by +1.0.\n - The 'changeDescription' property will be set automatically 'Approved version'.\n \nState after:\n - Dictionary codelist changed status to Final and assigned a new major version number.\n - Audit trail entry must be made with action of approving to new Final version.\n \nPossible errors:\n - Invalid codelistuid or status not Draft.\n    ", "operationId": "approve_dictionaries_codelists__uid__approve_post", "parameters": [{"description": "The unique id of the DictionaryCodelist", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryCodelist"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryCodelist"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The codelist is not in draft status.\n- The library does not allow to approve codelist.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The codelist with the specified 'codelistuid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/codelists/{uid}/add-term": {"post": {"tags": ["Dictionary codelists"], "summary": " Attaches a dictionary term to a dictionary codelist", "description": "\nState before:\n - codelistuid must exist.\n - termUid must exist.\n\nBusiness logic:\n - Create a HAS_TERM relationship between the selected codelist root and the selected term root, with the current date and current user.\n\nPossible errors:\n - Invalid codelistuid.\n-  Invalid termuid.\n-  Codelist with {uid} is not extensible.\n- Term is already part of the specified codelist.", "operationId": "add_term_dictionaries_codelists__uid__add_term_post", "parameters": [{"description": "The unique id of the DictionaryCodelist", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryCodelist"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Term Input", "allOf": [{"$ref": "#/components/schemas/DictionaryCodelistTermInput"}], "description": "UID of the DictionaryTermRoot node."}}}}, "responses": {"201": {"description": "The HAS_TERM relationship was successfully created.\nThe TemplateParameter labels and HAS_VALUE relationship were successfully added if dictionary codelist identified by 'uid' is a TemplateParameter.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryCodelist"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The dictionary codelist does not exist.\n- The dictionary term does not exist.\n- The dictionary codelist already has passed term.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/codelists/{uid}/remove-term": {"post": {"tags": ["Dictionary codelists"], "summary": "Removes a dictionary term from a dictionary codelist", "description": "\nState before:\n - codelistuid must exist.\n - termUid must exist.\n - the codelist contains the term that is removed.\n\n\nBusiness logic:\n - Create a HAD_TERM relationship between the selected codelist root and the selected term root, with the current date as the end date, and current user.\n - Remove the old HAS_TERM relationship between the codelist and the term.\n\nPossible errors:\n - Invalid codelistuid.\n - Invalid termuid.\n- Term is not part of the specified codelist. ", "operationId": "remove_term_dictionaries_codelists__uid__remove_term_post", "parameters": [{"description": "The unique id of the DictionaryCodelist", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryCodelist"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Term Input", "allOf": [{"$ref": "#/components/schemas/DictionaryCodelistTermInput"}], "description": "UID of the DictionaryTermRoot node."}}}}, "responses": {"201": {"description": "The HAS_TERM relationship was successfully deleted and HAD_TERM relationship was successfully created.\nThe HAS_VALUE relationship was successfully deleted if codelist identified by uid is a TemplateParameter", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryCodelist"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The codelist does not exist.\n- The term does not exist.\n- The codelist doesn't have passed term.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/terms": {"get": {"tags": ["Dictionary terms"], "summary": "List terms in the dictionary codelist.", "description": "\nBusiness logic:\n - List dictionary terms in the repository for the dictionary codelist (being a subset of terms)\n - The term uid property is the dictionary conceptId.\n \nState after:\n - No change\n \nPossible errors:\n - Invalid codelist_uid", "operationId": "get_terms_dictionaries_terms_get", "parameters": [{"description": "The unique id of the DictionaryCodelist", "required": true, "schema": {"title": "Codelist Uid", "type": "string", "description": "The unique id of the DictionaryCodelist"}, "name": "codelist_uid", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_DictionaryTerm_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Dictionary terms"], "summary": "Creates new dictionary term.", "description": "The following nodes are created\n  * DictionaryTermRoot\n  * DictionaryTermValue\n", "operationId": "create_dictionaries_terms_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Dictionary Term Input", "allOf": [{"$ref": "#/components/schemas/DictionaryTermCreateInput"}], "description": "Properties to create DictionaryTermValue node."}}}}, "responses": {"201": {"description": "Created - The dictionary term was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryTerm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/terms/headers": {"get": {"tags": ["Dictionary terms"], "summary": "Returns possibles values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_dictionaries_terms_headers_get", "parameters": [{"description": "The unique id of the DictionaryCodelist", "required": true, "schema": {"title": "Codelist Uid", "type": "string", "description": "The unique id of the DictionaryCodelist"}, "name": "codelist_uid", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Dictionaries Terms Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/terms/{uid}": {"get": {"tags": ["Dictionary terms"], "summary": "List details on the specific dictionary term", "description": "\nState before:\n -\n \nBusiness logic:\n - List details on a specific dictionary term.\n \nState after:\n - No change\n \nPossible errors:\n - Invalid codelist", "operationId": "get_codelists_dictionaries_terms__uid__get", "parameters": [{"description": "The unique id of the DictionaryTerm", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryTerm"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryTerm"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Dictionary terms"], "summary": "Delete draft version of a dictionary term", "description": "\nState before:\n - uid must exist\n - Dictionary term must be in status Draft in a version less then 1.0 (never been approved).\n \nBusiness logic:\n - The draft dictionary term is deleted\n \nState after:\n - Dictionary term is successfully deleted.\n \nPossible errors:\n - Invalid uid or status not Draft or exist in version 1.0 or above (previoulsy been approved) or not in an editable library.\n    ", "operationId": "delete_ct_term_dictionaries_terms__uid__delete", "parameters": [{"description": "The unique id of the DictionaryTerm", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryTerm"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The term was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in draft status.\n- The term was already in final state or is in use.\n- The library does not allow to delete term.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An term with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Dictionary terms"], "summary": "Update a dictionary term", "description": "\nState before:\n - uid must exist and dictionary term must exist in status draft.\n \nBusiness logic:\n - For SNOMED: Updates can only be imported from the SNOMED files, webservice or from legacy migration.\n - It should not be possible to update from the study builder app, this we can do with access permissions later.\n - The existing dictionary term is updated.\n - The individual values for name and uid must all be unique values within the dictionary codelist.\n - The status of the updated version will continue to be 'Draft'.\n - The 'version' property of the version will automatically be incremented with +0.1.\n - The 'changeDescription' property is required.\n \nState after:\n - Attribute are updated for the dictionary term.\n - Audit trail entry must be made with update of attributes.\n \nPossible errors:\n - Invalid uid.\n", "operationId": "edit_dictionaries_terms__uid__patch", "parameters": [{"description": "The unique id of the DictionaryTerm", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryTerm"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Dictionary Term Input", "allOf": [{"$ref": "#/components/schemas/DictionaryTermEditInput"}], "description": "The new parameter values for the dictionary term including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryTerm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The dictionary term is not in draft status.\n- The dictionary term had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/terms/{uid}/versions": {"get": {"tags": ["Dictionary terms"], "summary": "List version history for a specific dictionary term", "description": "\nState before:\n - uid must exist.\n \nBusiness logic:\n - List version history for a dictionary term.\n - The returned versions are ordered by startDate descending (newest entries first).\n \nState after:\n - No change\n \nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_dictionaries_terms__uid__versions_get", "parameters": [{"description": "The unique id of the DictionaryTerm", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryTerm"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Dictionaries Terms  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTermVersion"}}}}}, "404": {"description": "Not Found - The dictionary term with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/terms/{uid}/new-version": {"post": {"tags": ["Dictionary terms"], "summary": " Create a new version of a dictionary term", "description": "\nState before:\n - uid must exist and the dictionary term must be in status Final.\n \nBusiness logic:\n - The latest 'Final' version will remain the same as before.\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to the version of the latest 'Final' or 'Retired' version increased by +0.1.\n - The 'changeDescription' property will be set automatically to 'New version'.\n \nState after:\n - Dictionary term changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating new Draft version.\n \nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_new_version_dictionaries_terms__uid__new_version_post", "parameters": [{"description": "The unique id of the DictionaryTerm", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryTerm"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryTerm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create terms.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The dictionary term is not in final status.\n- The dictionary term with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/terms/{uid}/approve": {"post": {"tags": ["Dictionary terms"], "summary": "Approve draft version of the dictionary term", "description": "\nState before:\n - uid must exist and the dictionary term must be in status Draft.\n \nBusiness logic:\n - The latest 'Draft' version will remain the same as before.\n - The status of the new approved version will be automatically set to 'Final'.\n - The 'version' property of the new version will be automatically set to the version of the latest 'Final' version increased by +1.0.\n - The 'changeDescription' property will be set automatically 'Approved version'.\n \nState after:\n - dictionary term changed status to Final and assigned a new major version number.\n - Audit trail entry must be made with action of approving to new Final version.\n \nPossible errors:\n - Invalid uid or status not Draft.\n    ", "operationId": "approve_dictionaries_terms__uid__approve_post", "parameters": [{"description": "The unique id of the DictionaryTerm", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryTerm"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryTerm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in draft status.\n- The library does not allow to approve term.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/terms/{uid}/inactivate": {"post": {"tags": ["Dictionary terms"], "summary": " Inactivate final version of a dictionary term", "description": "\nState before:\n - uid must exist and the dictionary term must be in status Final.\n \nBusiness logic:\n - The latest 'Final' version will remain the same as before.\n - The status will be automatically set to 'Retired'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n \nState after:\n - dictionary term changed status to Retired.\n - Audit trail entry must be made with action of inactivating to retired version.\n \nPossible errors:\n - Invalid uid or status not Final.\n    ", "operationId": "inactivate_dictionaries_terms__uid__inactivate_post", "parameters": [{"description": "The unique id of the DictionaryTerm", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryTerm"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryTerm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/terms/{uid}/reactivate": {"post": {"tags": ["Dictionary terms"], "summary": "Reactivate retired version of a dictionary term", "description": "\nState before:\n - uid must exist and dictionary term must be in status Retired.\n \nBusiness logic:\n - The latest 'Retired' version will remain the same as before.\n - The status will be automatically set to 'Final'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n\nState after:\n - Dictionary term changed status to Final.\n - Audit trail entry must be made with action of reactivating to final version.\n \nPossible errors:\n - Invalid uid or status not Retired.\n    ", "operationId": "reactivate_dictionaries_terms__uid__reactivate_post", "parameters": [{"description": "The unique id of the DictionaryTerm", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryTerm"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryTerm"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The term is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/substances": {"get": {"tags": ["Dictionary terms"], "summary": "List terms in the substances dictionary codelist.", "description": "\nBusiness logic:\n - List dictionary terms in the repository for the dictionary codelist for substances\n \nState after:\n - No change\n \nPossible errors:\n - ", "operationId": "get_substances_dictionaries_substances_get", "parameters": [{"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_DictionaryTermSubstance_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Dictionary terms"], "summary": "Creates new substance dictionary term.", "description": "The following nodes are created\n  * DictionaryTermRoot/UNIITermRoot\n  * DictionaryTermValue/UNIITermValue\n", "operationId": "create_substance_dictionaries_substances_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Dictionary Term Input", "allOf": [{"$ref": "#/components/schemas/DictionaryTermSubstanceCreateInput"}], "description": "Properties to create DictionaryTermValue node."}}}}, "responses": {"201": {"description": "Created - The dictionary term was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryTermSubstance"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/dictionaries/substances/{uid}": {"get": {"tags": ["Dictionary terms"], "summary": "Details of the specific substance dictionary term", "description": "\nState before:\n -\n \nBusiness logic:\n - Returns details of the specific substance dictionary term.\n \nState after:\n - No change\n \nPossible errors:\n - Invalid uid", "operationId": "get_substance_by_id_dictionaries_substances__uid__get", "parameters": [{"description": "The unique id of the DictionaryTerm", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryTerm"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryTermSubstance"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Dictionary terms"], "summary": "Update a substance dictionary term", "description": "\nState before:\n - uid must exist and dictionary term must exist in status draft.\n \nBusiness logic:\n - The existing dictionary term is updated.\n - The individual values for name and uid must all be unique values within the dictionary codelist.\n - The status of the updated version will continue to be 'Draft'.\n - The 'version' property of the version will automatically be incremented with +0.1.\n - The 'changeDescription' property is required.\n \nState after:\n - Attribute are updated for the dictionary term.\n - Audit trail entry must be made with update of attributes.\n \nPossible errors:\n - Invalid uid.\n", "operationId": "edit_substance_dictionaries_substances__uid__patch", "parameters": [{"description": "The unique id of the DictionaryTerm", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the DictionaryTerm"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Dictionary Term Input", "allOf": [{"$ref": "#/components/schemas/DictionaryTermSubstanceEditInput"}], "description": "The new parameter values for the dictionary term including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/DictionaryTermSubstance"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The dictionary term is not in draft status.\n- The dictionary term had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The term with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/template-parameters": {"get": {"tags": ["Template Parameters"], "summary": "Returns all template parameter available with samples of the available values.", "description": "The returned template parameter are ordered by\n0. name ascending", "operationId": "get_all_template_parameters_template_parameters_get", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Template Parameters Template Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/template-parameters/{name}/values": {"get": {"tags": ["Template Parameters"], "summary": "Return all values available for the given template parameter.", "operationId": "get_template_parameter_values_template_parameters__name__values_get", "parameters": [{"required": true, "schema": {"title": "Name", "type": "string"}, "name": "name", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Template Parameter Values Template Parameters  Name  Values Get", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterValue"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-instances": {"get": {"tags": ["Activity Instances"], "summary": "List all activity instances (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n \nBusiness logic:\n - List all activity instances in their latest version, including properties derived from linked control terminology.\n \nState after:\n - No change\n \nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_activity_instances_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "A list of activity names to use as a specific filter", "required": false, "schema": {"title": "Activitynames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity names to use as a specific filter"}, "name": "activityNames[]", "in": "query"}, {"description": "A list of specimen names to use as a specific filter", "required": false, "schema": {"title": "Specimennames[]", "type": "array", "items": {"type": "string"}, "description": "A list of specimen names to use as a specific filter"}, "name": "specimenNames[]", "in": "query"}, {"description": "A list of sdtm variable names to use as a specific filter", "required": false, "schema": {"title": "Sdtmvariablenames[]", "type": "array", "items": {"type": "string"}, "description": "A list of sdtm variable names to use as a specific filter"}, "name": "sdtmVariableNames[]", "in": "query"}, {"description": "A list of sdtm domain names to use as a specific filter", "required": false, "schema": {"title": "Sdtmdomainnames[]", "type": "array", "items": {"type": "string"}, "description": "A list of sdtm domain names to use as a specific filter"}, "name": "sdtmDomainNames[]", "in": "query"}, {"description": "A list of sdtm category names to use as a specific filter", "required": false, "schema": {"title": "Sdtmcategorynames[]", "type": "array", "items": {"type": "string"}, "description": "A list of sdtm category names to use as a specific filter"}, "name": "sdtmCategoryNames[]", "in": "query"}, {"description": "A list of sdtm sub category names to use as a specific filter", "required": false, "schema": {"title": "Sdtmsubcategorynames[]", "type": "array", "items": {"type": "string"}, "description": "A list of sdtm sub category names to use as a specific filter"}, "name": "sdtmSubCategoryNames[]", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string", "default": {}}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_ActivityInstance_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-instances/headers": {"get": {"tags": ["Activity Instances"], "summary": "Returns possibles values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_activity_instances_headers_get", "parameters": [{"required": false, "schema": {"title": "Library", "type": "string"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Activity Instances Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-instances/{uid}/new-version": {"post": {"tags": ["Activity Instances"], "summary": " Create a new version of an activity instance", "description": "\nState before:\n - uid must exist and the activity instance must be in status Final.\n \nBusiness logic:\n- The activity instance is changed to a draft state.\n\nState after:\n - Activity instance changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n \nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_concepts_activities_activity_instances__uid__new_version_post", "parameters": [{"description": "The unique id of the ActivityInstance", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityInstance"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityInstance"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create activity instances.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The activity instance is not in final status.\n- The activity instance with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-instances/{uid}/approve": {"post": {"tags": ["Activity Instances"], "summary": "Approve draft version of an activity instance", "description": "\nState before:\n - uid must exist and activity instance must be in status Draft.\n \nBusiness logic:\n - The latest 'Draft' version will remain the same as before.\n - The status of the new approved version will be automatically set to 'Final'.\n - The 'version' property of the new version will be automatically set to the version of the latest 'Final' version increased by +1.0.\n - The 'changeDescription' property will be set automatically 'Approved version'.\n \nState after:\n - Activity instance changed status to Final and assigned a new major version number.\n - Audit trail entry must be made with action of approving to new Final version.\n \nPossible errors:\n - Invalid uid or status not Draft.\n    ", "operationId": "approve_concepts_activities_activity_instances__uid__approve_post", "parameters": [{"description": "The unique id of the ActivityInstance", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityInstance"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityInstance"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity instance is not in draft status.\n- The library does not allow to approve activity instance.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity instance with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-instances/{uid}/inactivate": {"post": {"tags": ["Activity Instances"], "summary": " Inactivate final version of an activity instance", "description": "\nState before:\n - uid must exist and activity instance must be in status Final.\n \nBusiness logic:\n - The latest 'Final' version will remain the same as before.\n - The status will be automatically set to 'Retired'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n \nState after:\n - Activity instance changed status to Retired.\n - Audit trail entry must be made with action of inactivating to retired version.\n \nPossible errors:\n - Invalid uid or status not Final.\n    ", "operationId": "inactivate_concepts_activities_activity_instances__uid__inactivate_post", "parameters": [{"description": "The unique id of the ActivityInstance", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityInstance"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityInstance"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity instance is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity instance with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-instances/{uid}/reactivate": {"post": {"tags": ["Activity Instances"], "summary": "Reactivate retired version of an activity instance", "description": "\nState before:\n - uid must exist and activity instance must be in status Retired.\n \nBusiness logic:\n - The latest 'Retired' version will remain the same as before.\n - The status will be automatically set to 'Final'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n\nState after:\n - Activity instance changed status to Final.\n - An audit trail entry must be made with action of reactivating to final version.\n \nPossible errors:\n - Invalid uid or status not Retired.\n    ", "operationId": "reactivate_concepts_activities_activity_instances__uid__reactivate_post", "parameters": [{"description": "The unique id of the ActivityInstance", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityInstance"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityInstance"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity instance is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity instance with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-instances/{uid}": {"delete": {"tags": ["Activity Instances"], "summary": "Delete draft version of an activity instance", "description": "\nState before:\n - uid must exist\n - The concept must be in status Draft in a version less then 1.0 (never been approved).\n - The concept must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n \nBusiness logic:\n - The draft concept is deleted.\n \nState after:\n - Activity instance is successfully deleted.\n \nPossible errors:\n - Invalid uid or status not Draft or exist in version 1.0 or above (previously been approved) or not in an editable library.\n    ", "operationId": "delete_activity_instance_concepts_activities_activity_instances__uid__delete", "parameters": [{"description": "The unique id of the ActivityInstance", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityInstance"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The activity instance was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity instance is not in draft status.\n- The activity instance was already in final state or is in use.\n- The library does not allow to delete activity instance.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An activity instance with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/reminders": {"get": {"tags": ["Reminders"], "summary": "List all reminders (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all reminders in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_reminders_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_Reminder_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Reminders"], "summary": "Creates new reminder.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the reminder with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - reminders is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_reminders_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ReminderCreateInput"}}}}, "responses": {"201": {"description": "Created - The reminder was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Reminder"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/reminders/headers": {"get": {"tags": ["Reminders"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_reminders_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Reminders Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/reminders/{uid}": {"get": {"tags": ["Reminders"], "summary": "Get details on a specific reminder (in a specific version)", "description": "\nState before:\n - a reminder with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_reminders__uid__get", "parameters": [{"description": "The unique id of the reminder", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the reminder"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Reminder"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Reminders"], "summary": "Update reminder", "description": "\nState before:\n - uid must exist and reminder must exist in status draft.\n - The reminder must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If reminder exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked reminder is updated, the relationships are updated to point to the reminder value node.\n\nState after:\n - attributes are updated for the reminder.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_reminders__uid__patch", "parameters": [{"description": "The unique id of the reminder", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the reminder"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ReminderEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Reminder"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The reminder is not in draft status.\n- The reminder had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The reminder with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/reminders/{uid}/versions": {"get": {"tags": ["Reminders"], "summary": "List version history for reminder", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for reminder.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_reminders__uid__versions_get", "parameters": [{"description": "The unique id of the reminder", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the reminder"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Reminders  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/Reminder"}}}}}, "404": {"description": "Not Found - The reminder with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/compound-dosings": {"get": {"tags": ["Compound Dosings"], "summary": "List all compound dosings (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all compound dosings in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_compound_dosings_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CompoundDosing_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Compound Dosings"], "summary": "Creates new compound dosing.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the compound dosing with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - compound dosings is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_compound_dosings_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundDosingCreateInput"}}}}, "responses": {"201": {"description": "Created - The compound dosing was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundDosing"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/compound-dosings/headers": {"get": {"tags": ["Compound Dosings"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_compound_dosings_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Compound Dosings Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/compound-dosings/{uid}": {"get": {"tags": ["Compound Dosings"], "summary": "Get details on a specific compound-dosings (in a specific version)", "description": "\nState before:\n - a compound dosing with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_compound_dosings__uid__get", "parameters": [{"description": "The unique id of the compound dosing", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound dosing"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundDosing"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Compound Dosings"], "summary": "Update compound dosing", "description": "\nState before:\n - uid must exist and compound dosing must exist in status draft.\n - The compound dosing must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If compound dosing exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked compound dosing is updated, the relationships are updated to point to the compound dosing value node.\n\nState after:\n - attributes are updated for the compound dosing.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_compound_dosings__uid__patch", "parameters": [{"description": "The unique id of the compound dosing", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound dosing"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundDosingEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundDosing"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound dosing is not in draft status.\n- The compound dosing had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The compound dosing with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/compound-dosings/{uid}/versions": {"get": {"tags": ["Compound Dosings"], "summary": "List version history for compound dosings", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for compound-dosings.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_compound_dosings__uid__versions_get", "parameters": [{"description": "The unique id of the compound dosing", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound dosing"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Compound Dosings  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/CompoundDosing"}}}}}, "404": {"description": "Not Found - The compound dosing with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compounds": {"get": {"tags": ["Compounds"], "summary": "List all compounds (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all compounds in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_compounds_concepts_compounds_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_Compound_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Compounds"], "summary": "Creates new compound.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the compound with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - compounds is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_compounds_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundCreateInput"}}}}, "responses": {"201": {"description": "Created - The compound was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Compound"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compounds-simple": {"get": {"tags": ["Compounds"], "summary": "List all compounds (for a given library) with only uid/name fields", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all compounds in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_compounds_simple_concepts_compounds_simple_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_SimpleCompound_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compounds/headers": {"get": {"tags": ["Compounds"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_compounds_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Compounds Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compounds/{uid}": {"get": {"tags": ["Compounds"], "summary": "Get details on a specific compounds (in a specific version)", "description": "\nState before:\n - a compound with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_compounds__uid__get", "parameters": [{"description": "The unique id of the compound", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Compound"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Compounds"], "summary": "Delete draft version of an compound", "description": "\nState before:\n - uid must exist\n - The concept must be in status Draft in a version less then 1.0 (never been approved).\n - The concept must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n \nBusiness logic:\n - The draft concept is deleted.\n \nState after:\n - Compound is successfully deleted.\n \nPossible errors:\n - Invalid uid or status not Draft or exist in version 1.0 or above (previously been approved) or not in an editable library.\n    ", "operationId": "delete_concepts_compounds__uid__delete", "parameters": [{"description": "The unique id of the compound", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The compound was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound is not in draft status.\n- The compound was already in final state or is in use.\n- The library does not allow to delete compound.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An compound with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Compounds"], "summary": "Update compound", "description": "\nState before:\n - uid must exist and compound must exist in status draft.\n - The compound must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If compound exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked compound is updated, the relationships are updated to point to the compound value node.\n\nState after:\n - attributes are updated for the compound.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_compounds__uid__patch", "parameters": [{"description": "The unique id of the compound", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Compound"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound is not in draft status.\n- The compound had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The compound with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compounds/{uid}/versions": {"get": {"tags": ["Compounds"], "summary": "List version history for compounds", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for compounds.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_compounds__uid__versions_get", "parameters": [{"description": "The unique id of the compound", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Compounds  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/Compound"}}}}}, "404": {"description": "Not Found - The compound with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compounds/{uid}/approve": {"post": {"tags": ["Compounds"], "summary": "Approve draft version of a compound", "description": "\nState before:\n - uid must exist and compound must be in status Draft.\n \nBusiness logic:\n - The latest 'Draft' version will remain the same as before.\n - The status of the new approved version will be automatically set to 'Final'.\n - The 'version' property of the new version will be automatically set to the version of the latest 'Final' version increased by +1.0.\n - The 'changeDescription' property will be set automatically to 'Approved version'.\n \nState after:\n - Compound changed status to Final and assigned a new major version number.\n - Audit trail entry must be made with action of approving to new Final version.\n \nPossible errors:\n - Invalid uid or status not Draft.\n    ", "operationId": "approve_concepts_compounds__uid__approve_post", "parameters": [{"description": "The unique id of the compound", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Compound"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound is not in draft status.\n- The library does not allow compound approval.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The compound with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compounds/{uid}/new-version": {"post": {"tags": ["Compounds"], "summary": " Create a new version of a compound", "description": "\nState before:\n - uid must exist and the compound must be in status Final.\n \nBusiness logic:\n- The compound is changed to a draft state.\n\nState after:\n - Compound changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n \nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_new_version_concepts_compounds__uid__new_version_post", "parameters": [{"description": "The unique id of the compound", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Compound"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create compounds.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The compound is not in final status.\n- The compound with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compounds/{uid}/inactivate": {"post": {"tags": ["Compounds"], "summary": " Inactivate final version of an compound", "description": "\nState before:\n - uid must exist and compound must be in status Final.\n \nBusiness logic:\n - The latest 'Final' version will remain the same as before.\n - The status will be automatically set to 'Retired'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n \nState after:\n - Compound changed status to Retired.\n - Audit trail entry must be made with action of inactivating to retired version.\n \nPossible errors:\n - Invalid uid or status not Final.\n    ", "operationId": "inactivate_concepts_compounds__uid__inactivate_post", "parameters": [{"description": "The unique id of the compound", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Compound"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The compound with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compounds/{uid}/reactivate": {"post": {"tags": ["Compounds"], "summary": "Reactivate retired version of an compound", "description": "\nState before:\n - uid must exist and compound must be in status Retired.\n \nBusiness logic:\n - The latest 'Retired' version will remain the same as before.\n - The status will be automatically set to 'Final'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n\nState after:\n - Compound changed status to Final.\n - An audit trail entry must be made with action of reactivating to final version.\n \nPossible errors:\n - Invalid uid or status not Retired.\n    ", "operationId": "reactivate_concepts_compounds__uid__reactivate_post", "parameters": [{"description": "The unique id of the compound", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Compound"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The compound with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compound-aliases": {"get": {"tags": ["Compound Aliases"], "summary": "List all compound aliases (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all compound aliases in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_all_concepts_compound_aliases_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CompoundAlias_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Compound Aliases"], "summary": "Creates new compound alias.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the compound alias with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - compound aliases is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_compound_aliases_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundAliasCreateInput"}}}}, "responses": {"201": {"description": "Created - The compound alias was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compound-aliases/headers": {"get": {"tags": ["Compound Aliases"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_compound_aliases_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Compound Aliases Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compound-aliases/{uid}": {"get": {"tags": ["Compound Aliases"], "summary": "Get details on a specific compound aliases (in a specific version)", "description": "\nState before:\n - a compound alias with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_concepts_compound_aliases__uid__get", "parameters": [{"description": "The unique id of the compound alias", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound alias"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundAlias"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Compound Aliases"], "summary": "Delete draft version of an compound alias", "description": "\nState before:\n - uid must exist\n - The concept must be in status Draft in a version less then 1.0 (never been approved).\n - The concept must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n \nBusiness logic:\n - The draft concept is deleted.\n \nState after:\n - Compound is successfully deleted.\n \nPossible errors:\n - Invalid uid or status not Draft or exist in version 1.0 or above (previously been approved) or not in an editable library.\n    ", "operationId": "delete_concepts_compound_aliases__uid__delete", "parameters": [{"description": "The unique id of the compound alias", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound alias"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The compound alias was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound alias is not in draft status.\n- The compound alias was already in final state or is in use.\n- The library does not allow to delete compound alias.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An compound alias with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Compound Aliases"], "summary": "Update compound alias", "description": "\nState before:\n - uid must exist and compound alias must exist in status draft.\n - The compound alias must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If compound alias exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked compound alias is updated, the relationships are updated to point to the compound alias value node.\n\nState after:\n - attributes are updated for the compound alias.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_compound_aliases__uid__patch", "parameters": [{"description": "The unique id of the compound alias", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound alias"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundAliasEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound alias is not in draft status.\n- The compound alias had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The compound alias with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compound-aliases/{uid}/versions": {"get": {"tags": ["Compound Aliases"], "summary": "List version history for compound aliases", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for compound aliases.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_compound_aliases__uid__versions_get", "parameters": [{"description": "The unique id of the compound alias", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound alias"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Compound Aliases  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/CompoundAlias"}}}}}, "404": {"description": "Not Found - The compound alias with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compound-aliases/{uid}/approve": {"post": {"tags": ["Compound Aliases"], "summary": "Approve draft version of a compound alias", "description": "\nState before:\n - uid must exist and compound alias must be in status Draft.\n \nBusiness logic:\n - The latest 'Draft' version will remain the same as before.\n - The status of the new approved version will be automatically set to 'Final'.\n - The 'version' property of the new version will be automatically set to the version of the latest 'Final' version increased by +1.0.\n - The 'changeDescription' property will be set automatically to 'Approved version'.\n \nState after:\n - Compound changed status to Final and assigned a new major version number.\n - Audit trail entry must be made with action of approving to new Final version.\n \nPossible errors:\n - Invalid uid or status not Draft.\n    ", "operationId": "approve_concepts_compound_aliases__uid__approve_post", "parameters": [{"description": "The unique id of the compound alias", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound alias"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound alias is not in draft status.\n- The library does not allow compound alias approval.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The compound alias with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compound-aliases/{uid}/new-version": {"post": {"tags": ["Compound Aliases"], "summary": " Create a new version of a compound alias", "description": "\nState before:\n - uid must exist and the compound alias must be in status Final.\n \nBusiness logic:\n- The compound alias is changed to a draft state.\n\nState after:\n - Compound changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n \nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_new_version_concepts_compound_aliases__uid__new_version_post", "parameters": [{"description": "The unique id of the compound alias", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound alias"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create compound aliases.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The compound alias is not in final status.\n- The compound alias with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compound-aliases/{uid}/inactivate": {"post": {"tags": ["Compound Aliases"], "summary": " Inactivate final version of an compound alias", "description": "\nState before:\n - uid must exist and compound alias must be in status Final.\n \nBusiness logic:\n - The latest 'Final' version will remain the same as before.\n - The status will be automatically set to 'Retired'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n \nState after:\n - Compound changed status to Retired.\n - Audit trail entry must be made with action of inactivating to retired version.\n \nPossible errors:\n - Invalid uid or status not Final.\n    ", "operationId": "inactivate_concepts_compound_aliases__uid__inactivate_post", "parameters": [{"description": "The unique id of the compound alias", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound alias"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound alias is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The compound alias with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/compound-aliases/{uid}/reactivate": {"post": {"tags": ["Compound Aliases"], "summary": "Reactivate retired version of an compound alias", "description": "\nState before:\n - uid must exist and compound alias must be in status Retired.\n \nBusiness logic:\n - The latest 'Retired' version will remain the same as before.\n - The status will be automatically set to 'Final'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n\nState after:\n - Compound changed status to Final.\n - An audit trail entry must be made with action of reactivating to final version.\n \nPossible errors:\n - Invalid uid or status not Retired.\n    ", "operationId": "reactivate_concepts_compound_aliases__uid__reactivate_post", "parameters": [{"description": "The unique id of the compound alias", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the compound alias"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CompoundAlias"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The compound alias is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The compound alias with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/special-purposes": {"get": {"tags": ["Special Purposes"], "summary": "List all special purposes (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all special purposes in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_special_purposes_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_SpecialPurpose_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Special Purposes"], "summary": "Creates new special purpose.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the special purpose with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - special-purposes is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_special_purposes_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/SpecialPurposeCreateInput"}}}}, "responses": {"201": {"description": "Created - The special purpose was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/SpecialPurpose"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/special-purposes/headers": {"get": {"tags": ["Special Purposes"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_special_purposes_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Special Purposes Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/special-purposes/{uid}": {"get": {"tags": ["Special Purposes"], "summary": "Get details on a specific special purpose (in a specific version)", "description": "\nState before:\n - a special purpose with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_special_purposes__uid__get", "parameters": [{"description": "The unique id of the special purpose", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the special purpose"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/SpecialPurpose"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Special Purposes"], "summary": "Update special purpose", "description": "\nState before:\n - uid must exist and special purpose must exist in status draft.\n - The special purpose must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If special purpose exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked special purpose is updated, the relationships are updated to point to the special purpose value node.\n\nState after:\n - attributes are updated for the special purpose.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_special_purposes__uid__patch", "parameters": [{"description": "The unique id of the special purpose", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the special purpose"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/SpecialPurposeEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/SpecialPurpose"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The special purpose is not in draft status.\n- The special purpose had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The special purpose with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/special-purposes/{uid}/versions": {"get": {"tags": ["Special Purposes"], "summary": "List version history for special purpose", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for special purpose.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_special_purposes__uid__versions_get", "parameters": [{"description": "The unique id of the special purpose", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the special purpose"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Special Purposes  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/SpecialPurpose"}}}}}, "404": {"description": "Not Found - The special purpose with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/categoric-findings": {"get": {"tags": ["Categoric Findings"], "summary": "List all categoric findings (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all categoric findings in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_categoric_findings_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CategoricFinding_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Categoric Findings"], "summary": "Creates new categoric finding.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the categoric finding with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - Categoric Findings is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_categoric_findings_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/CategoricFindingCreateInput"}}}}, "responses": {"201": {"description": "Created - The categoric finding was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CategoricFinding"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/categoric-findings/headers": {"get": {"tags": ["Categoric Findings"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_categoric_findings_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Categoric Findings Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/categoric-findings/{uid}": {"get": {"tags": ["Categoric Findings"], "summary": "Get details on a specific categoric-findings (in a specific version)", "description": "\nState before:\n - a categoric finding with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_categoric_findings__uid__get", "parameters": [{"description": "The unique id of the Categoric finding", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Categoric finding"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CategoricFinding"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Categoric Findings"], "summary": "Update categoric finding", "description": "\nState before:\n - uid must exist and categoric finding must exist in status draft.\n - The categoric finding must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If categoric finding exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked categoric finding is updated, the relationships are updated to point to the categoric finding value node.\n\nState after:\n - attributes are updated for the categoric finding.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_categoric_findings__uid__patch", "parameters": [{"description": "The unique id of the Categoric finding", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Categoric finding"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/CategoricFindingEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CategoricFinding"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The categoric finding is not in draft status.\n- The categoric finding had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The categoric finding with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/categoric-findings/{uid}/versions": {"get": {"tags": ["Categoric Findings"], "summary": "List version history for categoric findings", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for categoric-findings.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_categoric_findings__uid__versions_get", "parameters": [{"description": "The unique id of the Categoric finding", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Categoric finding"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Categoric Findings  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/CategoricFinding"}}}}}, "404": {"description": "Not Found - The categoric finding with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/numeric-findings": {"get": {"tags": ["Numeric Findings"], "summary": "List all numeric findings (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all numeric findings in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_numeric_findings_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_NumericFinding_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Numeric Findings"], "summary": "Creates new numeric finding.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the numeric finding with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - numeric-findings is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_numeric_findings_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericFindingCreateInput"}}}}, "responses": {"201": {"description": "Created - The numeric finding was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericFinding"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/numeric-findings/headers": {"get": {"tags": ["Numeric Findings"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_numeric_findings_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Numeric Findings Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/numeric-findings/{uid}": {"get": {"tags": ["Numeric Findings"], "summary": "Get details on a specific numeric finding (in a specific version)", "description": "\nState before:\n - a numeric finding with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_numeric_findings__uid__get", "parameters": [{"description": "The unique id of the numeric finding", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the numeric finding"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericFinding"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Numeric Findings"], "summary": "Update numeric finding", "description": "\nState before:\n - uid must exist and numeric finding must exist in status draft.\n - The numeric finding must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If numeric finding exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked numeric finding is updated, the relationships are updated to point to the numeric finding value node.\n\nState after:\n - attributes are updated for the numeric finding.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_numeric_findings__uid__patch", "parameters": [{"description": "The unique id of the numeric finding", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the numeric finding"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericFindingEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericFinding"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The numeric finding is not in draft status.\n- The numeric finding had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The numeric finding with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/numeric-findings/{uid}/versions": {"get": {"tags": ["Numeric Findings"], "summary": "List version history for numeric finding", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for numeric finding.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_numeric_findings__uid__versions_get", "parameters": [{"description": "The unique id of the numeric finding", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the numeric finding"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Numeric Findings  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/NumericFinding"}}}}}, "404": {"description": "Not Found - The numeric finding with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/textual-findings": {"get": {"tags": ["Textual Findings"], "summary": "List all textual findings (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all textual findings in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_textual_findings_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_TextualFinding_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Textual Findings"], "summary": "Creates new textual finding.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the textual finding with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - textual-findings is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_textual_findings_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/TextualFindingCreateInput"}}}}, "responses": {"201": {"description": "Created - The textual finding was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TextualFinding"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/textual-findings/headers": {"get": {"tags": ["Textual Findings"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_textual_findings_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Textual Findings Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/textual-findings/{uid}": {"get": {"tags": ["Textual Findings"], "summary": "Get details on a specific textual finding (in a specific version)", "description": "\nState before:\n - a textual finding with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_textual_findings__uid__get", "parameters": [{"description": "The unique id of the textual finding", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the textual finding"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TextualFinding"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Textual Findings"], "summary": "Update textual finding", "description": "\nState before:\n - uid must exist and textual finding must exist in status draft.\n - The textual finding must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If textual finding exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked textual finding is updated, the relationships are updated to point to the textual finding value node.\n\nState after:\n - attributes are updated for the textual finding.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_textual_findings__uid__patch", "parameters": [{"description": "The unique id of the textual finding", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the textual finding"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/TextualFindingEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TextualFinding"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The textual finding is not in draft status.\n- The textual finding had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The textual finding with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/textual-findings/{uid}/versions": {"get": {"tags": ["Textual Findings"], "summary": "List version history for textual finding", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for textual finding.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_textual_findings__uid__versions_get", "parameters": [{"description": "The unique id of the textual finding", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the textual finding"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Textual Findings  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/TextualFinding"}}}}}, "404": {"description": "Not Found - The textual finding with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/rating-scales": {"get": {"tags": ["Rating Scales"], "summary": "List all rating scales (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all rating scales in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_rating_scales_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_RatingScale_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Rating Scales"], "summary": "Creates new rating scale.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the rating scale with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - rating-scales is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_rating_scales_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/RatingScaleCreateInput"}}}}, "responses": {"201": {"description": "Created - The rating scale was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RatingScale"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/rating-scales/headers": {"get": {"tags": ["Rating Scales"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_rating_scales_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Rating Scales Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/rating-scales/{uid}": {"get": {"tags": ["Rating Scales"], "summary": "Get details on a specific rating scale (in a specific version)", "description": "\nState before:\n - a rating scale with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_rating_scales__uid__get", "parameters": [{"description": "The unique id of the rating scale", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the rating scale"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RatingScale"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Rating Scales"], "summary": "Update rating scale", "description": "\nState before:\n - uid must exist and rating scale must exist in status draft.\n - The rating scale must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If rating scale exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked rating scale is updated, the relationships are updated to point to the rating scale value node.\n\nState after:\n - attributes are updated for the rating scale.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_rating_scales__uid__patch", "parameters": [{"description": "The unique id of the rating scale", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the rating scale"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/RatingScaleEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RatingScale"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The rating scale is not in draft status.\n- The rating scale had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The rating scale with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/rating-scales/{uid}/versions": {"get": {"tags": ["Rating Scales"], "summary": "List version history for rating scale", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for rating scale.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_rating_scales__uid__versions_get", "parameters": [{"description": "The unique id of the rating scale", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the rating scale"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Rating Scales  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/RatingScale"}}}}}, "404": {"description": "Not Found - The rating scale with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/laboratory-activities": {"get": {"tags": ["Laboratory Activities"], "summary": "List all laboratory activities (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all laboratory activities in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_laboratory_activities_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_LaboratoryActivity_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Laboratory Activities"], "summary": "Creates new laboratory activity.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the laboratory activity with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - laboratory-activities is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_laboratory_activities_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/LaboratoryActivityCreateInput"}}}}, "responses": {"201": {"description": "Created - The laboratory activity was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LaboratoryActivity"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/laboratory-activities/headers": {"get": {"tags": ["Laboratory Activities"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_laboratory_activities_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Laboratory Activities Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/laboratory-activities/{uid}": {"get": {"tags": ["Laboratory Activities"], "summary": "Get details on a specific laboratory activity (in a specific version)", "description": "\nState before:\n - a laboratory activity with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_laboratory_activities__uid__get", "parameters": [{"description": "The unique id of the laboratory activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the laboratory activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LaboratoryActivity"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Laboratory Activities"], "summary": "Update laboratory activity", "description": "\nState before:\n - uid must exist and laboratory activity must exist in status draft.\n - The laboratory activity must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If laboratory activity exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked laboratory activity is updated, the relationships are updated to point to the laboratory activity value node.\n\nState after:\n - attributes are updated for the laboratory activity.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_laboratory_activities__uid__patch", "parameters": [{"description": "The unique id of the laboratory activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the laboratory activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/LaboratoryActivityEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LaboratoryActivity"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The laboratory activity is not in draft status.\n- The laboratory activity had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The laboratory activity with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/laboratory-activities/{uid}/versions": {"get": {"tags": ["Laboratory Activities"], "summary": "List version history for laboratory activity", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for laboratory activity.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_laboratory_activities__uid__versions_get", "parameters": [{"description": "The unique id of the laboratory activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the laboratory activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Laboratory Activities  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/LaboratoryActivity"}}}}}, "404": {"description": "Not Found - The laboratory activity with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/events": {"get": {"tags": ["Events"], "summary": "List all events (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all events in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_events_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_Event_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Events"], "summary": "Creates new event.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the event with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - events is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_events_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/EventCreateInput"}}}}, "responses": {"201": {"description": "Created - The event was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Event"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/events/headers": {"get": {"tags": ["Events"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_events_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Events Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/events/{uid}": {"get": {"tags": ["Events"], "summary": "Get details on a specific events (in a specific version)", "description": "\nState before:\n - a event with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_events__uid__get", "parameters": [{"description": "The unique id of the event", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the event"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Event"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Events"], "summary": "Update event", "description": "\nState before:\n - uid must exist and event must exist in status draft.\n - The event must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If event exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked event is updated, the relationships are updated to point to the event value node.\n\nState after:\n - attributes are updated for the event.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_events__uid__patch", "parameters": [{"description": "The unique id of the event", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the event"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/EventEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Event"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The event is not in draft status.\n- The event had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The event with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/events/{uid}/versions": {"get": {"tags": ["Events"], "summary": "List version history for events", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for events.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_events__uid__versions_get", "parameters": [{"description": "The unique id of the event", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the event"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Events  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/Event"}}}}}, "404": {"description": "Not Found - The event with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activities": {"get": {"tags": ["Activities"], "summary": "List all activities (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all activities in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activities_concepts_activities_activities_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The unique id of the activity sub group to use as a specific filter", "required": false, "schema": {"title": "Activitysubgroupuid", "type": "string", "description": "The unique id of the activity sub group to use as a specific filter"}, "name": "activitySubGroupUid", "in": "query"}, {"description": "A list of activity names to use as a specific filter", "required": false, "schema": {"title": "Activitynames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity names to use as a specific filter"}, "name": "activityNames[]", "in": "query"}, {"description": "A list of activity sub group names to use as a specific filter", "required": false, "schema": {"title": "Activitysubgroupnames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity sub group names to use as a specific filter"}, "name": "activitySubGroupNames[]", "in": "query"}, {"description": "A list of activity group names to use as a specific filter", "required": false, "schema": {"title": "Activitygroupnames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity group names to use as a specific filter"}, "name": "activityGroupNames[]", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_Activity_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Activities"], "summary": "Creates new activity.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the activity with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - Activity is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_activities_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityCreateInput"}}}}, "responses": {"201": {"description": "Created - The activity was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Activity"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activities/headers": {"get": {"tags": ["Activities"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_activities_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "A list of activity names to use as a specific filter", "required": false, "schema": {"title": "Activitynames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity names to use as a specific filter"}, "name": "activityNames[]", "in": "query"}, {"description": "A list of activity sub group names to use as a specific filter", "required": false, "schema": {"title": "Activitysubgroupnames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity sub group names to use as a specific filter"}, "name": "activitySubGroupNames[]", "in": "query"}, {"description": "A list of activity group names to use as a specific filter", "required": false, "schema": {"title": "Activitygroupnames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity group names to use as a specific filter"}, "name": "activityGroupNames[]", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Activities Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activities/{uid}": {"get": {"tags": ["Activities"], "summary": "Get details on a specific activity (in a specific version)", "description": "\nState before:\n - an activity with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_activities__uid__get", "parameters": [{"description": "The unique id of the Activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Activity"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Activities"], "summary": "Delete draft version of activity", "description": "\nState before:\n - uid must exist\n - The concept must be in status Draft in a version less then 1.0 (never been approved).\n - The concept must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - The draft concept is deleted.\n\nState after:\n - Activity is successfully deleted.\n\nPossible errors:\n - Invalid uid or status not Draft or exist in version 1.0 or above (previously been approved) or not in an editable library.\n    ", "operationId": "delete_activity_concepts_activities_activities__uid__delete", "parameters": [{"description": "The unique id of the Activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The activity was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity is not in draft status.\n- The activity was already in final state or is in use.\n- The library does not allow to delete activity.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An activity with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Activities"], "summary": "Update activity", "description": "\nState before:\n - uid must exist and activity must exist in status draft.\n - The activity must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If activities exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked activity is updated, the relationships are updated to point to the activity value node.\n\nState after:\n - attributes are updated for the activity.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_activities__uid__patch", "parameters": [{"description": "The unique id of the Activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Activity"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity is not in draft status.\n- The activity had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activities/{uid}/versions": {"get": {"tags": ["Activities"], "summary": "List version history for activities", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for activities.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_activities__uid__versions_get", "parameters": [{"description": "The unique id of the Activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Activities  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/Activity"}}}}}, "404": {"description": "Not Found - The activity with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activities/{uid}/new-version": {"post": {"tags": ["Activities"], "summary": " Create a new version of activity", "description": "\nState before:\n - uid must exist and the activity must be in status Final.\n\nBusiness logic:\n- The activity is changed to a draft state.\n\nState after:\n - Activity changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "new_version_concepts_activities_activities__uid__new_version_post", "parameters": [{"description": "The unique id of the Activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Activity"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create activities.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The activity is not in final status.\n- The activity with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activities/{uid}/approve": {"post": {"tags": ["Activities"], "summary": "Approve draft version of activity", "description": "\nState before:\n - uid must exist and activity must be in status Draft.\n\nBusiness logic:\n - The latest 'Draft' version will remain the same as before.\n - The status of the new approved version will be automatically set to 'Final'.\n - The 'version' property of the new version will be automatically set to the version of the latest 'Final' version increased by +1.0.\n - The 'changeDescription' property will be set automatically 'Approved version'.\n\nState after:\n - Activity changed status to Final and assigned a new major version number.\n - Audit trail entry must be made with action of approving to new Final version.\n\nPossible errors:\n - Invalid uid or status not Draft.\n    ", "operationId": "approve_concepts_activities_activities__uid__approve_post", "parameters": [{"description": "The unique id of the Activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Activity"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity is not in draft status.\n- The library does not allow to approve activity.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activities/{uid}/inactivate": {"post": {"tags": ["Activities"], "summary": " Inactivate final version of activity", "description": "\nState before:\n - uid must exist and activity must be in status Final.\n\nBusiness logic:\n - The latest 'Final' version will remain the same as before.\n - The status will be automatically set to 'Retired'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n\nState after:\n - Activity changed status to Retired.\n - Audit trail entry must be made with action of inactivating to retired version.\n\nPossible errors:\n - Invalid uid or status not Final.\n    ", "operationId": "inactivate_concepts_activities_activities__uid__inactivate_post", "parameters": [{"description": "The unique id of the Activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Activity"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activities/{uid}/reactivate": {"post": {"tags": ["Activities"], "summary": "Reactivate retired version of a activity", "description": "\nState before:\n - uid must exist and activity  must be in status Retired.\n\nBusiness logic:\n - The latest 'Retired' version will remain the same as before.\n - The status will be automatically set to 'Final'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n\nState after:\n - Activity changed status to Final.\n - An audit trail entry must be made with action of reactivating to final version.\n\nPossible errors:\n - Invalid uid or status not Retired.\n    ", "operationId": "reactivate_concepts_activities_activities__uid__reactivate_post", "parameters": [{"description": "The unique id of the Activity", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the Activity"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Activity"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-sub-groups": {"get": {"tags": ["Activity sub groups"], "summary": "List all activity sub groups (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all activities sub groups in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activity_sub_groups_concepts_activities_activity_sub_groups_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The unique id of the activity group", "required": false, "schema": {"title": "Activitygroupuid", "type": "string", "description": "The unique id of the activity group"}, "name": "activityGroupUid", "in": "query"}, {"description": "A list of activity group names to use as a specific filter", "required": false, "schema": {"title": "Activitygroupnames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity group names to use as a specific filter"}, "name": "activityGroupNames[]", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_ActivitySubGroup_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Activity sub groups"], "summary": "Creates new activity sub group.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the activity sub group with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - ActivitySubGroup is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_activity_sub_groups_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivitySubGroupCreateInput"}}}}, "responses": {"201": {"description": "Created - The activity sub group was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivitySubGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-sub-groups/headers": {"get": {"tags": ["Activity sub groups"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_activity_sub_groups_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "A list of activity group names to use as a specific filter", "required": false, "schema": {"title": "Activitygroupnames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity group names to use as a specific filter"}, "name": "activityGroupNames[]", "in": "query"}, {"description": "A list of activity names to use as a specific filter", "required": false, "schema": {"title": "Activitynames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity names to use as a specific filter"}, "name": "activityNames[]", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Activity Sub Groups Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-sub-groups/{uid}": {"get": {"tags": ["Activity sub groups"], "summary": "Get details on a specific activity sub group (in a specific version)", "description": "\nState before:\n - an activity sub group with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_activity_sub_groups__uid__get", "parameters": [{"description": "The unique id of the ActivitySubGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivitySubGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivitySubGroup"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Activity sub groups"], "summary": "Delete draft version of activity sub group", "description": "\nState before:\n - uid must exist\n - The concept must be in status Draft in a version less then 1.0 (never been approved).\n - The concept must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - The draft concept is deleted.\n\nState after:\n - Activity sub group is successfully deleted.\n\nPossible errors:\n - Invalid uid or status not Draft or exist in version 1.0 or above (previously been approved) or not in an editable library.\n    ", "operationId": "delete_activity_sub_group_concepts_activities_activity_sub_groups__uid__delete", "parameters": [{"description": "The unique id of the ActivitySubGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivitySubGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The activity sub group was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity sub group is not in draft status.\n- The activity sub group was already in final state or is in use.\n- The library does not allow to delete activity sub group.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An activity sub group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Activity sub groups"], "summary": "Update activity sub group", "description": "\nState before:\n - uid must exist and activity sub group must exist in status draft.\n - The activity sub group must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If activity sub group exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked activity sub group is updated, the relationships are updated to point to the activity sub group value node.\n\nState after:\n - attributes are updated for the activity sub group.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_activity_sub_groups__uid__patch", "parameters": [{"description": "The unique id of the ActivitySubGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivitySubGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivitySubGroupEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivitySubGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity sub group is not in draft status.\n- The activity sub group had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity sub group with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-sub-groups/{uid}/versions": {"get": {"tags": ["Activity sub groups"], "summary": "List version history for activity sub groups", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for activity sub groups.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_activity_sub_groups__uid__versions_get", "parameters": [{"description": "The unique id of the ActivitySubGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivitySubGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Activity Sub Groups  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/ActivitySubGroup"}}}}}, "404": {"description": "Not Found - The activity sub group with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-sub-groups/{uid}/new-version": {"post": {"tags": ["Activity sub groups"], "summary": " Create a new version of activity sub group", "description": "\nState before:\n - uid must exist and the activity sub group must be in status Final.\n\nBusiness logic:\n- The activity sub group is changed to a draft state.\n\nState after:\n - ActivitySubGroup changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "new_version_concepts_activities_activity_sub_groups__uid__new_version_post", "parameters": [{"description": "The unique id of the ActivitySubGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivitySubGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivitySubGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create activity sub groups.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The activity sub group is not in final status.\n- The activity sub group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-sub-groups/{uid}/approve": {"post": {"tags": ["Activity sub groups"], "summary": "Approve draft version of activity sub group", "description": "\nState before:\n - uid must exist and activity sub group must be in status Draft.\n\nBusiness logic:\n - The latest 'Draft' version will remain the same as before.\n - The status of the new approved version will be automatically set to 'Final'.\n - The 'version' property of the new version will be automatically set to the version of the latest 'Final' version increased by +1.0.\n - The 'changeDescription' property will be set automatically 'Approved version'.\n\nState after:\n - Activity sub group changed status to Final and assigned a new major version number.\n - Audit trail entry must be made with action of approving to new Final version.\n\nPossible errors:\n - Invalid uid or status not Draft.\n    ", "operationId": "approve_concepts_activities_activity_sub_groups__uid__approve_post", "parameters": [{"description": "The unique id of the ActivitySubGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivitySubGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivitySubGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity sub group is not in draft status.\n- The library does not allow to approve activity sub group.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity sub group with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-sub-groups/{uid}/inactivate": {"post": {"tags": ["Activity sub groups"], "summary": " Inactivate final version of activity sub group", "description": "\nState before:\n - uid must exist and activity sub group must be in status Final.\n\nBusiness logic:\n - The latest 'Final' version will remain the same as before.\n - The status will be automatically set to 'Retired'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n\nState after:\n - Activity sub group changed status to Retired.\n - Audit trail entry must be made with action of inactivating to retired version.\n\nPossible errors:\n - Invalid uid or status not Final.\n    ", "operationId": "inactivate_concepts_activities_activity_sub_groups__uid__inactivate_post", "parameters": [{"description": "The unique id of the ActivitySubGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivitySubGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivitySubGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity sub group is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity sub group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-sub-groups/{uid}/reactivate": {"post": {"tags": ["Activity sub groups"], "summary": "Reactivate retired version of a activity sub group", "description": "\nState before:\n - uid must exist and activity sub group must be in status Retired.\n\nBusiness logic:\n - The latest 'Retired' version will remain the same as before.\n - The status will be automatically set to 'Final'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n\nState after:\n - Activity sub group changed status to Final.\n - An audit trail entry must be made with action of reactivating to final version.\n\nPossible errors:\n - Invalid uid or status not Retired.\n    ", "operationId": "reactivate_concepts_activities_activity_sub_groups__uid__reactivate_post", "parameters": [{"description": "The unique id of the ActivitySubGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivitySubGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivitySubGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity sub group is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity sub group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-groups": {"get": {"tags": ["Activity groups"], "summary": "List all activity groups (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all activities groups in their latest version, including properties derived from linked control terminology.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_activity_groups_concepts_activities_activity_groups_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_ActivityGroup_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Activity groups"], "summary": "Creates new activity group.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n - The specified CT term uids must exist, and the term names are in a final state.\n\nBusiness logic:\n - New node is created for the activity group with the set properties.\n - relationships to specified control terminology are created (as in the model).\n - relationships to specified activity parent are created (as in the model)\n - The status of the new created version will be automatically set to 'Draft'.\n - The 'version' property of the new version will be automatically set to 0.1.\n - The 'changeDescription' property will be set automatically to 'Initial version'.\n\nState after:\n - ActivityGroup is created in status Draft and assigned an initial minor version number as 0.1.\n - Audit trail entry must be made with action of creating new Draft version.\n\nPossible errors:\n - Invalid library or control terminology uid's specified.\n", "operationId": "create_concepts_activities_activity_groups_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityGroupCreateInput"}}}}, "responses": {"201": {"description": "Created - The activity group was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-groups/headers": {"get": {"tags": ["Activity groups"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_activities_activity_groups_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "A list of activity sub group names to use as a specific filter", "required": false, "schema": {"title": "Activitysubgroupnames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity sub group names to use as a specific filter"}, "name": "activitySubGroupNames[]", "in": "query"}, {"description": "A list of activity names to use as a specific filter", "required": false, "schema": {"title": "Activitynames[]", "type": "array", "items": {"type": "string"}, "description": "A list of activity names to use as a specific filter"}, "name": "activityNames[]", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Activities Activity Groups Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-groups/{uid}": {"get": {"tags": ["Activity groups"], "summary": "Get details on a specific activity group (in a specific version)", "description": "\nState before:\n - an activity sub group with uid must exist.\n\nBusiness logic:\n - If parameter atSpecifiedDateTime is specified then the latest/newest representation of the concept at this point in time is returned. The point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\ufffd0 is assumed.\n - If parameter status is specified then the representation of the concept in that status is returned (if existent). This is useful if the concept has a status 'Draft' and a status 'Final'.\n - If parameter version is specified then the latest/newest representation of the concept in that version is returned. Only exact matches are considered. The version is specified in the following format: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ...\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid, atSpecifiedDateTime, status or version.\n ", "operationId": "get_activity_concepts_activities_activity_groups__uid__get", "parameters": [{"description": "The unique id of the ActivityGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityGroup"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Activity groups"], "summary": "Delete draft version of activity group", "description": "\nState before:\n - uid must exist\n - The concept must be in status Draft in a version less then 1.0 (never been approved).\n - The concept must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - The draft concept is deleted.\n\nState after:\n - Activity group is successfully deleted.\n\nPossible errors:\n - Invalid uid or status not Draft or exist in version 1.0 or above (previously been approved) or not in an editable library.\n    ", "operationId": "delete_activity_group_concepts_activities_activity_groups__uid__delete", "parameters": [{"description": "The unique id of the ActivityGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The activity group was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity group is not in draft status.\n- The activity group was already in final state or is in use.\n- The library does not allow to delete activity sub group.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An activity group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Activity groups"], "summary": "Update activity group", "description": "\nState before:\n - uid must exist and activity group must exist in status draft.\n - The activity group must belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - If activity group exist in status draft then attributes are updated.\n - If links to CT are selected or updated then relationships are made to CTTermRoots.\n- If the linked activity group is updated, the relationships are updated to point to the activity group value node.\n\nState after:\n - attributes are updated for the activity group.\n - Audit trail entry must be made with update of attributes.\n\nPossible errors:\n - Invalid uid.\n\n", "operationId": "edit_concepts_activities_activity_groups__uid__patch", "parameters": [{"description": "The unique id of the ActivityGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityGroupEditInput"}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity group is not in draft status.\n- The activity group had been in 'Final' status before.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity group with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-groups/{uid}/versions": {"get": {"tags": ["Activity groups"], "summary": "List version history for activity groups", "description": "\nState before:\n - uid must exist.\n\nBusiness logic:\n - List version history for activity groups.\n - The returned versions are ordered by startDate descending (newest entries first).\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid.\n    ", "operationId": "get_versions_concepts_activities_activity_groups__uid__versions_get", "parameters": [{"description": "The unique id of the ActivityGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Activities Activity Groups  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/ActivityGroup"}}}}}, "404": {"description": "Not Found - The activity group with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-groups/{uid}/new-version": {"post": {"tags": ["Activity groups"], "summary": " Create a new version of activity group", "description": "\nState before:\n - uid must exist and the activity group must be in status Final.\n\nBusiness logic:\n- The activity group is changed to a draft state.\n\nState after:\n - ActivityGroup changed status to Draft and assigned a new minor version number.\n - Audit trail entry must be made with action of creating a new draft version.\n\nPossible errors:\n - Invalid uid or status not Final.\n", "operationId": "create_new_version_concepts_activities_activity_groups__uid__new_version_post", "parameters": [{"description": "The unique id of the ActivityGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not allow to create activity sub groups.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Reasons include e.g.: \n- The activity group is not in final status.\n- The activity group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-groups/{uid}/approve": {"post": {"tags": ["Activity groups"], "summary": "Approve draft version of activity group", "description": "\nState before:\n - uid must exist and activity group must be in status Draft.\n\nBusiness logic:\n - The latest 'Draft' version will remain the same as before.\n - The status of the new approved version will be automatically set to 'Final'.\n - The 'version' property of the new version will be automatically set to the version of the latest 'Final' version increased by +1.0.\n - The 'changeDescription' property will be set automatically 'Approved version'.\n\nState after:\n - Activity group changed status to Final and assigned a new major version number.\n - Audit trail entry must be made with action of approving to new Final version.\n\nPossible errors:\n - Invalid uid or status not Draft.\n    ", "operationId": "approve_concepts_activities_activity_groups__uid__approve_post", "parameters": [{"description": "The unique id of the ActivityGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity group is not in draft status.\n- The library does not allow to approve activity group.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity group with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-groups/{uid}/inactivate": {"post": {"tags": ["Activity groups"], "summary": " Inactivate final version of activity group", "description": "\nState before:\n - uid must exist and activity group must be in status Final.\n\nBusiness logic:\n - The latest 'Final' version will remain the same as before.\n - The status will be automatically set to 'Retired'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n\nState after:\n - Activity group changed status to Retired.\n - Audit trail entry must be made with action of inactivating to retired version.\n\nPossible errors:\n - Invalid uid or status not Final.\n    ", "operationId": "inactivate_concepts_activities_activity_groups__uid__inactivate_post", "parameters": [{"description": "The unique id of the ActivityGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity group is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/activities/activity-groups/{uid}/reactivate": {"post": {"tags": ["Activity groups"], "summary": "Reactivate retired version of a activity group", "description": "\nState before:\n - uid must exist and activity group must be in status Retired.\n\nBusiness logic:\n - The latest 'Retired' version will remain the same as before.\n - The status will be automatically set to 'Final'.\n - The 'changeDescription' property will be set automatically.\n - The 'version' property will remain the same as before.\n\nState after:\n - Activity group changed status to Final.\n - An audit trail entry must be made with action of reactivating to final version.\n\nPossible errors:\n - Invalid uid or status not Retired.\n    ", "operationId": "reactivate_concepts_activities_activity_groups__uid__reactivate_post", "parameters": [{"description": "The unique id of the ActivityGroup", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the ActivityGroup"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ActivityGroup"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The activity group is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The activity group with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/numeric-values": {"get": {"tags": ["Numeric values"], "summary": "List all numeric values (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all numeric values.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_numeric_values_concepts_numeric_values_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_NumericValue_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Numeric values"], "summary": "Creates new numeric value or returns already existing numeric value.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - New node is created for the numeric value with the set properties.\n\nPossible errors:\n - Invalid library.\n", "operationId": "create_concepts_numeric_values_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValueInput"}}}}, "responses": {"201": {"description": "Created - The numeric value was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValue"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/numeric-values/headers": {"get": {"tags": ["Numeric values"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_numeric_values_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Numeric Values Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/numeric-values/{uid}": {"get": {"tags": ["Numeric values"], "summary": "Get details on a specific numeric value", "description": "\nState before:\n - a time point with uid must exist.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid\n ", "operationId": "get_numeric_value_concepts_numeric_values__uid__get", "parameters": [{"description": "The unique id of the numeric value", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the numeric value"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValue"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/numeric-values-with-unit": {"get": {"tags": ["Numeric values with unit"], "summary": "List all numeric values with unit (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all numeric values with units.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_numeric_values_concepts_numeric_values_with_unit_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_NumericValueWithUnit_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Numeric values with unit"], "summary": "Creates new numeric value or returns already existing numeric value.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - New node is created for the numeric value with the set properties.\n\nPossible errors:\n - Invalid library.\n", "operationId": "create_concepts_numeric_values_with_unit_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValueWithUnitInput"}}}}, "responses": {"201": {"description": "Created - The numeric value was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValueWithUnit"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/numeric-values-with-unit/headers": {"get": {"tags": ["Numeric values with unit"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_numeric_values_with_unit_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Numeric Values With Unit Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/numeric-values-with-unit/{uid}": {"get": {"tags": ["Numeric values with unit"], "summary": "Get details on a specific numeric value with unit", "description": "\nState before:\n - a numerical value with specified uid must exist.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid\n ", "operationId": "get_numeric_value_concepts_numeric_values_with_unit__uid__get", "parameters": [{"description": "The unique id of the numeric value", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the numeric value"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValueWithUnit"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/text-values": {"get": {"tags": ["Text values"], "summary": "List all text values (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all text values.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_text_values_concepts_text_values_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_TextValue_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Text values"], "summary": "Creates new text value or returns already existing text value.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - New node is created for the text value with the set properties.\n\nPossible errors:\n - Invalid library.\n", "operationId": "create_concepts_text_values_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/TextValueInput"}}}}, "responses": {"201": {"description": "Created - The text value was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TextValue"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/text-values/headers": {"get": {"tags": ["Text values"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_text_values_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Text Values Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/text-values/{uid}": {"get": {"tags": ["Text values"], "summary": "Get details on a specific text value", "description": "\nState before:\n - a time point with uid must exist.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid\n ", "operationId": "get_text_value_concepts_text_values__uid__get", "parameters": [{"description": "The unique id of the text value", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the text value"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TextValue"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/visit-names": {"get": {"tags": ["Visit names"], "summary": "List all visit names (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all visit names.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_visit_names_concepts_visit_names_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_VisitName_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Visit names"], "summary": "Creates new visit name or returns already existing visit name.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - New node is created for the visit name with the set properties.\n\nPossible errors:\n - Invalid library.\n", "operationId": "create_concepts_visit_names_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/VisitNameInput"}}}}, "responses": {"201": {"description": "Created - The visit name was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/VisitName"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/visit-names/headers": {"get": {"tags": ["Visit names"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_visit_names_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Visit Names Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/visit-names/{uid}": {"get": {"tags": ["Visit names"], "summary": "Get details on a specific visit name", "description": "\nState before:\n - a time point with uid must exist.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid\n ", "operationId": "get_visit_name_concepts_visit_names__uid__get", "parameters": [{"description": "The unique id of the visit name", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the visit name"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/VisitName"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-days": {"get": {"tags": ["Study days"], "summary": "List all study days (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all study days.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_study_days_concepts_study_days_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_NumericValue_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Study days"], "summary": "Creates new study day or returns already existing study day.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - New node is created for the study day with the set properties.\n\nPossible errors:\n - Invalid library.\n", "operationId": "create_concepts_study_days_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValueInput"}}}}, "responses": {"201": {"description": "Created - The study day was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValue"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-days/headers": {"get": {"tags": ["Study days"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_study_days_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Study Days Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-days/{uid}": {"get": {"tags": ["Study days"], "summary": "Get details on a specific study day", "description": "\nState before:\n - a study day with uid must exist.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid\n ", "operationId": "get_study_day_concepts_study_days__uid__get", "parameters": [{"description": "The unique id of the study day", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study day"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValue"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-weeks": {"get": {"tags": ["Study weeks"], "summary": "List all study weeks (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all study weeks.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_study_weeks_concepts_study_weeks_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_NumericValue_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Study weeks"], "summary": "Creates new study week or returns already existing study week.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - New node is created for the study week with the set properties.\n\nPossible errors:\n - Invalid library.\n", "operationId": "create_concepts_study_weeks_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValueInput"}}}}, "responses": {"201": {"description": "Created - The study week was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValue"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-weeks/headers": {"get": {"tags": ["Study weeks"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_study_weeks_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Study Weeks Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-weeks/{uid}": {"get": {"tags": ["Study weeks"], "summary": "Get details on a specific study week", "description": "\nState before:\n - a time point with uid must exist.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid\n ", "operationId": "get_study_week_concepts_study_weeks__uid__get", "parameters": [{"description": "The unique id of the study week", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study week"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValue"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-duration-days": {"get": {"tags": ["Study duration days"], "summary": "List all study duration days (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all study duration days.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_study_duration_days_concepts_study_duration_days_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_NumericValue_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Study duration days"], "summary": "Creates new study duration day or returns already existing study duration day.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - New node is created for the study duration day with the set properties.\n\nPossible errors:\n - Invalid library.\n", "operationId": "create_concepts_study_duration_days_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValueInput"}}}}, "responses": {"201": {"description": "Created - The study duration day was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValue"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-duration-days/headers": {"get": {"tags": ["Study duration days"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_study_duration_days_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Study Duration Days Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-duration-days/{uid}": {"get": {"tags": ["Study duration days"], "summary": "Get details on a specific study duration day", "description": "\nState before:\n - a study duration day with uid must exist.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid\n ", "operationId": "get_study_duration_day_concepts_study_duration_days__uid__get", "parameters": [{"description": "The unique id of the study duration day", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study duration day"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValue"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-duration-weeks": {"get": {"tags": ["Study duration weeks"], "summary": "List all study duration weeks (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all study duration weeks.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_study_duration_weeks_concepts_study_duration_weeks_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_NumericValue_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Study duration weeks"], "summary": "Creates new study duration week or returns already existing study duration week.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - New node is created for the study duration week with the set properties.\n\nPossible errors:\n - Invalid library.\n", "operationId": "create_concepts_study_duration_weeks_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValueInput"}}}}, "responses": {"201": {"description": "Created - The study duration week was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValue"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-duration-weeks/headers": {"get": {"tags": ["Study duration weeks"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_study_duration_weeks_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Study Duration Weeks Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/study-duration-weeks/{uid}": {"get": {"tags": ["Study duration weeks"], "summary": "Get details on a specific study duration week", "description": "\nState before:\n - a study duration week with uid must exist.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid\n ", "operationId": "get_study_duration_week_concepts_study_duration_weeks__uid__get", "parameters": [{"description": "The unique id of the study duration week", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study duration week"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/NumericValue"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/time-points": {"get": {"tags": ["Time points"], "summary": "List all time points (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all time points.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_time_points_concepts_time_points_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_TimePoint_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Time points"], "summary": "Creates new time point.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - New node is created for the time point with the set properties.\n\nPossible errors:\n - Invalid library.\n", "operationId": "create_concepts_time_points_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimePointInput"}}}}, "responses": {"201": {"description": "Created - The time point was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimePoint"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/time-points/headers": {"get": {"tags": ["Time points"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_time_points_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Time Points Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/time-points/{uid}": {"get": {"tags": ["Time points"], "summary": "Get details on a specific time point", "description": "\nState before:\n - a time point with uid must exist.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid\n ", "operationId": "get_time_point_concepts_time_points__uid__get", "parameters": [{"description": "The unique id of the time point", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the time point"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TimePoint"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/lag-times": {"get": {"tags": ["Lag times"], "summary": "List all lag times (for a given library)", "description": "\nState before:\n - The library must exist (if specified)\n\nBusiness logic:\n - List all lag times.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid library name specified.", "operationId": "get_lag_times_concepts_lag_times_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_LagTime_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Lag times"], "summary": "Creates new lag time or returns already existing lag time.", "description": "\nState before:\n - The specified library allows creation of concepts (the 'isEditable' property of the library needs to be true).\n\nBusiness logic:\n - New node is created for the lag time with the set properties.\n\nPossible errors:\n - Invalid library.\n", "operationId": "create_concepts_lag_times_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/LagTimeInput"}}}}, "responses": {"201": {"description": "Created - The lag time was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LagTime"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The library does not exist.\n- The library does not allow to add new items.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/lag-times/headers": {"get": {"tags": ["Lag times"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_lag_times_headers_get", "parameters": [{"description": "The library name", "required": false, "schema": {"title": "Library", "type": "string", "description": "The library name"}, "name": "library", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Lag Times Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/lag-times/{uid}": {"get": {"tags": ["Lag times"], "summary": "Get details on a specific lag time", "description": "\nState before:\n - a lag time with specified uid must exist.\n\nState after:\n - No change\n\nPossible errors:\n - Invalid uid\n ", "operationId": "get_lag_time_concepts_lag_times__uid__get", "parameters": [{"description": "The unique id of the lag time", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the lag time"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/LagTime"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/projects": {"get": {"tags": ["Projects"], "summary": "Returns all projects.", "operationId": "get_projects_projects_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Projects Projects Get", "type": "array", "items": {"$ref": "#/components/schemas/Project"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}}}, "post": {"tags": ["Projects"], "summary": "Creates a new project.", "operationId": "create_projects_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Project Create Input", "allOf": [{"$ref": "#/components/schemas/ProjectCreateInput"}], "description": "Related parameters of the project that shall be created."}}}}, "responses": {"201": {"description": "Created - The project was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Project"}}}}, "403": {"description": "Some application/business rules forbid to process the request. Expect more detailed information in response body.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/clinical-programmes": {"get": {"tags": ["Clinical Programmes"], "summary": "Returns all clinical programmes.", "operationId": "get_projects_clinical_programmes_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Projects Clinical Programmes Get", "type": "array", "items": {"$ref": "#/components/schemas/ClinicalProgramme"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}}}, "post": {"tags": ["Clinical Programmes"], "summary": "Creates a new clinical programme.", "operationId": "create_clinical_programmes_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Clinical Programme Create Input", "allOf": [{"$ref": "#/components/schemas/ClinicalProgrammeInput"}], "description": "Related parameters of the clinical programme that shall be created."}}}}, "responses": {"201": {"description": "Created - The clinical programme was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ClinicalProgramme"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/admin/caches": {"get": {"tags": ["Admin"], "summary": "Returns all cache stores", "operationId": "get_caches_admin_caches_get", "parameters": [{"required": false, "schema": {"title": "Showitems", "type": "boolean", "default": false}, "name": "showItems", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Caches Admin Caches Get", "type": "array", "items": {}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/admin/caches/clear": {"post": {"tags": ["Admin"], "summary": "Clears all cache stores", "operationId": "clear_caches_admin_caches_clear_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Clear Caches Admin Caches Clear Post", "type": "array", "items": {}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/brands": {"get": {"tags": ["Brands"], "summary": "Returns all brands.", "operationId": "get_brands_brands_get", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Brands Brands Get", "type": "array", "items": {"$ref": "#/components/schemas/Brand"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Brands"], "summary": "Creates a new brand.", "operationId": "create_brands_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Brand Create Input", "allOf": [{"$ref": "#/components/schemas/BrandCreateInput"}], "description": "Related parameters of the brand that shall be created."}}}}, "responses": {"201": {"description": "Created - The brand was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Brand"}}}}, "403": {"description": "Some application/business rules forbid to process the request. Expect more detailed information in response body.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/brands/{uid}": {"get": {"tags": ["Brands"], "summary": "Returns the brand identified by the specified 'uid'.", "operationId": "get_brand_brands__uid__get", "parameters": [{"description": "The unique id of brand", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of brand"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Brand"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Brands"], "summary": "Deletes the brand identified by 'uid'.", "operationId": "delete_brands__uid__delete", "parameters": [{"description": "The unique id of brand", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of brand"}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The item was successfully deleted."}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies": {"get": {"tags": ["Studies"], "summary": "Returns all studies in their latest/newest version.", "description": "Allowed parameters include : filter on fields, sort by field name with sort direction, pagination", "operationId": "get_all_studies_get", "parameters": [{"description": "Parameter specifies which parts of the whole Study Definition representation to retrieve. This endpoint won't return underlying metadata parts like highLevelStudyDesign or studyIntervention even if they will be prefixed with a `+` because it was set to return only the most important part of the information like identification metadata. In the form of comma separated name of the fields prefixed by (optional) `+`  if the client wishes to retrieve the field or `-` if the client wants to skip the field. If not specified identification metadata and version metadata are retrieved. If value starts with `+` or `-` above default is extended or reduced by the specified fields otherwise (if not started with `+` or `-`) provided fields specification replaces the default. The `uid` and `studyStatus` fields will be always returned as they are mandatory fields for the Study API model. Currently supported fields are `currentMetadata.identificationMetadata`, `currentMetadata.highLevelStudyDesign` , `currentMetadata.studyPopulation` and `currentMetadata.studyIntervention` , `currentMetadata.studyDescription`.", "required": false, "schema": {"title": "Fields", "type": "string", "description": "Parameter specifies which parts of the whole Study Definition representation to retrieve. This endpoint won't return underlying metadata parts like highLevelStudyDesign or studyIntervention even if they will be prefixed with a `+` because it was set to return only the most important part of the information like identification metadata. In the form of comma separated name of the fields prefixed by (optional) `+`  if the client wishes to retrieve the field or `-` if the client wants to skip the field. If not specified identification metadata and version metadata are retrieved. If value starts with `+` or `-` above default is extended or reduced by the specified fields otherwise (if not started with `+` or `-`) provided fields specification replaces the default. The `uid` and `studyStatus` fields will be always returned as they are mandatory fields for the Study API model. Currently supported fields are `currentMetadata.identificationMetadata`, `currentMetadata.highLevelStudyDesign` , `currentMetadata.studyPopulation` and `currentMetadata.studyIntervention` , `currentMetadata.studyDescription`."}, "name": "fields", "in": "query"}, {"description": "Optionaly, filter studies based on the existence of related study objectives or not", "required": false, "schema": {"title": "Hasstudyobjective", "type": "boolean", "description": "Optionaly, filter studies based on the existence of related study objectives or not"}, "name": "hasStudyObjective", "in": "query"}, {"description": "Optionaly, filter studies based on the existence of related study endpoints or not", "required": false, "schema": {"title": "Hasstudyendpoint", "type": "boolean", "description": "Optionaly, filter studies based on the existence of related study endpoints or not"}, "name": "hasStudyEndpoint", "in": "query"}, {"description": "Optionaly, filter studies based on the existence of related study criteria or not", "required": false, "schema": {"title": "Hasstudycriteria", "type": "boolean", "description": "Optionaly, filter studies based on the existence of related study criteria or not"}, "name": "hasStudyCriteria", "in": "query"}, {"description": "Optionaly, filter studies based on the existence of related study activities or not", "required": false, "schema": {"title": "Hasstudyactivity", "type": "boolean", "description": "Optionaly, filter studies based on the existence of related study activities or not"}, "name": "hasStudyActivity", "in": "query"}, {"description": "Optionaly, filter studies based on the existence of related study activity instruction or not", "required": false, "schema": {"title": "Hasstudyactivityinstruction", "type": "boolean", "description": "Optionaly, filter studies based on the existence of related study activity instruction or not"}, "name": "hasStudyActivityInstruction", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_Study_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Studies"], "summary": "Creates a new Study Definition.", "description": "\nIf the request succeeds new DRAFT Study Definition will be with initial identification data as provided in \nrequest body with new unique uid generated and returned in response body.\n        ", "operationId": "create_studies_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Study Create Input", "allOf": [{"$ref": "#/components/schemas/StudyCreateInput"}], "description": "Related parameters of the objective that shall be created."}}}}, "responses": {"201": {"description": "Created - The study was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Study"}}}}, "403": {"description": "Some application/business rules forbid to process the request. Expect more detailed information in response body.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/headers": {"get": {"tags": ["Studies"], "summary": "Returns possibles values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_studies_headers_get", "parameters": [{"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Studies Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{uid}": {"get": {"tags": ["Studies"], "summary": "Returns the current state of a specific study definition identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to match all at the same time (they are combined with the AND operation).", "operationId": "get_studies__uid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Parameter specifies which parts of the whole Study Definition representation to retrieve. In the form of comma separated name of the fields prefixed by (optional) `+`  if the client wishes to retrieve the field or `-` if the client wants to skip the field. If not specified identification metadata and version metadata are retrieved. If value starts with `+` or `-` above default is extended or reduced by the specified fields otherwise (if not started with `+` or `-`) provided fields specification replaces the default. The `uid` and `studyStatus` fields will be always returned as they are mandatory fields for the Study API model. Currently supported fields are `currentMetadata.identificationMetadata`, `currentMetadata.highLevelStudyDesign` ,`currentMetadata.studyPopulation` and `currentMetadata.studyIntervention` , `currentMetadata.studyDescription`.", "required": false, "schema": {"title": "Fields", "type": "string", "description": "Parameter specifies which parts of the whole Study Definition representation to retrieve. In the form of comma separated name of the fields prefixed by (optional) `+`  if the client wishes to retrieve the field or `-` if the client wants to skip the field. If not specified identification metadata and version metadata are retrieved. If value starts with `+` or `-` above default is extended or reduced by the specified fields otherwise (if not started with `+` or `-`) provided fields specification replaces the default. The `uid` and `studyStatus` fields will be always returned as they are mandatory fields for the Study API model. Currently supported fields are `currentMetadata.identificationMetadata`, `currentMetadata.highLevelStudyDesign` ,`currentMetadata.studyPopulation` and `currentMetadata.studyIntervention` , `currentMetadata.studyDescription`."}, "name": "fields", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Study"}}}}, "404": {"description": "Not Found - The study with the specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Studies"], "summary": "Request to change some aspects (parts) of a specific study definition identified by 'uid'.", "description": "The request to change (some aspect) of the state of current aggregate. There are some special cases and considerations:\n* patching studyStatus in currentMetadata.versionMetadata is considered as the request for  locking/unlocking/releasing the study definition and should not be combined with any other  changes\n* there are many business rules that apply in different patching scenario or state of the  study definition. If request is not compliant it will fail with 403 and response body  will (hopefully) explain what is wrong.\n* the method may be invoked with dry=true query param. if that's the case it wokrs the same  except that any change made to the resource are not persisted (however all validations are  performed.\n", "operationId": "patch_studies__uid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "If specified the operation does full validation and returns either 200 or 403 butnothing is persisted.", "required": false, "schema": {"title": "Dry", "type": "boolean", "description": "If specified the operation does full validation and returns either 200 or 403 butnothing is persisted.", "default": false}, "name": "dry", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Study Patch Request", "allOf": [{"$ref": "#/components/schemas/StudyPatchRequestJsonModel"}], "description": "The request with the structure similar to the GET /{uid} response. Carrying only thosefields requested to change."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Study"}}}}, "403": {"description": "Some application/business rules forbid to process the request. Expect more detailed information in response body.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The study with the specified 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{uid}/fields-audit-trail": {"get": {"tags": ["Studies"], "summary": "Returns the audit trail for the fields of a specific study definition identified by 'uid'.", "description": "Actions on the study are grouped by date of edit.Optionally select which subset of fields should be reflected in the audit trail.", "operationId": "get_fields_audit_trail_studies__uid__fields_audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally specify a list of sections to filter the audit trail by. Each section name must be preceded by a '+' or a '-', valid values are: 'IdentificationMetadata, RegistryIdentifiers, VersionMetadata, HighLevelStudyDesign, StudyPopulation, StudyIntervention, StudyDescription'. Example valid input: '-IdentificationMetadata,+StudyPopulation'. If no filters are specified, the entire audit trail is returned.", "required": false, "schema": {"title": "Sections", "type": "string", "description": "Optionally specify a list of sections to filter the audit trail by. Each section name must be preceded by a '+' or a '-', valid values are: 'IdentificationMetadata, RegistryIdentifiers, VersionMetadata, HighLevelStudyDesign, StudyPopulation, StudyIntervention, StudyDescription'. Example valid input: '-IdentificationMetadata,+StudyPopulation'. If no filters are specified, the entire audit trail is returned."}, "name": "sections", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Fields Audit Trail Studies  Uid  Fields Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyFieldAuditTrailEntry"}}}}}, "404": {"description": "Not Found - The study with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{uid}/protocol-title": {"get": {"tags": ["Studies"], "summary": "Retrieve all information related to Protocol Title", "description": "\nState before:\n - Study-uid must exist\n\nBusiness logic:\n - Retrieve Study title, Universal Trial Number, EudraCT number, IND number, Study phase fields\n - Retrieve all names of study compounds associated to {uid} and where type of treatment is equal to Investigational Product\n\nState after:\n - No change\n", "operationId": "get_protocol_title_studies__uid__protocol_title_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyProtocolTitle"}}}}, "404": {"description": "Not Found - The study with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{uid}/copy-component": {"patch": {"tags": ["Studies"], "summary": "Copy study form from another study", "description": "\nState before:\n - uid must exist\n - referenceStudyUid must exist\n\nBusiness logic:\n - if overwrite is set to false, then the projection of the copy will be returned\n - if overwrite is set to true, then the component referenced as a componentToCopy will be copied\n from the study referenced by referenceStudyUid to the study referenced by uid.\n\nState after:\n - The specific form is copied or projected into a study referenced by uid 'uid'.\n", "operationId": "copy_simple_form_from_another_study_studies__uid__copy_component_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The uid of the study to copy component from", "required": true, "schema": {"title": "Referencestudyuid", "type": "string", "description": "The uid of the study to copy component from"}, "name": "referenceStudyUid", "in": "query"}, {"description": "The uid of the study to copy component from", "required": true, "schema": {"allOf": [{"$ref": "#/components/schemas/StudyComponentEnum"}], "description": "The uid of the study to copy component from"}, "name": "componentToCopy", "in": "query"}, {"description": "Indicates whether to overwrite the component of the study referenced by the uidor return a projection", "required": false, "schema": {"title": "Overwrite", "type": "boolean", "description": "Indicates whether to overwrite the component of the study referenced by the uidor return a projection", "default": false}, "name": "overwrite", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Study"}}}}, "404": {"description": "Not Found - The study with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{study_uid}/design.svg": {"get": {"tags": ["Studies"], "summary": "Builds and returns a Study Design visualization image in SVG format", "operationId": "get_study_flowchart_html_studies__study_uid__design_svg_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Study Uid", "type": "string", "description": "The unique id of the study."}, "name": "study_uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"image/svg+xml": {"schema": {"type": "string"}}}}, "500": {"description": "Internal Server Error", "content": {"image/svg+xml": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{uid}/flowchart": {"get": {"tags": ["Studies"], "summary": "Returns Study Protocol Flowchart table", "operationId": "get_study_flowchart_studies__uid__flowchart_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The preferred time unit, either days or weeks.", "required": false, "schema": {"title": "Time Unit", "pattern": "^(weeks|days)$", "type": "string", "description": "The preferred time unit, either days or weeks.", "default": "days"}, "name": "time_unit", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/TableWithHeaders"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{uid}/flowchart.html": {"get": {"tags": ["Studies"], "summary": "Builds and returns an HTML document with Study Protocol Flowchart table", "operationId": "get_study_flowchart_html_studies__uid__flowchart_html_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The preferred time unit, either days or weeks.", "required": false, "schema": {"title": "Time Unit", "pattern": "^(weeks|days)$", "type": "string", "description": "The preferred time unit, either days or weeks.", "default": "days"}, "name": "time_unit", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"text/html": {"schema": {"type": "string"}}}}, "500": {"description": "Internal Server Error", "content": {"text/html": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{uid}/flowchart.docx": {"get": {"tags": ["Studies"], "summary": "Builds and returns a DOCX document with Study Protocol Flowchart table", "operationId": "get_study_flowchart_docx_studies__uid__flowchart_docx_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The preferred time unit, either days or weeks.", "required": false, "schema": {"title": "Time Unit", "pattern": "^(weeks|days)$", "type": "string", "description": "The preferred time unit, either days or weeks.", "default": "days"}, "name": "time_unit", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{uid}/interventions": {"get": {"tags": ["Studies"], "summary": "Returns Study Protocol Interventions table", "operationId": "get_study_interventions_studies__uid__interventions_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Table"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{uid}/interventions.html": {"get": {"tags": ["Studies"], "summary": "Builds and returns an HTML document of Study Protocol Interventions table", "operationId": "get_study_interventions_html_studies__uid__interventions_html_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"text/html": {"schema": {"type": "string"}}}}, "500": {"description": "Internal Server Error", "content": {"text/html": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/studies/{uid}/interventions.docx": {"get": {"tags": ["Studies"], "summary": "Builds and returns a DOCX document of Study Protocol Interventions table", "operationId": "get_study_interventions_docx_studies__uid__interventions_docx_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-objectives": {"get": {"tags": ["Study Selections"], "summary": "Returns all study objectives currently selected", "operationId": "get_all_selected_objectives_for_all_studies_study_study_objectives_get", "parameters": [{"description": "Indicates whether brackets around Template Parameters in the Objectiveshould be returned", "required": false, "schema": {"title": "Nobrackets", "type": "boolean", "description": "Indicates whether brackets around Template Parameters in the Objectiveshould be returned", "default": false}, "name": "noBrackets", "in": "query"}, {"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionObjective_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-objectives/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_objective_values_for_header_study_study_objectives_headers_get", "parameters": [{"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Objective Values For Header Study Study Objectives Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives": {"get": {"tags": ["Study Selections"], "summary": "Returns all study objectives currently selected for study with provided uid", "operationId": "get_all_selected_objectives_study__uid__study_objectives_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Indicates whether brackets around Template Parameters in the Objectiveshould be returned", "required": false, "schema": {"title": "Nobrackets", "type": "boolean", "description": "Indicates whether brackets around Template Parameters in the Objectiveshould be returned", "default": false}, "name": "noBrackets", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GenericFilteringReturn_StudySelectionObjective_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_study__uid__study_objectives_headers_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Study  Uid  Study Objectives Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List full audit trail related to definition of all study objectives.", "description": "\nThe following values should be return for all study objectives.\n- dateTime\n- userInitials\n- action\n- objectiveTemplate\n- objective\n- objectiveLevel\n- order\n    ", "operationId": "get_all_objectives_audit_trail_study__uid__study_objectives_audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Objectives Audit Trail Study  Uid  Study Objectives Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionObjectiveCore"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives/{studyobjectiveuid}": {"get": {"tags": ["Study Selections"], "summary": "Returns specific study objective", "operationId": "get_selected_objective_study__uid__study_objectives__studyobjectiveuid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyobjectiveuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyobjectiveuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionObjective"}}}}, "404": {"description": "Not Found - there exist no selection of the objective for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Deletes a study objective", "operationId": "delete_selected_objective_study__uid__study_objectives__studyobjectiveuid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyobjectiveuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyobjectiveuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the objective and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "update the objective level of a study objective", "operationId": "patch_update_objective_selection_study__uid__study_objectives__studyobjectiveuid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyobjectiveuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyobjectiveuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionObjectiveInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionObjective"}}}}, "404": {"description": "Not Found - There exist no selection between the study and objective.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives/{studyobjectiveuid}/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study objective.", "description": "\nThe following values should be return for selected study objective:\n- dateTime\n- userInitials\n- action\n- objectiveTemplate\n- objective\n- objectiveLevel\n- order\n    ", "operationId": "get_selected_objective_audit_trail_study__uid__study_objectives__studyobjectiveuid__audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyobjectiveuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyobjectiveuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Selected Objective Audit Trail Study  Uid  Study Objectives  Studyobjectiveuid  Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionObjectiveCore"}}}}}, "404": {"description": "Not Found - there exist no selection of the objective for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives/select": {"post": {"tags": ["Study Selections"], "summary": "Creating a study objective selection based on the input data", "operationId": "post_new_objective_selection_study__uid__study_objectives_select_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionObjectiveInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionObjective"}}}}, "403": {"description": "Forbidden - There already exists a selection of the objective", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or objective is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives/create": {"post": {"tags": ["Study Selections"], "summary": "Creating a study objective selection based on the input data including creating new objective", "operationId": "post_new_objective_selection_create_study__uid__study_objectives_create_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionObjectiveCreateInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionObjective"}}}}, "403": {"description": "Forbidden - There already exists a selection of the objective", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or objective is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives/create/preview": {"post": {"tags": ["Study Selections"], "summary": "Preview creating a study objective selection based on the input data", "operationId": "preview_new_objective_selection_create_study__uid__study_objectives_create_preview_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionObjectiveCreateInput"}], "description": "Related parameters of the selection that shall be previewed."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionObjective"}}}}, "403": {"description": "Forbidden - There already exists a selection of the objective", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or objective is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives/{studyobjectiveuid}/order": {"patch": {"tags": ["Study Selections"], "summary": "Change a order of a study objective", "operationId": "patch_new_objective_selection_order_study__uid__study_objectives__studyobjectiveuid__order_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyobjectiveuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyobjectiveuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "New Order Input", "allOf": [{"$ref": "#/components/schemas/StudySelectionObjectiveNewOrder"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionObjective"}}}}, "404": {"description": "Not Found - There exist no selection between the study and objective to reorder.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives/{studyobjectiveuid}/sync-latest-version": {"post": {"tags": ["Study Selections"], "summary": "update to latest objective version study selection", "operationId": "sync_latest_version_study__uid__study_objectives__studyobjectiveuid__sync_latest_version_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyobjectiveuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyobjectiveuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionObjective"}}}}, "404": {"description": "Not Found - There exist no selection between the study and objective.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-endpoints": {"get": {"tags": ["Study Selections"], "summary": "Returns all study endpoints currently selected", "operationId": "get_all_selected_endpoints_for_all_studies_study_study_endpoints_get", "parameters": [{"description": "Indicates whether brackets around Template Parameters in the Endpointshould be returned", "required": false, "schema": {"title": "Nobrackets", "type": "boolean", "description": "Indicates whether brackets around Template Parameters in the Endpointshould be returned", "default": false}, "name": "noBrackets", "in": "query"}, {"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionEndpoint_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-endpoints/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_endpoint_values_for_header_study_study_endpoints_headers_get", "parameters": [{"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Endpoint Values For Header Study Study Endpoints Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints": {"get": {"tags": ["Study Selections"], "summary": "List all study endpoints currently selected for study with provided uid", "description": "\nState before:\n- Study must exist.\n\nBusiness logic:\n - By default (no study status is provided) list all study endpoints for the study uid in status draft. If the study not exist in status draft then return the study endpoints for the study in status released. If the study uid only exist as deleted then this is returned.\n- If a specific study status parameter is provided then return study endpoints for this study status.\n- If the locked study status parameter is requested then a study version should also be provided, and then the study endpoints for the specific locked study version is returned.\n- Indicate by an boolean variable if the study endpoint can be updated (if the selected study is in status draft).\n- Indicate by an boolean variable if all expected selections have been made for each study endpoint, or some are missing.\n   - e.g. endpoint level, minimum one timeframe and one unit is expected.\n - Indicate by an boolean variable if the selected endpoint is available in a newer version.\n - Indicate by an boolean variable if a study endpoint can be re-ordered.\n\nState after:\n- no change.\n", "operationId": "get_all_selected_endpoints_study__uid__study_endpoints_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Indicates whether brackets around Template Parameters in the Objectiveand Endpoint should be returned", "required": false, "schema": {"title": "Nobrackets", "type": "boolean", "description": "Indicates whether brackets around Template Parameters in the Objectiveand Endpoint should be returned", "default": false}, "name": "noBrackets", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GenericFilteringReturn_StudySelectionEndpoint_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_study_endpoint_values_for_header_study__uid__study_endpoints_headers_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Study Endpoint Values For Header Study  Uid  Study Endpoints Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List full audit trail related to definition of all study endpoints.", "description": "\nParameters:\n - uid as study-uid (required)\n - [NOT YET IMPLEMENTED] study status (optional)\n - [NOT YET IMPLEMENTED] study version (required when study status is locked)\n\nState before:\n - Study must exist.\n\nBusiness logic:\n - List all entries in the audit trail related to study endpoints for specified study-uid.\n - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.\n\nReturned data:\n - List of actions and changes related to study endpoints.\n    ", "operationId": "get_all_endpoints_audit_trail_study__uid__study_endpoints_audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Endpoints Audit Trail Study  Uid  Study Endpoints Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/{studyendpointuid}": {"get": {"tags": ["Study Selections"], "summary": "Returns specific study endpoint", "description": "\nState before:\n - Study and study endpoint must exist\n\nBusiness logic:\n - By default (no study status is provided) list all details for specified study endpoint for the study uid in status draft. If the study not exist in status draft then return the study endpoints for the study in status released. If the study uid only exist as deleted then this is returned.\n - If a specific study status parameter is provided then return study endpoints for this study status.\n - If the locked study status parameter is requested then a study version should also be provided, and then the specified study endpoint for the specific locked study version is returned.\n - Indicate by an boolean variable if the study endpoint can be updated (if the selected study is in status draft).\n - Indicate by an boolean variable if all expected selections have been made for each study endpoint, or some are missing.\n - e.g. endpoint level, minimum one timeframe and one unit is expected.\n - Indicate by an boolean variable if the selected endpoint is available in a newer version.\n - Indicate by an boolean variable if a study endpoint can be re-ordered.\n\nState after:\n - no change\n", "operationId": "get_selected_endpoint_study__uid__study_endpoints__studyendpointuid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyendpointuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyendpointuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}, "404": {"description": "Not Found - When there exist no study endpoint with the study endpoint uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Deletes a objective selection", "description": "\nState before:\n - Study must exist and study status must be in draft.\n - study-endpoint-uid must exist.\n\nBusiness logic:\n - Remove specified study-endpoint from the study.\n - Reference to the study-endpoint should still exist in the the audit trail.\n - If a subsequent study endpoint exist in the list of study endpoints then the order number for following study endpoint must be decreased with 1.\n\nState after:\n- Study endpoint is deleted from the study, but still exist as a node in the database with a reference from the audit trail.\n- Added new entry in the audit trail for the deletion of the study-endpoint.\n", "operationId": "delete_selected_endpoint_study__uid__study_endpoints__studyendpointuid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyendpointuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyendpointuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - When there exist no study endpoint with the study endpoint uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "update the study endpoint", "description": "\nState before:\n - Study must exist and study status must be in draft.\n - Selected endpoint-uid, endpoint-template-uid, endpoint-level, timeframe-uid and unit-definition-uid must exist.\n\nBusiness logic:\n - Same logic applies as for selecting or creating an study endpoint (see two POST statements for /study-endpoints)\n\nState after:\n- Endpoint is added as study endpoint to the study.\n - This PATCH method can cover cover two parts:\n    - Change the endpoint level for the currently selected study endpoint\n    - Replace the currently selected study endpoint based on the same functionality as /study-endpoints/create\n - Added new entry in the audit trail for the update of the study-endpoint.\n", "operationId": "patch_update_endpoint_selection_study__uid__study_endpoints__studyendpointuid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyendpointuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyendpointuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionEndpointInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}, "404": {"description": "Not Found - When there exist no study endpoint with the study endpoint uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/{studyendpointuid}/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study coendpointsmpound.", "description": "\nParameters:\n - uid as study-uid (required)\n - study-compound-uid (required)\n - [NOT YET IMPLEMENTED] study status (optional)\n - [NOT YET IMPLEMENTED] study version (required when study status is locked)\n\nState before:\n - Study and study compounds must exist.\n\nBusiness logic:\n - List a specific entry in the audit trail related to the specified study endpoints for the specified study-uid.\n - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.\n\nReturned data:\n - List of actions and changes related to the specified study endpoints.\n    ", "operationId": "get_selected_endpoint_audit_trail_study__uid__study_endpoints__studyendpointuid__audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyendpointuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyendpointuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Selected Endpoint Audit Trail Study  Uid  Study Endpoints  Studyendpointuid  Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}}, "404": {"description": "Not Found - there exist no selection of the objective for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/select": {"post": {"tags": ["Study Selections"], "summary": "Creating a study endpoint selection based on the input data", "description": "\nState before:\n - Study must exist and study status must be in draft.\n - Selected endpoint-uid, endpoint-level, timeframe-uid and unit-definition-uid must exist.\n\nBusiness logic:\n - Add a study-endpoint to a study based on selection of an existing endpoint.\n - Reference to endpoint-uid must be included, this will implicitly include reference to the endpoint template.\n - If the selected endpoint is in draft then approve it and select the new approved version.\n - If the selected endpoint is retired then an error message must be provided.\n - Selection of endpoint level is optional.\n - Selection of Unit is optional.\n - Order must be assigned as the next incremental order number or as 1 if this is the initial study endpoint.\n\nState after:\n - Endpoint is added as study endpoint to the study.\n - Added new entry in the audit trail for the creation of the study-endpoint.\n", "operationId": "post_new_endpoint_selection_study__uid__study_endpoints_select_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionEndpointInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}, "404": {"description": "Not Found - When there exist no study endpoint with the study endpoint uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/create": {"post": {"tags": ["Study Selections"], "summary": "Creating a study endpoint selection based on the input data including creating new endpoint", "operationId": "post_new_endpoint_selection_create_study__uid__study_endpoints_create_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionEndpointCreateInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}, "403": {"description": "Forbidden - There already exists a selection of the endpoint", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or endpoint is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/create/preview": {"post": {"tags": ["Study Selections"], "summary": "Preview creating a study endpoint selection based on the input data", "operationId": "post_new_endpoint_selection_preview_study__uid__study_endpoints_create_preview_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionEndpointCreateInput"}], "description": "Related parameters of the selection that shall be previewed."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}, "403": {"description": "Forbidden - There already exists a selection of the endpoint", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or endpoint is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/{studyendpointuid}/order": {"patch": {"tags": ["Study Selections"], "summary": "Change a order of a selection", "description": "\nState before:\n - Study must exist and study status must be in draft.\n - studyEndpointUid must exist.\n\nBusiness logic:\n - moves the study selection to the order which is send in the new_order property\n\nState after:\n - Order number for specified study-endpoint is updated to new order number.\n - Note this will change order on either the preceding or following study-endpoints as well.\n - Added new entry in the audit trail for the re-ordering of the study-endpoints.\n", "operationId": "patch_new_endpoint_selection_order_study__uid__study_endpoints__studyendpointuid__order_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyendpointuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyendpointuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "New Order Input", "allOf": [{"$ref": "#/components/schemas/StudySelectionEndpointNewOrder"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}, "403": {"description": "Forbidden - Order is larger than the number of selections", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - When there exist no study endpoint with the study endpoint uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives.docx": {"get": {"tags": ["Study Selections"], "summary": "Returns Study Objectives and Endpoints table in standard layout DOCX document", "operationId": "get_all_selected_objectives_and_endpoints_standard_docx_study__uid__study_objectives_docx_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-compounds": {"get": {"tags": ["Study Selections"], "summary": "Returns all study compounds currently selected", "operationId": "get_all_selected_compounds_for_all_studies_study_study_compounds_get", "parameters": [{"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionCompound_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-compounds/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_compound_values_for_header_study_study_compounds_headers_get", "parameters": [{"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Compound Values For Header Study Study Compounds Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compounds": {"get": {"tags": ["Study Selections"], "summary": "List all study compounds currently selected for study with provided uid", "description": "\nState before:\n - Study-uid must exist.\n\nBusiness logic:\n - By default (no study status is provided) list all study compounds for the study uid in status draft. If the study not exist in status draft then return the study compounds for the study in status released. If the study uid only exist as deleted then this is returned.\n - If a specific study status parameter is provided then return study compounds for this study status.\n - If the locked study status parameter is requested then a study version should also be provided, and then the study compounds for the specific locked study version is returned.\n - Indicate by an boolean variable if the study compound can be updated (if the selected study is in status draft).\n - Indicate by an boolean variable if all expected selections have been made for each study compound, or some are missing.\n   - e.g. Compound and TypeOfTreatment are expected.\n - Indicate by an boolean variable if the selected compound is available in a newer version.\n - Indicate by an boolean variable if a study compound can be re-ordered.\n \nState after:\n- no change.\n", "operationId": "get_all_selected_compounds_study__uid__study_compounds_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GenericFilteringReturn_StudySelectionCompound_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compounds/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_compounds_values_for_header_study__uid__study_compounds_headers_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Compounds Values For Header Study  Uid  Study Compounds Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compounds/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List full audit trail related to definition of all study compounds.", "description": "\nParameters:\n - uid as study-uid (required)\n - [NOT YET IMPLEMENTED] study status (optional)\n - [NOT YET IMPLEMENTED] study version (required when study status is locked)\n\nState before:\n - Study must exist.\n\nBusiness logic:\n - List all entries in the audit trail related to study compounds for specified study-uid.\n - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.\n\nReturned data:\n - List of actions and changes related to study compounds.\n    ", "operationId": "get_all_compounds_audit_trail_study__uid__study_compounds_audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Compounds Audit Trail Study  Uid  Study Compounds Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCompound"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compounds/{studycompounduid}/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study compound.", "description": "\nParameters:\n - uid as study-uid (required)\n - study-compound-uid (required)\n - [NOT YET IMPLEMENTED] study status (optional)\n - [NOT YET IMPLEMENTED] study version (required when study status is locked)\n\nState before:\n - Study and study compounds must exist.\n\nBusiness logic:\n - List a specific entry in the audit trail related to the specified study compound for the specified study-uid.\n - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.\n\nReturned data:\n - List of actions and changes related to the specified study compound.\n    ", "operationId": "get_selected_compound_audit_trail_study__uid__study_compounds__studycompounduid__audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycompounduid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycompounduid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Selected Compound Audit Trail Study  Uid  Study Compounds  Studycompounduid  Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCompound"}}}}}, "404": {"description": "Not Found - there exist no selection of the objective for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compounds/{studycompounduid}": {"get": {"tags": ["Study Selections"], "summary": "Returns specific study objective", "description": "\nState before:\n - Study-uid and study-compound-uid must exist\n\nBusiness logic:\n - By default (no study status is provided) list all details for specified study compound for the study uid in status draft. If the study not exist in status draft then return the study compounds for the study in status released. If the study uid only exist as deleted then this is returned.\n - If a specific study status parameter is provided then return study compounds for this study status.\n - If the locked study status parameter is requested then a study version should also be provided, and then the specified study compound for the specific locked study version is returned.  - Indicate by an boolean variable if the study compound can be updated (if the selected study is in status draft).\n - Indicate by an boolean variable if all expected selections have been made for each study compound, or some are missing.\n   - e.g. Compound and TypeOfTreatment are expected.\n - Indicate by an boolean variable if the selected compound is available in a newer version.\n - Indicate by an boolean variable if a study compound can be re-ordered.\n\nState after:\n - no change\n", "operationId": "get_selected_compound_study__uid__study_compounds__studycompounduid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycompounduid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycompounduid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCompound"}}}}, "404": {"description": "Not Found - there exist no selection of the objective for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Delete a study compound.", "description": "\nState before:\n- Study and study-compound-uid must exist and study must be in status draft.\n\nBusiness logic:\n - Remove specified study-compound from the study.\n - Reference to the study-compound should still exist in the the audit trail.\n - If a subsequent study compound exist in the list of study compounds then the order number for following study compound must be decreased with 1.\n\nState after:\n- Study compound is deleted from the study, but still exist as a node in the database with a reference from the audit trail.\n- Added new entry in the audit trail for the deletion of the study-compound.\n", "operationId": "delete_selected_compound_study__uid__study_compounds__studycompounduid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycompounduid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycompounduid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the objective and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "Edit or replace a study compound", "description": "\nState before:\n - Study must exist and be in status draft\n - Compound-uid must exist and be in status Final.\n\nBusiness logic:\n - Update specified study-compound with selection of an existing compound concept in the library.\n - If the selected compound-uid is retired then an error message must be provided.\n - A single relationships can be defined for a study compound to each of the following code list terms:\n   - Type of treatment\n   - Route of administration\n   - Dosages form\n   - Dispensed in\n   - Device\n   - Formulation\n - It is also possible to save a free text string describing other information for the study-compound.\n - Order number for the study compound cannot be changed by this API endpoint.\n - It should be possible to define a 'Reason for missing' value for a specific value of 'Type of treatment'. In this case the following rule apply:\n   - Only the parameter for 'Type of treatment' can be defined - the parameter value for compound or any other related parameters must be null.\n   - No other study compound must exist for the study with the same value for 'Type of Treatment'.\n   - No other 'Reason for missing' value must exist for the study with the same value for 'Type of Treatment' (ReasonForMissing can only be defined once for a TypeOfTreatment).\n   - Thereby either the parameter compound-uid or type-of-treatment-uid must be provided, but not both of them 8they are mutually exclusive).\n\nState after:\n - compound or related parameters is updated for the study compound.\n - Added new entry in the audit trail for the update of the study-compound.", "operationId": "patch_update_compound_selection_study__uid__study_compounds__studycompounduid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycompounduid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycompounduid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionCompoundInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCompound"}}}}, "404": {"description": "Not Found - There exist no selection between the study and objective.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compounds/select": {"post": {"tags": ["Study Selections"], "summary": "Add a study compound to a study based on selection of a compound concept in library, or a 'Reason for missing'.", "description": "\nState before:\n - Study must exist and be in status draft\n - Compound-uid must exist and be in status Final.\n \nBusiness logic:\n - Add a study-compound to the study based on selection of an existing compound concept in the library.\n - If the selected compound-uid is retired then an error message must be provided.\n - A single relationships can be defined for a study compound to each of the following code list terms:\n   - Type of treatment\n   - Route of administration\n   - Dosages form\n   - Dispensed in\n   - Device\n   - Formulation\n - It is also possible to save a free test string describing other information for the study-compound.\n - Order for the study compound must be assigged as the next incremental order number or as 1 if this is the initial study objective for the study.\n - It should be possible to define a 'Reason for missing' value for a specific value of 'Type of treatment'. In this case the following rule apply:\n   - Only the parameter for 'Type of treatment' can be defined - the parameter value for compound or any other related parameters must be null.\n   - No other study compound must exist for the study with the same value for 'Type of Treatment'.\n   - No other 'Reason for missing' value must exist for the study with the same value for 'Type of Treatment' (ReasonForMissing can only be defined once for a TypeOfTreatment).\n   - Thereby either the parameter compound-uid or type-of-treatment-uid must be provided, but not both of them 8they are mytually exclusive).\n\nState after:\n - compound is added as study compound to the study.\n - Added new entry in the audit trail for the creation of the study-compound.\n ", "operationId": "post_new_compound_selection_study__uid__study_compounds_select_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionCompoundInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCompound"}}}}, "403": {"description": "Forbidden - There already exists a selection of the objective", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or objective is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compounds/{studycompounduid}/order": {"patch": {"tags": ["Study Selections"], "summary": "Change display order of study compound", "description": "\nState before:\n- Study and study-compound-uid must exist and study must be in status draft.\n- Old order number must match current order number in database for study compound.\n\nBusiness logic:\n - moves the study selection to the order which is send in the new_order property\n \nState after:\n - Order number for specified study-compound is updated to new order number.\n - Note this will change order on either the preceding or following study-compounds as well.\n - Added new entry in the audit trail for the re-ordering of the study-compounds.\n", "operationId": "patch_new_compound_selection_order_study__uid__study_compounds__studycompounduid__order_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycompounduid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycompounduid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "New Order Input", "allOf": [{"$ref": "#/components/schemas/StudySelectionCompoundNewOrder"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCompound"}}}}, "404": {"description": "Not Found - There exist no selection between the study and objective to reorder.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/{studyendpointuid}/sync-latest-endpoint-version": {"post": {"tags": ["Study Selections"], "summary": "update to latest endpoint version study selection", "description": "\nState before:\n - Study must exist\n - Study endpoint selection must exist\n - Endpoint version selected for study endpoint selection is not the latest available final version of endpoint.\n\nBusiness logic:\n - Update specified endpoint study-selection with the latest final version of previously selected endpoint.\n\nState after:\n - Study exists\n - Study endpoint selection exists\n - Endpoint version selected for study endpoint selection is the latest available final version.\n - Added new entry in the audit trail for the update of the study-endpoint.", "operationId": "sync_latest_endpoint_version_study__uid__study_endpoints__studyendpointuid__sync_latest_endpoint_version_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyendpointuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyendpointuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}, "404": {"description": "Not Found - There exist no selection between the study and endpoint", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/{studyendpointuid}/sync-latest-timeframe-version": {"post": {"tags": ["Study Selections"], "summary": "update to latest timeframe version study selection", "description": "\n    State before:\n     - Study must exist\n     - Study endpoint selection must exist\n     - Timeframe version selected for study endpoint selection is not the latest available final version of the timeframe.\n\n    Business logic:\n     - Update specified endpoint study-selection with the latest final version of previously selected timeframe.\n\n    State after:\n     - Study exists\n     - Study endpoint selection exists\n     - Timeframe version selected for study endpoint selection is the latest available final version.\n     - Added new entry in the audit trail for the update of the study-endpoint.", "operationId": "sync_latest_timeframe_version_study__uid__study_endpoints__studyendpointuid__sync_latest_timeframe_version_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyendpointuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyendpointuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}, "404": {"description": "Not Found - There exist no selection between the study and timeframe", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-endpoints/{studyendpointuid}/accept-version": {"post": {"tags": ["Study Selections"], "summary": "update to latest timeframe version study selection", "description": "\n    State before:\n     - Study must exist\n     - Study endpoint selection must exist\n     - Timeframe and/or endpoint version selected for study endpoint selection is not the latest available final version of the timeframe.\n\n    Business logic:\n     - Update specified endpoint study-selection, setting accepted version to show that update was refused by user.\n\n    State after:\n     - Study exists\n     - Study endpoint selection exists\n     - Timeframe and endpoint version selected for study endpoint selection is not changed.\n     - Added new entry in the audit trail for the update of the study-endpoint.", "operationId": "patch_endpoint_accept_version_study__uid__study_endpoints__studyendpointuid__accept_version_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyendpointuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyendpointuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}}}, "404": {"description": "Not Found - There exist no selection between the study and timeframe", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-objectives/{studyobjectiveuid}/accept-version": {"post": {"tags": ["Study Selections"], "summary": "update to latest timeframe version study selection", "description": "\n    State before:\n     - Study must exist\n     - Study endpoint selection must exist\n     - Objective version selected for study endpoint selection is not the latest available final version of the timeframe.\n\n    Business logic:\n     - Update specified endpoint study-selection, setting accepted version to show that update was refused by user.\n\n    State after:\n     - Study exists\n     - Study endpoint selection exists\n     - Objective version selected for study endpoint selection is not changed.\n     - Added new entry in the audit trail for the update of the study-endpoint.", "operationId": "patch_objective_accept_version_study__uid__study_objectives__studyobjectiveuid__accept_version_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyobjectiveuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyobjectiveuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionObjective"}}}}, "404": {"description": "Not Found - There exist no selection between the study and timeframe", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-criteria": {"get": {"tags": ["Study Selections"], "summary": "Returns all study criteria currently selected", "operationId": "get_all_selected_criteria_for_all_studies_study_study_criteria_get", "parameters": [{"description": "Indicates whether brackets around Template Parameters in the Criteriashould be returned", "required": false, "schema": {"title": "Nobrackets", "type": "boolean", "description": "Indicates whether brackets around Template Parameters in the Criteriashould be returned", "default": false}, "name": "noBrackets", "in": "query"}, {"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionCriteria_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-criteria/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_criteria_values_for_header_study_study_criteria_headers_get", "parameters": [{"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Criteria Values For Header Study Study Criteria Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria": {"get": {"tags": ["Study Selections"], "summary": "Returns all study criteria currently selected for study with provided uid", "description": "\n    State before:\n    - Study must exist.\n    \n    Business logic:\n    - By default (no study status is provided) list all study criteria for the study uid in status draft. If the study not exist in status draft then return the study criteria for the study in status released. If the study uid only exist as deleted then this is returned.\n    - If a specific study status parameter is provided then return study criteria for this study status.\n    - If the locked study status parameter is requested then a study version should also be provided, and then the study criteria for the specific locked study version is returned.\n    - Indicate by a boolean variable if the study criteria can be updated (if the selected study is in status draft).  \n    - Indicate by a boolean variable if all expected selections have been made for each study criteria, or some are missing.\n    - e.g. a criteria instance is expected.\n    - Indicate by an boolean variable if a study criteria can be re-ordered.\n\n    State after:\n    - no change.\n    \n    Possible errors:\n    - Invalid study-uid.\n    \n    Returned data:\n    List selected study with the following information:\n    - studyUid\n    - studyCriteriaUid\n    - order (Derived Integer, valid in the scope of a criteriaType)\n    - criteriaUid (Selected CriteriaRoot  uid)\n    - criteriaName (String, CriteriaValue name)\n    - criteriaType (String, derived from the selected criteria instance's template, which has a connection to a type node)\n    - note (String)\n    - Modified (as a date of last modification).\n    - Possible Actions (based on study state, version of selected nodes, metadata consistency checks, etc. - see business rules).\n        - Boolean indication if edit is possible.\n        - Boolean indication if all expected selections have been made.\n        - Boolean indication if the study criteria can be re-ordered.\n    ", "operationId": "get_all_selected_criteria_study__uid__study_criteria_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Indicates whether brackets around Template Parameters in the Criteriashould be returned", "required": false, "schema": {"title": "Nobrackets", "type": "boolean", "description": "Indicates whether brackets around Template Parameters in the Criteriashould be returned", "default": false}, "name": "noBrackets", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionCriteria_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_study_criteria_values_for_header_study__uid__study_criteria_headers_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Study Criteria Values For Header Study  Uid  Study Criteria Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List full audit trail related to definition of all study criteria.", "description": "\n    State before:\n    - Study must exist.\n\n    Business logic:\n    - List all entries in the audit trail related to study criteria for specified study-uid.\n    - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\n    State after:\n    - no change.\n    \n    Possible errors:\n    - Invalid study-uid.\n\n    Returned data:\n    List selected study with the following information:\n    - studyUid\n    - studyCriteriaUid\n    - order (Derived Integer)\n    - criteriaUid (Selected CriteriaRoot  uid)\n    - criteriaName (String, CriteriaValue name)\n    - criteriaType (String, derived from the selected criteria instance's template, which has a connection to a type node)\n    - note (String)\n    - Modified (as a date of last modification).\n    - Possible Actions (based on study state, version of selected nodes, metadata consistency checks, etc. - see business rules).\n        - Boolean indication if edit is possible.\n        - Boolean indication if all expected selections have been made.\n        - Boolean indication if the study criteria can be re-ordered.\n    ", "operationId": "get_all_criteria_audit_trail_study__uid__study_criteria_audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Criteria Audit Trail Study  Uid  Study Criteria Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCriteriaCore"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria/{studycriteriauid}": {"get": {"tags": ["Study Selections"], "summary": "Returns specific study criteria", "description": "\n    State before:\n    - Study and study criteria must exist\n    \n    Business logic:\n    - By default (no study status is provided) list all details for specified study criteria for the study uid in status draft. If the study not exist in status draft then return the study criteria for the study in status released. If the study uid only exist as deleted then this is returned.\n    - If a specific study status parameter is provided then return study criteria for this study status.\n    - If the locked study status parameter is requested then a study version should also be provided, and then the specified study criteria for the specific locked study version is returned.\n    - Indicate by an boolean variable if the study criteria can be updated (if the selected study is in status draft).\n    - Indicate by an boolean variable if all expected selections have been made for each study criteria, or some are missing.\n    - Indicate by an boolean variable if the selected criteria is available in a newer version.\n    - Indicate by an boolean variable if a study criteria can be re-ordered.\n    \n    State after:\n    - no change\n    \n    Possible errors:\n    - Invalid study-uid or studyCriteriaUid.\n    \n    Returned data:\n    List selected study with the following information:\n    - studyUid\n    - studyCriteriaUid\n    - order (Derived Integer)\n    - criteriaUid (Selected CriteriaRoot  uid)\n    - criteriaName (String, CriteriaValue name)\n    - criteriaType (String, derived from the selected criteria instance's template, which has a connection to a type node)\n    - note (String)\n    - Modified (as a date of last modification).\n    - Possible Actions (based on study state, version of selected nodes, metadata consistency checks, etc. - see business rules).\n        - Boolean indication if edit is possible.\n        - Boolean indication if all expected selections have been made.\n        - Boolean indication if the study criteria can be re-ordered.\n    ", "operationId": "get_selected_criteria_study__uid__study_criteria__studycriteriauid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycriteriauid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycriteriauid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCriteria"}}}}, "404": {"description": "Not Found - there exists no selection of the criteria for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Deletes a study criteria", "description": "\n    State before:\n    - Study must exist and study status must be in draft.\n    - studyCriteriaUid must exist. \n\n    Business logic:\n    - Remove specified study-criteria from the study.\n    - Reference to the study-criteria should still exist in the the audit trail.\n\n    State after:\n    - Study criteria deleted from the study, but still exist as a node in the database with a reference from the audit trail.\n    - Added new entry in the audit trail for the deletion of the study-criteria .\n    \n    Possible errors:\n    - Invalid study-uid or studyCriteriaUid.\n\n    Returned data:\n    - none\n    ", "operationId": "delete_selected_criteria_study__uid__study_criteria__studycriteriauid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycriteriauid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycriteriauid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the criteria and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria/{studycriteriauid}/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study criteria.", "description": "\n    State before:\n    - Study and study criteria must exist.\n\n    Business logic:\n    - List a specific entry in the audit trail related to the specified study criteria for the specified study-uid.\n    - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\n    State after:\n    - no change.\n    \n    Possible errors:\n    - Invalid study-uid.\n\n    Returned data:\n    List selected study with the following information:\n    - studyUid\n    - studyCriteriaUid\n    - order (Derived Integer)\n    - criteriaUid (Selected CriteriaRoot  uid)\n    - criteriaName (String, CriteriaValue name)\n    - criteriaType (String, derived from the selected criteria instance's template, which has a connection to a type node)\n    - note (String)\n    - Modified (as a date of last modification).\n    - Possible Actions (based on study state, version of selected nodes, metadata consistency checks, etc. - see business rules).\n        - Boolean indication if edit is possible.\n        - Boolean indication if all expected selections have been made.\n        - Boolean indication if the study criteria can be re-ordered.\n    ", "operationId": "get_selected_criteria_audit_trail_study__uid__study_criteria__studycriteriauid__audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycriteriauid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycriteriauid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Selected Criteria Audit Trail Study  Uid  Study Criteria  Studycriteriauid  Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCriteriaCore"}}}}}, "404": {"description": "Not Found - there exist no selection of the criteria for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria/create": {"post": {"tags": ["Study Selections"], "summary": "Creating a study criteria selection based on the input data including creating new criteria", "description": "\n    State before:\n    - Study must exist and study status must be in draft.\n\n    Business logic:\n    - Create a study criteria and to a study based on valid selections and values.\n    \n    State after:\n    - criteria instance is created\n    - criteria is added as study criteria to the study.\n    - Added new entry in the audit trail for the creation of the study-criteria.\n    \n    Possible errors:\n    - Invalid study-uid.\n\n    Returned data:\n    List selected study with the following information:\n    - studyUid\n    - studyCriteriaUid\n    - order (Derived Integer)\n    - criteriaUid (Selected CriteriaRoot  uid)\n    - criteriaName (String, CriteriaValue name)\n    - criteriaType (String, derived from the selected criteria instance's template, which has a connection to a type node)\n    - note (String)\n    - Modified (as a date of last modification).\n    - Possible Actions (based on study state, version of selected nodes, metadata consistency checks, etc. - see business rules).\n        - Boolean indication if edit is possible. (study is in Draft status)\n        - Boolean indication if all expected selections have been made. (expected !== required)\n    ", "operationId": "post_new_criteria_selection_create_study__uid__study_criteria_create_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionCriteriaCreateInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCriteria"}}}}, "403": {"description": "Forbidden - There already exists a selection of the criteria", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or criteria is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria/create/preview": {"post": {"tags": ["Study Selections"], "summary": "Previews creating a study criteria selection based on the input data including creating new criteria", "operationId": "preview_new_criteria_selection_create_study__uid__study_criteria_create_preview_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionCriteriaCreateInput"}], "description": "Related parameters of the selection that shall be previewed."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCriteria"}}}}, "403": {"description": "Forbidden - There already exists a selection of the criteria", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or criteria is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria/batch-select": {"post": {"tags": ["Study Selections"], "summary": "Select multiple criteria templates as a batch. If the template has no parameters, will also create the instance.", "description": "\n    State before:\n    - Study must exist and study status must be in draft.\n\n    Business logic:\n    - Select criteria template without instantiating them.\n    - This must be done as a batch\n    \n    State after:\n    - Study criteria is created.\n    - Criteria templates are all selected by the study criteria.\n    - If a given template has no parameters, the instance will be created and selected.\n    - Added new entry in the audit trail for the creation of the study-criteria.\n    \n    Possible errors:\n    - Invalid study-uid.\n    - Invalid study-criteria-template-uid.\n\n    Returned data:\n    List selected criteria templates/instances with the following information:\n    - studyUid\n    - studyCriteriaTemplateUid / studyCriteriaUid\n    - order (Derived Integer)\n    - latest version of the selected criteria template/instance\n    ", "operationId": "post_batch_select_criteria_template_study__uid__study_criteria_batch_select_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCriteriaTemplateSelectInput"}, "description": "List of objects with properties needed to identify the templates to select"}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Post Batch Select Criteria Template Study  Uid  Study Criteria Batch Select Post", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCriteria"}}}}}, "403": {"description": "Forbidden - There already exists a selection of the criteria", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or criteria is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria/{studycriteriauid}/finalize": {"patch": {"tags": ["Study Selections"], "summary": "Finalize the study criteria template selection by creating an instance of this template", "description": "\n    State before:\n    - Study and study selection must exist and the selected object must be a template and not an instance.\n\n    Business logic:\n    - Create an instance of the selected template\n    - Re-attach the study criteria object to the instance instead of the template\n    \n    State after:\n    - Instance of the template is created\n    - Study criteria is detached from the template\n    - Study criteria is attached to the instance\n    \n    Possible errors:\n    - Invalid study-uid.\n    - Invalid study-criteria-uid.\n\n    Returned data:\n    Selected criteria instance with the following information:\n    - studyUid\n    - studyCriteriaUid\n    - order\n    - latest version of the selected criteria\n    ", "operationId": "patch_finalize_criteria_selection_study__uid__study_criteria__studycriteriauid__finalize_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycriteriauid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycriteriauid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Criteria Data", "allOf": [{"$ref": "#/components/schemas/CriteriaCreateInput"}], "description": "Data necessary to create the criteria instance from the template"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCriteria"}}}}, "404": {"description": "Not Found - Study or study criteria is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria/{studycriteriauid}/order": {"patch": {"tags": ["Study Selections"], "summary": "Change the order of a study criteria", "operationId": "patch_new_criteria_selection_order_study__uid__study_criteria__studycriteriauid__order_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycriteriauid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycriteriauid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "New Order Input", "allOf": [{"$ref": "#/components/schemas/StudySelectionCriteriaNewOrder"}], "description": "New value to set for the order property of the selection"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCriteria"}}}}, "404": {"description": "Not Found - There exists no selection between the study and criteria to reorder.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-criteria/{studycriteriauid}/key-criteria": {"patch": {"tags": ["Study Selections"], "summary": "Change the key-criteria property of a study criteria", "operationId": "patch_criteria_selection_key_criteria_property_study__uid__study_criteria__studycriteriauid__key_criteria_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycriteriauid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycriteriauid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Key Criteria Input", "allOf": [{"$ref": "#/components/schemas/StudySelectionCriteriaKeyCriteria"}], "description": "New value to set for the key-criteria property of the selection"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCriteria"}}}}, "404": {"description": "Not Found - There exists no selection between the study and criteria to change.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-activities": {"get": {"tags": ["Study Selections"], "summary": "Returns all study activities currently selected", "operationId": "get_all_selected_activities_for_all_studies_study_study_activities_get", "parameters": [{"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "A list of activity names to use as a specific filter", "required": false, "schema": {"title": "Activitynames", "type": "array", "items": {"type": "string"}, "description": "A list of activity names to use as a specific filter"}, "name": "activityNames", "in": "query"}, {"description": "A list of activity sub group names to use as a specific filter", "required": false, "schema": {"title": "Activitysubgroupnames", "type": "array", "items": {"type": "string"}, "description": "A list of activity sub group names to use as a specific filter"}, "name": "activitySubGroupNames", "in": "query"}, {"description": "A list of activity group names to use as a specific filter", "required": false, "schema": {"title": "Activitygroupnames", "type": "array", "items": {"type": "string"}, "description": "A list of activity group names to use as a specific filter"}, "name": "activityGroupNames", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionActivity_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activities": {"get": {"tags": ["Study Selections"], "summary": "Returns all study activities currently selected", "operationId": "get_all_selected_activities_study__uid__study_activities_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionActivity_"}}}}, "404": {"description": "Not Found - there is no study with the given uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activities/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_activity_values_for_header_study__uid__study_activities_headers_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Activity Values For Header Study  Uid  Study Activities Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activities/{studyactivityuid}": {"get": {"tags": ["Study Selections"], "summary": "Returns specific study activity", "operationId": "get_selected_activity_study__uid__study_activities__studyactivityuid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyactivityuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyactivityuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionActivity"}}}}, "404": {"description": "Not Found - there exists no selection of the activity for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Delete a study activity", "operationId": "delete_selected_activity_study__uid__study_activities__studyactivityuid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyactivityuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyactivityuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the activity and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "Edit a study activity", "description": "\nState before:\n - Study must exist and be in status draft\n\nBusiness logic:\n \n\nState after:\n - Added new entry in the audit trail for the update of the study-activity.", "operationId": "patch_update_activity_selection_study__uid__study_activities__studyactivityuid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyactivityuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyactivityuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionActivityInput"}], "description": "Related parameters of the selection that shall be updated."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionActivity"}}}}, "404": {"description": "Not Found - There exist no selection between the study and activity.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activities/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List full audit trail related to definition of all study activities.", "description": "\nThe following values should be returned for all study activities:\n- dateTime\n- userInitials\n- action\n- activity\n- order\n    ", "operationId": "get_all_activity_audit_trail_study__uid__study_activities_audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Activity Audit Trail Study  Uid  Study Activities Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionActivityCore"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activities/{studyactivityuid}/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study activity.", "operationId": "get_selected_activity_audit_trail_study__uid__study_activities__studyactivityuid__audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyactivityuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyactivityuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Selected Activity Audit Trail Study  Uid  Study Activities  Studyactivityuid  Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionActivityCore"}}}}}, "404": {"description": "Not Found - there exist no selection of the activity for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activities/create": {"post": {"tags": ["Study Selections"], "summary": "Creating a study activity selection based on the input data", "operationId": "post_new_activity_selection_create_study__uid__study_activities_create_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionActivityCreateInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionActivity"}}}}, "403": {"description": "Forbidden - There already exists a selection of the activity", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or activity is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activities/batch": {"post": {"tags": ["Study Selections"], "summary": "Batch create and/or edit of study activities", "operationId": "activity_selection_batch_operations_study__uid__study_activities_batch_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Operations", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionActivityBatchInput"}}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Activity Selection Batch Operations Study  Uid  Study Activities Batch Post", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionActivityBatchOutput"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activities/{studyactivityuid}/order": {"patch": {"tags": ["Study Selections"], "summary": "Change the order of a study activity", "operationId": "patch_new_activity_selection_order_study__uid__study_activities__studyactivityuid__order_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyactivityuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyactivityuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "New Order Input", "allOf": [{"$ref": "#/components/schemas/StudySelectionActivityNewOrder"}], "description": "New value to set for the order property of the selection"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionActivity"}}}}, "404": {"description": "Not Found - There exists no selection between the study and activity to reorder.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-arms": {"get": {"tags": ["Study Selections"], "summary": "List all study arms currently selected for study with provided uid", "description": "\n    State before:\n    - Study must exist.\n     \n    Business logic:\n     - By default (no study status is provided) list all study arms for the study uid in status draft. If the study not exist in status draft then return the study arms for the study in status released. If the study uid only exist as deleted then this is returned.\n     - If a specific study status parameter is provided then return study arm for this study status.\n    - If the locked study status parameter is requested then a study version should also be provided, and then the study arms for the specific locked study version is returned.\n    - Indicate by a boolean variable if the study arm can be updated (if the selected study is in status draft).  \n    - Indicate by a boolean variable if all expected selections have been made for each study arms, or some are missing.\n\n\n    State after:\n    - no change.\n     \n    Possible errors:\n    - Invalid study-uid.\n", "operationId": "get_all_selected_arms_study__uid__study_arms_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionArmWithConnectedBranchArms_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-arms/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_arm_values_for_header_study__uid__study_arms_headers_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Arm Values For Header Study  Uid  Study Arms Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-arms": {"get": {"tags": ["Study Selections"], "summary": "Returns all study arms currently selected", "operationId": "get_all_selected_arms_for_all_studies_study_study_arms_get", "parameters": [{"description": "Optionally, the name of the project for which to return study selections.", "required": false, "schema": {"title": "Projectname", "type": "string", "description": "Optionally, the name of the project for which to return study selections."}, "name": "projectName", "in": "query"}, {"description": "Optionally, the number of the project for which to return study selections.", "required": false, "schema": {"title": "Projectnumber", "type": "string", "description": "Optionally, the number of the project for which to return study selections."}, "name": "projectNumber", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionArmWithConnectedBranchArms_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-arms/create": {"post": {"tags": ["Study Selections"], "summary": "Creating a study arm selection based on the input data", "operationId": "post_new_arm_selection_create_study__uid__study_arms_create_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionArmCreateInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionArm"}}}}, "403": {"description": "Forbidden - There already exists a selection of the arm", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or arm is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-arms/{studyarmuid}": {"get": {"tags": ["Study Selections"], "summary": "Returns specific study arm", "operationId": "get_selected_arm_study__uid__study_arms__studyarmuid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyarmuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyarmuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionArmWithConnectedBranchArms"}}}}, "404": {"description": "Not Found - there exists no selection of the arm for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Delete a study arm", "operationId": "delete_selected_arm_study__uid__study_arms__studyarmuid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyarmuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyarmuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the arm and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "Edit a study arm", "description": "\nState before:\n - Study must exist and be in status draft\n\nBusiness logic:\n\n\nState after:\n - Added new entry in the audit trail for the update of the study-arm.", "operationId": "patch_update_arm_selection_study__uid__study_arms__studyarmuid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyarmuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyarmuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionArmInput"}], "description": "Related parameters of the selection that shall be updated."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionArmWithConnectedBranchArms"}}}}, "404": {"description": "Not Found - There exist no selection between the study and arm.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-arms/{studyarmuid}/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study arm.", "operationId": "get_selected_arm_audit_trail_study__uid__study_arms__studyarmuid__audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyarmuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyarmuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Selected Arm Audit Trail Study  Uid  Study Arms  Studyarmuid  Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionArmVersion"}}}}}, "404": {"description": "Not Found - there exist no selection of the activity for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-arms/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of all study arms.", "operationId": "get_all_arm_audit_trail_study__uid__study_arms_audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Arm Audit Trail Study  Uid  Study Arms Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionArmVersion"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-arms/{studyarmuid}/order": {"patch": {"tags": ["Study Selections"], "summary": "Change the order of a study arm", "operationId": "patch_new_arm_selection_order_study__uid__study_arms__studyarmuid__order_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyarmuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyarmuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "New Order Input", "allOf": [{"$ref": "#/components/schemas/StudySelectionArmNewOrder"}], "description": "New value to set for the order property of the selection"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionArmWithConnectedBranchArms"}}}}, "404": {"description": "Not Found - There exists no selection between the study and arm to reorder.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-elements/create": {"post": {"tags": ["Study Selections"], "summary": "Creating a study element selection based on the input data", "operationId": "post_new_element_selection_create_study__uid__study_elements_create_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionElementCreateInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionElement"}}}}, "403": {"description": "Forbidden - There already exists a selection of the element", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or element is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-elements": {"get": {"tags": ["Study Selections"], "summary": "List all study elements currently selected for study with provided uid", "description": "\n    State before:\n    - Study must exist.\n\n    State after:\n    - no change.\n     \n    Possible errors:\n    - Invalid study-uid.\n", "operationId": "get_all_selected_elements_study__uid__study_elements_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionElement_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-elements/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_element_values_for_header_study__uid__study_elements_headers_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Element Values For Header Study  Uid  Study Elements Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-elements/{studyelementuid}": {"get": {"tags": ["Study Selections"], "summary": "Returns specific study element", "operationId": "get_selected_element_study__uid__study_elements__studyelementuid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyelementuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyelementuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionElement"}}}}, "404": {"description": "Not Found - there exists no selection of the element for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Delete a study element", "operationId": "delete_selected_element_study__uid__study_elements__studyelementuid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyelementuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyelementuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the element and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "Edit a study element", "description": "\n        State before:\n        - Study must exist and be in status draft\n\n        Business logic:\n\n        State after:\n        - Added new entry in the audit trail for the update of the study-element.", "operationId": "patch_update_element_selection_study__uid__study_elements__studyelementuid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyelementuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyelementuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionElementInput"}], "description": "Related parameters of the selection that shall be updated."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionElement"}}}}, "404": {"description": "Not Found - There exist no selection between the study and element.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-elements/{studyelementuid}/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study element.", "operationId": "get_selected_element_audit_trail_study__uid__study_elements__studyelementuid__audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyelementuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyelementuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Selected Element Audit Trail Study  Uid  Study Elements  Studyelementuid  Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionElementVersion"}}}}}, "404": {"description": "Not Found - there exist no selection of the activity for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-element/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of all study element.", "operationId": "get_all_element_audit_trail_study__uid__study_element_audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Element Audit Trail Study  Uid  Study Element Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionElementVersion"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-elements/allowed-element-configs": {"get": {"tags": ["Study Selections"], "summary": "Returns all allowed config sets for element type and subtype", "operationId": "get_all_configs_study_study_elements_allowed_element_configs_get", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Configs Study Study Elements Allowed Element Configs Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyElementTypes"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-elements/{studyelementuid}/order": {"patch": {"tags": ["Study Selections"], "summary": "Change the order of a study element", "operationId": "patch_new_element_selection_order_study__uid__study_elements__studyelementuid__order_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studyelementuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studyelementuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "New Order Input", "allOf": [{"$ref": "#/components/schemas/StudySelectionElementNewOrder"}], "description": "New value to set for the order property of the selection"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionElement"}}}}, "404": {"description": "Not Found - There exists no selection between the study and element to reorder.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-branch-arms/create": {"post": {"tags": ["Study Selections"], "summary": "Creating a study branch arm selection based on the input data", "operationId": "post_new_branch_arm_selection_create_study__uid__study_branch_arms_create_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionBranchArmCreateInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionBranchArm"}}}}, "403": {"description": "Forbidden - There already exists a selection of the branch arm", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or branch arm is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-branch-arms": {"get": {"tags": ["Study Selections"], "summary": "List all study branch arms currently selected for study with provided uid", "description": "\n    State before:\n    - Study must exist.\n     \n    Business logic:\n     - By default (no study status is provided) list all study branch arms for the study uid in status draft. If the study not exist in status draft then return the study branch arms for the study in status released. If the study uid only exist as deleted then this is returned.\n     - If a specific study status parameter is provided then return study branch arm for this study status.\n    - If the locked study status parameter is requested then a study version should also be provided, and then the study branch arms for the specific locked study version is returned.\n    - Indicate by a boolean variable if the study branch arm can be updated (if the selected study is in status draft).  \n    - Indicate by a boolean variable if all expected selections have been made for each study branch arms, or some are missing.\n\n\n    State after:\n    - no change.\n     \n    Possible errors:\n    - Invalid study-uid.\n", "operationId": "get_all_selected_branch_arms_study__uid__study_branch_arms_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Selected Branch Arms Study  Uid  Study Branch Arms Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionBranchArm"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-branch-arms/{studybrancharmuid}": {"get": {"tags": ["Study Selections"], "summary": "Returns specific study branch arm", "operationId": "get_selected_branch_arm_study__uid__study_branch_arms__studybrancharmuid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studybrancharmuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studybrancharmuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionBranchArm"}}}}, "404": {"description": "Not Found - there exists no selection of the branch arm for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Delete a study branch arm", "operationId": "delete_selected_branch_arm_study__uid__study_branch_arms__studybrancharmuid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studybrancharmuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studybrancharmuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the branch arm and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "Edit a study branch arm", "description": "\n            State before:\n            - Study must exist and be in status draft\n            Business logic:\n\n            State after:\n            - Added new entry in the audit trail for the update of the study-branch-arm.", "operationId": "patch_update_branch_arm_selection_study__uid__study_branch_arms__studybrancharmuid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studybrancharmuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studybrancharmuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionBranchArmEditInput"}], "description": "Related parameters of the selection that shall be updated."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionBranchArm"}}}}, "404": {"description": "Not Found - There exist no selection between the study and branch arm.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-branch-arms/{studybrancharmuid}/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study branch-arm.", "operationId": "get_selected_branch_arm_audit_trail_study__uid__study_branch_arms__studybrancharmuid__audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studybrancharmuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studybrancharmuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Selected Branch Arm Audit Trail Study  Uid  Study Branch Arms  Studybrancharmuid  Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionBranchArmVersion"}}}}}, "404": {"description": "Not Found - there exist no selection of the activity for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-branch-arm/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of all study branch-arm.", "operationId": "get_all_branch_arm_audit_trail_study__uid__study_branch_arm_audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Branch Arm Audit Trail Study  Uid  Study Branch Arm Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionBranchArmVersion"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-branch-arms/{studybrancharmuid}/order": {"patch": {"tags": ["Study Selections"], "summary": "Change the order of a study branch arm", "operationId": "patch_new_branch_arm_selection_order_study__uid__study_branch_arms__studybrancharmuid__order_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studybrancharmuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studybrancharmuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "New Order Input", "allOf": [{"$ref": "#/components/schemas/StudySelectionBranchArmNewOrder"}], "description": "New value to set for the order property of the selection"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionBranchArm"}}}}, "404": {"description": "Not Found - There exists no selection between the study and branch arm to reorder.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-branch-arms/arm/{armUid}": {"get": {"tags": ["Study Selections"], "summary": "List all study branch arms currently selected for study with provided uid", "description": "\n    State before:\n    - Study must exist.\n     \n    Business logic:\n     - By default (no study status is provided) list all study branch arms for the study uid in status draft. If the study not exist in status draft then return the study branch arms for the study in status released. If the study uid only exist as deleted then this is returned.\n     - If a specific study status parameter is provided then return study branch arm for this study status.\n    - If the locked study status parameter is requested then a study version should also be provided, and then the study branch arms for the specific locked study version is returned.\n    - Indicate by a boolean variable if the study branch arm can be updated (if the selected study is in status draft).  \n    - Indicate by a boolean variable if all expected selections have been made for each study branch arms, or some are missing.\n\n\n    State after:\n    - no change.\n     \n    Possible errors:\n    - Invalid study-uid.\n", "operationId": "get_all_selected_branch_arms_within_arm_study__uid__study_branch_arms_arm__armUid__get", "parameters": [{"required": true, "schema": {"title": "Uid", "type": "string"}, "name": "uid", "in": "path"}, {"required": true, "schema": {"title": "Armuid", "type": "string"}, "name": "armUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Selected Branch Arms Within Arm Study  Uid  Study Branch Arms Arm  Armuid  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionBranchArm"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-cohorts/create": {"post": {"tags": ["Study Selections"], "summary": "Creating a study cohort selection based on the input data", "operationId": "post_new_cohort_selection_create_study__uid__study_cohorts_create_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionCohortCreateInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCohort"}}}}, "403": {"description": "Forbidden - There already exists a selection of the cohort", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or cohort is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-cohorts": {"get": {"tags": ["Study Selections"], "summary": "List all study cohorts currently selected for study with provided uid", "description": "\n    State before:\n    - Study must exist.\n     \n    Business logic:\n     - By default (no study status is provided) list all study cohorts for the study uid in status draft. If the study not exist in status draft then return the study cohorts for the study in status released. If the study uid only exist as deleted then this is returned.\n     - If a specific study status parameter is provided then return study cohort for this study status.\n    - If the locked study status parameter is requested then a study version should also be provided, and then the study cohorts for the specific locked study version is returned.\n    - Indicate by a boolean variable if the study cohort can be updated (if the selected study is in status draft).  \n    - Indicate by a boolean variable if all expected selections have been made for each study cohorts, or some are missing.\n\n\n    State after:\n    - no change.\n     \n    Possible errors:\n    - Invalid study-uid.\n", "operationId": "get_all_selected_cohorts_study__uid__study_cohorts_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "The unique id of the study arm for which specified study cohorts should be returned", "required": false, "schema": {"title": "Armuid", "type": "string", "description": "The unique id of the study arm for which specified study cohorts should be returned", "default": false}, "name": "armUid", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySelectionCohort_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-cohorts/{studycohortuid}": {"get": {"tags": ["Study Selections"], "summary": "Returns specific study cohort", "operationId": "get_selected_cohort_study__uid__study_cohorts__studycohortuid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycohortuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycohortuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCohort"}}}}, "404": {"description": "Not Found - there exists no selection of the cohort for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Delete a study cohort", "operationId": "delete_selected_cohort_study__uid__study_cohorts__studycohortuid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycohortuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycohortuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the cohort and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "Edit a study cohort", "description": "\n            State before:\n            - Study must exist and be in status draft\n            Business logic:\n\n            State after:\n            - Added new entry in the audit trail for the update of the study-cohort.", "operationId": "patch_update_cohort_selection_study__uid__study_cohorts__studycohortuid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycohortuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycohortuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudySelectionCohortEditInput"}], "description": "Related parameters of the selection that shall be updated."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCohort"}}}}, "404": {"description": "Not Found - There exist no selection between the study and cohort.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-cohorts/{studycohortuid}/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study study-cohorts.", "operationId": "get_selected_cohort_audit_trail_study__uid__study_cohorts__studycohortuid__audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycohortuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycohortuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Selected Cohort Audit Trail Study  Uid  Study Cohorts  Studycohortuid  Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCohortVersion"}}}}}, "404": {"description": "Not Found - there exist no selection of the activity for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-cohort/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of all study study-cohort.", "operationId": "get_all_cohort_audit_trail_study__uid__study_cohort_audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Cohort Audit Trail Study  Uid  Study Cohort Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCohortVersion"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-cohorts/{studycohortuid}/order": {"patch": {"tags": ["Study Selections"], "summary": "Change the order of a study cohort", "operationId": "patch_new_cohort_selection_order_study__uid__study_cohorts__studycohortuid__order_patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study selection.", "required": true, "schema": {"title": "Studycohortuid", "type": "string", "description": "The unique id of the study selection."}, "name": "studycohortuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "New Order Input", "allOf": [{"$ref": "#/components/schemas/StudySelectionCohortNewOrder"}], "description": "New value to set for the order property of the selection"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudySelectionCohort"}}}}, "404": {"description": "Not Found - There exists no selection between the study and cohort to reorder.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-activity-instructions": {"get": {"tags": ["Study Selections"], "summary": "Returns all study activity instructions currently selected", "operationId": "get_all_activity_instructions_for_all_studies_study_study_activity_instructions_get", "parameters": [{"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudyActivityInstruction_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activity-instructions": {"get": {"tags": ["Study Selections"], "summary": "List all study activity instructions currently defined for the study", "operationId": "get_all_selected_instructions_study__uid__study_activity_instructions_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Selected Instructions Study  Uid  Study Activity Instructions Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyActivityInstruction"}}}}}, "404": {"description": "Not Found - there is no study with the given uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activity-instructions/{studyactivityinstructionuid}": {"delete": {"tags": ["Study Selections"], "summary": "Delete a study activity instruction", "operationId": "delete_activity_instructon_study__uid__study_activity_instructions__studyactivityinstructionuid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study activity instruction.", "required": true, "schema": {"title": "Studyactivityinstructionuid", "type": "string", "description": "The unique id of the study activity instruction."}, "name": "studyactivityinstructionuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the activity instruction and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activity-instructions/batch": {"post": {"tags": ["Study Selections"], "summary": "Batch operations (create, delete) for study activity instructions", "operationId": "activity_instruction_batch_operations_study__uid__study_activity_instructions_batch_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Operations", "type": "array", "items": {"$ref": "#/components/schemas/StudyActivityInstructionBatchInput"}, "description": "List of operation to perform"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Activity Instruction Batch Operations Study  Uid  Study Activity Instructions Batch Post", "type": "array", "items": {"$ref": "#/components/schemas/StudyActivityInstructionBatchOutput"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activity-schedules": {"get": {"tags": ["Study Selections"], "summary": "List all study activity schedules currently defined for the study", "operationId": "get_all_selected_activities_study__uid__study_activity_schedules_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Selected Activities Study  Uid  Study Activity Schedules Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyActivitySchedule"}}}}}, "404": {"description": "Not Found - there is no study with the given uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Study Selections"], "summary": "Add a study activity schedule to a study", "operationId": "post_new_activity_schedule_create_study__uid__study_activity_schedules_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyActivityScheduleCreateInput"}], "description": "Related parameters of the schedule that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyActivitySchedule"}}}}, "403": {"description": "Forbidden - A study activity schedule already exists for selected study activity and visit", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study, study activity or study visit is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activity-schedules/{studyactivitiescheduleuid}": {"delete": {"tags": ["Study Selections"], "summary": "Delete a study activity schedule", "operationId": "delete_activity_schedule_study__uid__study_activity_schedules__studyactivitiescheduleuid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study activity schedule.", "required": true, "schema": {"title": "Studyactivitiescheduleuid", "type": "string", "description": "The unique id of the study activity schedule."}, "name": "studyactivitiescheduleuid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the activity schedule and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activity-schedules/audit-trail/": {"get": {"tags": ["Study Selections"], "summary": "List full audit trail related to definition of all study activity schedules.", "description": "\nThe following values should be returned for all study activities:\n- dateTime\n- userInitials\n- action\n- activity\n- order\n    ", "operationId": "get_all_schedules_audit_trail_study__uid__study_activity_schedules_audit_trail__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Schedules Audit Trail Study  Uid  Study Activity Schedules Audit Trail  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyActivityScheduleHistory"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-activity-schedules/batch": {"post": {"tags": ["Study Selections"], "summary": "Batch operations (create, delete) for study activity schedules", "operationId": "activity_schedule_batch_operations_study__uid__study_activity_schedules_batch_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Operations", "type": "array", "items": {"$ref": "#/components/schemas/StudyActivityScheduleBatchInput"}, "description": "List of operation to perform"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Activity Schedule Batch Operations Study  Uid  Study Activity Schedules Batch Post", "type": "array", "items": {"$ref": "#/components/schemas/StudyActivityScheduleBatchOutput"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compound-dosings": {"get": {"tags": ["Study Selections"], "summary": "List all study compound dosings currently defined for the study", "operationId": "get_all_selected_compound_dosings_study__uid__study_compound_dosings_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/GenericFilteringReturn_StudyCompoundDosing_"}}}}, "404": {"description": "Not Found - there is no study with the given uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compound-dosings/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_study__uid__study_compound_dosings_headers_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Study  Uid  Study Compound Dosings Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-compound-dosings/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_compound_dosings_values_for_header_study_study_compound_dosings_headers_get", "parameters": [{"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Compound Dosings Values For Header Study Study Compound Dosings Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compound-dosings/{studycompounddosinguid}/audit-trail": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study compound dosing.", "description": "\nParameters:\n - uid as study-uid (required)\n - study-compound-dosing-uid (required)\n - [NOT YET IMPLEMENTED] study status (optional)\n - [NOT YET IMPLEMENTED] study version (required when study status is locked)\n\nState before:\n - Study and study compound dosing must exist.\n\nBusiness logic:\n - List a specific entry in the audit trail related to the specified study compound dosing for the specified study-uid.\n - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.\n\nReturned data:\n - List of actions and changes related to the specified study compound dosing.\n    ", "operationId": "get_compound_dosing_audit_trail_study__uid__study_compound_dosings__studycompounddosinguid__audit_trail_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study compound dosing.", "required": true, "schema": {"title": "Studycompounddosinguid", "type": "string", "description": "The unique id of the study compound dosing."}, "name": "studycompounddosinguid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Compound Dosing Audit Trail Study  Uid  Study Compound Dosings  Studycompounddosinguid  Audit Trail Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyCompoundDosing"}}}}}, "404": {"description": "Not Found - there exist no selection of the compound dosing for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compound-dosings/select": {"post": {"tags": ["Study Selections"], "summary": "Add a study compound dosing to a study", "operationId": "create_study_compound_dosing_study__uid__study_compound_dosings_select_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyCompoundDosingInput"}], "description": "Related parameters of the compound dosing that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyCompoundDosing"}}}}, "403": {"description": "Forbidden - A study compound dosing already exists for selected study compound and element", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study, study compound or study element is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-compound-dosings/{studycompounddosinguid}": {"delete": {"tags": ["Study Selections"], "summary": "Delete a study compound dosing", "operationId": "delete_compound_dosing_study__uid__study_compound_dosings__studycompounddosinguid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study compound dosing.", "required": true, "schema": {"title": "Studycompounddosinguid", "type": "string", "description": "The unique id of the study compound dosing."}, "name": "studycompounddosinguid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the compound dosing and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "Edit or replace a study compound dosing", "description": "\nState before:\n - Study must exist and be in status draft\n\nBusiness logic:\n - Update specified study-compound-dosing with selection of existing study compound and study element items.\n - A single relationships can be defined for a study compound dosing to each of the following code list terms:\n   - Dose frequency\n - Order number for the study compound cannot be changed by this API endpoint.\n\nState after:\n - related parameters are updated for the study compound dosing.\n - Added new entry in the audit trail for the update of the study-compound-dosing.", "operationId": "update_compound_dosing_study__uid__study_compound_dosings__studycompounddosinguid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study compound dosing.", "required": true, "schema": {"title": "Studycompounddosinguid", "type": "string", "description": "The unique id of the study compound dosing."}, "name": "studycompounddosinguid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyCompoundDosingInput"}], "description": "Related parameters of the selection that shall be updated."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyCompoundDosing"}}}}, "404": {"description": "Not Found - There exist no selection with the given uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-design-cells": {"get": {"tags": ["Study Selections"], "summary": "List all study design cells currently defined for the study", "operationId": "get_all_design_cells_study__uid__study_design_cells_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Design Cells Study  Uid  Study Design Cells Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyDesignCell"}}}}}, "404": {"description": "Not Found - there is no study with the given uid.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Study Selections"], "summary": "Add a study design cell to a study", "operationId": "post_new_design_cell_create_study__uid__study_design_cells_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyDesignCellCreateInput"}], "description": "Related parameters of the design cell that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyDesignCell"}}}}, "403": {"description": "Forbidden - A study design cell already exists for selected study arm and epoch", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study, study arm or study epoch is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-design-cells/{studydesigncelluid}": {"delete": {"tags": ["Study Selections"], "summary": "Delete a study design cell", "operationId": "delete_design_cell_study__uid__study_design_cells__studydesigncelluid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study design cell.", "required": true, "schema": {"title": "Studydesigncelluid", "type": "string", "description": "The unique id of the study design cell."}, "name": "studydesigncelluid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the design cell and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "Update a study design cell", "description": "\n    The StudyDesignCell has the following properties:\n        -StudyArm \n        -StudyBranchArm \n        -StudyEpoch \n        -StudyElement\n        -Transition_rule\n    Patching properties has different dependencies, to patch:\n        -StudyArm\n            -StudyArm has to exists\n            -if the StudyDesignCell already has a StudyBranchArm then the StudyBranchArm has to be set as null on the payload.\n        -StudyBranchArm\n            -StudyBranchArm has to exists\n            -if the StudyDesignCell already has a StudyArm then it will be disconnected from PREVIOUS StudyArm and switched to the NEW StudyBranchArm\n        -StudyElement\n            -StudyElement has to exists\n        -StudyEpoch\n            -StudyEpoch has to exists\n        -Transition_rule\n            -no dependencies, is just a string field\n     ", "operationId": "edit_design_cell_study__uid__study_design_cells__studydesigncelluid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study design cell.", "required": true, "schema": {"title": "Studydesigncelluid", "type": "string", "description": "The unique id of the study design cell."}, "name": "studydesigncelluid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyDesignCellEditInput"}], "description": "Related parameters of the selection that shall be updated."}}}}, "responses": {"204": {"description": "Successful Response"}, "200": {"description": "No content - The study design cell was successfully updated."}, "404": {"description": "Not Found - The study design cell with the specified 'studydesigncelluid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-design-cells/audit-trail/": {"get": {"tags": ["Study Selections"], "summary": "List full audit trail related to definition of all study design cells.", "description": "\nThe following values should be returned for all study design cells:\n- dateTime\n- userInitials\n- action\n- activity\n- order\n    ", "operationId": "get_all_design_cells_audit_trail_study__uid__study_design_cells_audit_trail__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Design Cells Audit Trail Study  Uid  Study Design Cells Audit Trail  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyDesignCellVersion"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-design-cells/{studydesigncelluid}/audit-trail/": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study design cell.", "operationId": "get_specific_schedule_audit_trail_study__uid__study_design_cells__studydesigncelluid__audit_trail__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study design cell.", "required": true, "schema": {"title": "Studydesigncelluid", "type": "string", "description": "The unique id of the study design cell."}, "name": "studydesigncelluid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Specific Schedule Audit Trail Study  Uid  Study Design Cells  Studydesigncelluid  Audit Trail  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyDesignCellVersion"}}}}}, "404": {"description": "Not Found - there exist no selection of the design cell for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-design-cells/batch": {"post": {"tags": ["Study Selections"], "summary": "Batch operations (create, delete) for study design cells", "operationId": "design_cell_batch_operations_study__uid__study_design_cells_batch_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Operations", "type": "array", "items": {"$ref": "#/components/schemas/StudyDesignCellBatchInput"}, "description": "List of operations to perform"}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Design Cell Batch Operations Study  Uid  Study Design Cells Batch Post", "type": "array", "items": {"$ref": "#/components/schemas/StudyDesignCellBatchOutput"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-design-cells/arm/{armUid}": {"get": {"tags": ["Study Selections"], "summary": "List all study desing-cells currently selected for study with provided uid that are connected to an StudyArm with armUid", "description": "\n    State before:\n    - Study must exist.\n     \n    Business logic:\n     - By default (no study status is provided) list all study desing-cells for the study uid in status draft. If the study not exist in status draft then return the study desing-cells for the study in status released. If the study uid only exist as deleted then this is returned.\n     - If a specific study status parameter is provided then return study desing-cell for this study status.\n    - If the locked study status parameter is requested then a study version should also be provided, and then the study desing-cells for the specific locked study version is returned.\n    - Indicate by a boolean variable if the study desing-cell can be updated (if the selected study is in status draft).  \n    - Indicate by a boolean variable if all expected selections have been made for each study desing-cells, or some are missing.\n\n\n    State after:\n    - no change.\n     \n    Possible errors:\n    - Invalid study-uid.\n", "operationId": "get_all_selected_desing_cells_connected_arm_study__uid__study_design_cells_arm__armUid__get", "parameters": [{"required": true, "schema": {"title": "Uid", "type": "string"}, "name": "uid", "in": "path"}, {"required": true, "schema": {"title": "Armuid", "type": "string"}, "name": "armUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Selected Desing Cells Connected Arm Study  Uid  Study Design Cells Arm  Armuid  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyDesignCell"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-design-cells/branch-arm/{branchArmUid}": {"get": {"tags": ["Study Selections"], "summary": "List all study desing-cells currently selected for study with provided\n    uid that are connected to an StudyBranchArm with branchArmUid", "description": "\n    State before:\n    - Study must exist.\n     \n    Business logic:\n     - By default (no study status is provided) list all study desing-cells for the\n     study uid in status draft. If the study not exist in status draft then return\n     the study desing-cells for the study in status released. If the study uid only exist as deleted then this is returned.\n     - If a specific study status parameter is provided then return study desing-cell for this study status.\n    - If the locked study status parameter is requested then a study version should\n    also be provided, and then the study desing-cells for the specific locked study version is returned.\n    - Indicate by a boolean variable if the study desing-cell can be updated (if the selected study is in status draft).  \n    - Indicate by a boolean variable if all expected selections have been made for each study desing-cells, or some are missing.\n\n\n    State after:\n    - no change.\n     \n    Possible errors:\n    - Invalid study-uid.\n", "operationId": "get_all_selected_desing_cells_connected_branch_arm_study__uid__study_design_cells_branch_arm__branchArmUid__get", "parameters": [{"required": true, "schema": {"title": "Uid", "type": "string"}, "name": "uid", "in": "path"}, {"required": true, "schema": {"title": "Brancharmuid", "type": "string"}, "name": "branchArmUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Selected Desing Cells Connected Branch Arm Study  Uid  Study Design Cells Branch Arm  Brancharmuid  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyDesignCell"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-design-cells/study-epochs/{epochUid}": {"get": {"tags": ["Study Selections"], "summary": "List all study desing-cells currently selected for study with provided uid that are connected to an StudyEpoch with epochUid", "description": "\n    State before:\n    - Study must exist.\n     \n    Business logic:\n     - By default (no study status is provided) list all study desing-cells for the study uid in status draft. If the study not exist in status draft then return the study desing-cells for the study in status released. If the study uid only exist as deleted then this is returned.\n     - If a specific study status parameter is provided then return study desing-cell for this study status.\n    - If the locked study status parameter is requested then a study version should also be provided, and then the study desing-cells for the specific locked study version is returned.\n    - Indicate by a boolean variable if the study desing-cell can be updated (if the selected study is in status draft).  \n    - Indicate by a boolean variable if all expected selections have been made for each study desing-cells, or some are missing.\n\n\n    State after:\n    - no change.\n     \n    Possible errors:\n    - Invalid study-uid.\n", "operationId": "get_all_selected_desing_cells_connected_epoch_study__uid__study_design_cells_study_epochs__epochUid__get", "parameters": [{"required": true, "schema": {"title": "Uid", "type": "string"}, "name": "uid", "in": "path"}, {"required": true, "schema": {"title": "Epochuid", "type": "string"}, "name": "epochUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Selected Desing Cells Connected Epoch Study  Uid  Study Design Cells Study Epochs  Epochuid  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyDesignCell"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-epochs": {"get": {"tags": ["Study Selections"], "summary": "List all study epochs currently selected for the study.", "description": "\nState before:\n - Study must exist.\n \nBusiness logic:\n - By default (no study status is provided) list all study epochs for the study uid in status draft. If the study not exist in status draft then return the study epochs for the study in status released. If the study uid only exist as deleted then this is returned.\n - If a specific study status parameter is provided then return study epoch for this study status.\n - If the locked study status parameter is requested then a study version should also be provided, and then the study epochs for the specific locked study version is returned.\n - Indicate by an boolean variable if the study epoch can be updated (if the selected study is in status draft).  \n - Indicate by an boolean variable if all expected selections have been made for each study epochs, or some are missing.\n   - e.g. duration time unit must is expected.\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.", "operationId": "get_all_study__uid__study_epochs_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudyEpoch_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Study Selections"], "summary": "Add a study epoch to a study", "description": "\nState before:\n - Study must exist and study status must be in draft.\n\nBusiness logic:\n - Add a study epoch to a study based on selection of an Epoch CT Term.\n- Update the order value of all other epochs for this study to be consecutive.\n\nState after:\n - Epoch is added as study epoch to the study.\n - Added new entry in the audit trail for the creation of the study-epoch.\n \nPossible errors:\n - Invalid study-uid or Epoch CT Term uid.\n    ", "operationId": "post_new_epoch_create_study__uid__study_epochs_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyEpochCreateInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyEpoch"}}}}, "403": {"description": "Forbidden - There already exists a selection of the epoch", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-epochs/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_study__uid__study_epochs_headers_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Study  Uid  Study Epochs Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-epochs/{studyEpochUid}": {"get": {"tags": ["Study Selections"], "summary": "List all definitions for a specific study epoch", "description": "\nState before:\n - Study and study epoch must exist\n \nBusiness logic:\n - By default (no study status is provided) list all details for specified study epoch for the study uid in status draft. If the study not exist in status draft then return the study epochs for the study in status released. If the study uid only exist as deleted then this is returned.\n - If a specific study status parameter is provided then return study epochs for this study status.\n - If the locked study status parameter is requested then a study version should also be provided, and then the specified study epoch  for the specific locked study version is returned.\n - Indicate by an boolean variable if the study epoch can be updated (if the selected study is in status draft).\n - Indicate by an boolean variable if all expected selections have been made for each study epoch , or some are missing.\n - e.g. epoch level, minimum one timeframe and one unit is expected.\n - Indicate by an boolean variable if the selected epoch is available in a newer version.\n \nState after:\n - no change\n \nPossible errors:\n - Invalid study-uid or studyEpoch Uid.\n    ", "operationId": "get_study_epoch_study__uid__study_epochs__studyEpochUid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study epoch.", "required": true, "schema": {"title": "Studyepochuid", "type": "string", "description": "The unique id of the study epoch."}, "name": "studyEpochUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyEpoch"}}}}, "404": {"description": "Not Found - there exist no epoch for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Delete a study epoch.", "description": "\nState before:\n - Study must exist and study status must be in draft.\n - study-epoch-uid must exist. \n\nBusiness logic:\n - Remove specified study-epoch from the study.\n - Reference to the study-epoch should still exist in the the audit trail.\n- Update the order value of all other epochs for this study to be consecutive.\n\nState after:\n- Study epochis deleted from the study, but still exist as a node in the database with a reference from the audit trail.\n- Added new entry in the audit trail for the deletion of the study-epoch.\n \nPossible errors:\n- Invalid study-uid or studyEpochUid.\n    ", "operationId": "delete_study_epoch_study__uid__study_epochs__studyEpochUid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study epoch.", "required": true, "schema": {"title": "Studyepochuid", "type": "string", "description": "The unique id of the study epoch."}, "name": "studyEpochUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - the study or epoch does not exist.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "Edit a study epoch", "description": "\nState before:\n - Study must exist and study status must be in draft.\n\nBusiness logic:\n - Same logic applies as for selecting or creating an study epoch (see two POST statements for /study-epochs)\n - Update the order value of all other epochs for this study to be consecutive.\n\nState after:\n - Epoch is added as study epoch to the study.\n - This PATCH method can cover cover two parts:\n\n - Added new entry in the audit trail for the update of the study-epoch.\n\nPossible errors:\n - Invalid study-uid or studyEpochUid .\n    ", "operationId": "patch_update_epoch_study__uid__study_epochs__studyEpochUid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study epoch.", "required": true, "schema": {"title": "Studyepochuid", "type": "string", "description": "The unique id of the study epoch."}, "name": "studyEpochUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyEpochEditInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyEpoch"}}}}, "404": {"description": "Not Found - There exist no study or epoch .", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-epochs/{studyEpochUid}/audit-trail/": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study epoch", "description": "\nState before:\n - Study and study epochs must exist.\n\nBusiness logic:\n - List a specific entry in the audit trail related to the specified study epoch for the specified study-uid.\n - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.\n     ", "operationId": "get_study_epoch_audit_trail_study__uid__study_epochs__studyEpochUid__audit_trail__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study epoch.", "required": true, "schema": {"title": "Studyepochuid", "type": "string", "description": "The unique id of the study epoch."}, "name": "studyEpochUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Study Epoch Audit Trail Study  Uid  Study Epochs  Studyepochuid  Audit Trail  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyEpochVersion"}}}}}, "404": {"description": "Not Found - there exist no selection of the visit for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-epoch/audit-trail/": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to all study epochs within the specified study-uid", "description": "\nState before:\n - Study and study epoch must exist.\n\nBusiness logic:\n - List all study epoch audit trail within the specified study-uid.\n - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.\n     ", "operationId": "get_study_epochs_all_audit_trail_study__uid__study_epoch_audit_trail__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Study Epochs All Audit Trail Study  Uid  Study Epoch Audit Trail  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyEpochVersion"}}}}}, "404": {"description": "Not Found - there exist no selection of the provided study.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-epochs/preview": {"post": {"tags": ["Study Selections"], "summary": "Preview a study epoch", "operationId": "post_preview_epoch_study__uid__study_epochs_preview_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyEpochCreateInput"}], "description": "Related parameters of the epoch that shall be created."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyEpoch"}}}}, "404": {"description": "Not Found - Study is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-epochs/{studyEpochUid}/order/{new_order}": {"patch": {"tags": ["Study Selections"], "summary": "Change display order of study epoch", "description": "\nState before:\n - Study must exist and study status must be in draft.\n - studyEpochUid must exist. \n - Old order number must match current order number in database for study epoch.\n\nBusiness logic:\n - Old order number must match existing order number in the database for specified study epoch.\n - New order number must be increased or decreased with one.\n - If order number is decreased with 1, then the old order number must be > 1 and a preceding study epoch must exist (the specified study epoch cannot be the first on the list).\n   - The specified study epoch get the order number set to be the new order number and the preceding study epoch get the order number to be the old order number.\n - If order number is increased with 1, then a following study epoch must exist (the specified study epoch cannot be the last on the list).\n   - The specified study epoch get the order number set to be the new order number and the following study epoch  get the order number to be the old order number.\n\nState after:\n - Order number for specified study epoch is updated to new order number.\n - Note this will change order on either the preceding or following study epoch as well.\n - Added new entry in the audit trail for the re-ordering of the study epoch.\n\nPossible errors:\n - Invalid study-uid, studyEpochUid\n - Old order number do not match current order number in database.\n - New order number not an increase or decrease of 1\n - Decrease order number for the first study epoch on the list\n - Increase order number for the last study epoch on the list\n    ", "operationId": "patch_reorder_study__uid__study_epochs__studyEpochUid__order__new_order__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study epoch.", "required": true, "schema": {"title": "Studyepochuid", "type": "string", "description": "The unique id of the study epoch."}, "name": "studyEpochUid", "in": "path"}, {"required": true, "schema": {"title": "New Order", "type": "integer"}, "name": "new_order", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyEpoch"}}}}, "404": {"description": "Not Found - There exist no selection between the study and epoch to reorder.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/epochs/allowed-configs": {"get": {"tags": ["Study Selections"], "summary": "Returns all allowed config sets", "operationId": "get_all_configs_study_epochs_allowed_configs_get", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Configs Study Epochs Allowed Configs Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyEpochTypes"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/allowed-consecutive-groups": {"get": {"tags": ["Study Selections"], "summary": "Returns all consecutive groups", "operationId": "get_all_consecutive_groups_study__uid__allowed_consecutive_groups_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Consecutive Groups Study  Uid  Allowed Consecutive Groups Get", "type": "array", "items": {"type": "string"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-visits": {"get": {"tags": ["Study Selections"], "summary": "List all study visits currently defined for the study", "description": "\nState before:\n- Study must exist.\n \nBusiness logic:\n - By default (no study status is provided) list all study visits for the study uid in status draft. If the study not exist in status draft then return the study visits for the study in status released. If the study uid only exist as deleted then this is returned.\n - If a specific study status parameter is provided then return study visit for this study status.\n - If the locked study status parameter is requested then a study version should also be provided, and then the study visits for the specific locked study version is returned.\n - Indicate by an boolean variable if the study visit can be updated (if the selected study is in status draft).  \n - Indicate by an boolean variable if all expected selections have been made for each study visits , or some are missing.\n   - e.g. time unit must is expected.\n - Indicate by an boolean variable if a study visit can be re-ordered.\n - Duration time is calculated in the duration time unit specified for the study epoch based on the following rule:\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.\n    ", "operationId": "get_all_study__uid__study_visits_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudyVisit_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Study Selections"], "summary": "Add a study visit to a study", "description": "\n\nState before:\n - Study must exist and study status must be in draft.\n\nBusiness logic:\n - A subset of the visit types are of the type being a time reference (the sponsor defined term exist both in the code list visit type as well as time reference) - only one visit in the study visits can refer to a visit type related to a specific time reference.\n \n - The initial study visit specified for a study must refer to a visit type being a time reference type, it must have this as the time reference as well, and the time value must be set to 0.\n \n - All other study visits, than the initial visit, must either refer to a time reference that exist as a visit type for one of the other study visits for the study; or refer to the time reference for 'previous visit'. [previous visit needs to be selected in up - this probably will not be implemented in 0.1]\n\n - The duration time must be calculated as the duration time at the visit for the reference time + the time value specified for the study visit. [absolute value of time difference from initial reference time visit (e.g. the Baseline visit)\" - to be discussed in point 3]\n \n - The duration time must be returned in the duration time unit specified for the related study epoch. [changed calculated to returned]\n \n - The time value is only valid, if the derived duration time for the study visit is greater than or equal to the duration time for the last study visit in the previous study epoch (given the study visit not is in the first epoch). [depending on a epoch definition, not in v 0.1]\n \n - The time value is only valid, if the derived duration time for the study visit is less than or equal to the duration time for the first study visit in the following study epoch (given the study visit not is in the last epoch). [depending on epoch definition, not in c 0.1)\n ]\n - The study day number is derived as:\n    - Equal to the derived study duration time in days if value is less than 0.\n    - Equal to 1 + the derived study duration time in days if value is greater than or equal to 0.\n    - If the derived study duration time is blank, then the study day number must also be blank.\n    - The derived result for the study day number is rounded: If result is below zero, the result is rounded using ceil function. Otherwise the result is rounded using floor function.\n   \n - The study day label is a text string derived by concatenation of: Day+<space>+[Study day number]\n - The study week number is derived as\n    - Equal to the derived study duration time in weeks if value is less than 0.\n    - Equal to 1 + the derived study duration time in weeks if value is greater than or equal to 0.\n    - If the derived study duration time is blank, then the study week number must also be blank.\n    - The derived result for the study week number is rounded: If result is below zero, the result is rounded using ceil function. Otherwise the result is rounded using floor function.\n - The study week label is a text string derived by concatenation of:  Week+space+[Study week number]\n\n\n - The visit number is derived as an running integer with 1 for the very first visit sorted by chronological order (i.e. 1, 2. 3, 4, etc.). [NOTE: we have to figure out a rule for how we avoid counting sub visits? 1.1, 1.2, 1.3 etc?]\n \n - The unique visit number is derived as an integer with 10 for the very first visit, increasing with +10 for each visit, sorted by chronological order  (i.e. 10, 20. 30, 40, etc.). [NOTE: we have to figure out a rule for how we create unique visit numbers for sub visits?]\n \n - The visit name is a text string derived by concatenation of: Visit+space+[Visit number]+[Visit sub-label] (if available)\n \n - The visit short name is a text string derived by concatenation of: V+[Visit number]+[Visit sub-label] (if available)\n\n\nState after:\n - the visit is added as study visit to the study.\n - Added new entry in the audit trail for the creation of the study-visit .\n - new simple concepts are possibly created based on the result of the \"get or create\" operation.\n \nPossible errors:\n - Invalid study-uid.\n - Invalid timepointuid, visitnameuid, ... etc.\n    ", "operationId": "post_new_visit_create_study__uid__study_visits_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyVisitCreateInput"}], "description": "Related parameters of the visit that shalll be created."}}}}, "responses": {"201": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyVisit"}}}}, "403": {"description": "Forbidden - The settings for visit are invalid", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - Study or visit is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-visits/headers": {"get": {"tags": ["Study Selections"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_study__uid__study_visits_headers_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Study  Uid  Study Visits Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-visits-references": {"get": {"tags": ["Study Selections"], "summary": "Returns all study visit references for study currently selected", "operationId": "get_all_references_study__uid__study_visits_references_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All References Study  Uid  Study Visits References Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyVisit"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-visits/preview": {"post": {"tags": ["Study Selections"], "summary": "Preview a study visit", "operationId": "post_preview_visit_study__uid__study_visits_preview_post", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyVisitCreateInput"}], "description": "Related parameters of the visit that shalll be created."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyVisit"}}}}, "404": {"description": "Not Found - Study is not found with the passed 'uid'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-visits/{studyVisitUid}": {"get": {"tags": ["Study Selections"], "summary": "List all definitions for a specific study visit", "description": "\nState before:\n - Study and study visit must exist\n \nBusiness logic:\n - By default (no study status is provided) list all details for specified study visit for the study uid in status draft. If the study not exist in status draft then return the study visits for the study in status released. If the study uid only exist as deleted then this is returned.\n - If a specific study status parameter is provided then return study visits for this study status.\n - If the locked study status parameter is requested then a study version should also be provided, and then the specified study visit for the specific locked study version is returned.\n - Indicate by an boolean variable if the study visit can be updated (if the selected study is in status draft).\n - Indicate by an boolean variable if all expected selections have been made for each study visit , or some are missing.\n - Indicate by an boolean variable if the selected visit is available in a newer version.\n \nState after:\n - no change\n \nPossible errors:\n - Invalid study-uid or studyVisitUid.\n    ", "operationId": "get_study_visit_study__uid__study_visits__studyVisitUid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study visit.", "required": true, "schema": {"title": "Studyvisituid", "type": "string", "description": "The unique id of the study visit."}, "name": "studyVisitUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyVisit"}}}}, "404": {"description": "Not Found - there exist no visit for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Study Selections"], "summary": "Delete a study visit", "description": "\"\nState before:\n - Study must exist and study status must be in draft.\n - studyVisitUid must exist. \n\nBusiness logic:\n - Remove specified study-visit from the study.\n - Reference to the study-visit should still exist in the the audit trail.\n - Simple concepts that are now unused should continue to be persisted in the database.\n\nState after:\n - Study visit deleted from the study, but still exist as a node in the database with a reference from the audit trail.\n - Added new entry in the audit trail for the deletion of the study-visit .\n \nPossible errors:\n - Invalid study-uid or studyVisitUid.\n    ", "operationId": "delete_study_visit_study__uid__study_visits__studyVisitUid__delete", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study visit.", "required": true, "schema": {"title": "Studyvisituid", "type": "string", "description": "The unique id of the study visit."}, "name": "studyVisitUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The selection was successfully deleted."}, "404": {"description": "Not Found - there exist no selection of the visit and the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Study Selections"], "summary": "Edit a study visit", "description": "\nState before:\n - Study and study visit must exist and study status must be in draft.\n\nBusiness logic:\n - Same logic applies as for selecting or creating an study visit (see POST statements for /study-visits)\n\nState after:\n - Visit is added as study visit to the study.\n - Add new entry in the audit trail for the update of the study-visit .\n\nPossible errors:\n - Invalid study-uid or studyVisitUidDescription .\n    ", "operationId": "patch_update_visit_study__uid__study_visits__studyVisitUid__patch", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study visit.", "required": true, "schema": {"title": "Studyvisituid", "type": "string", "description": "The unique id of the study visit."}, "name": "studyVisitUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Selection", "allOf": [{"$ref": "#/components/schemas/StudyVisitEditInput"}], "description": "Related parameters of the selection that shall be created."}}}}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyVisit"}}}}, "404": {"description": "Not Found - There exist no study or visit.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-visits/{studyVisitUid}/audit-trail/": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of a specific study visit.", "description": "\nState before:\n - Study and study visits must exist.\n\nBusiness logic:\n - List a specific entry in the audit trail related to the specified study visit for the specified study-uid.\n - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.\n     ", "operationId": "get_study_visit_audit_trail_study__uid__study_visits__studyVisitUid__audit_trail__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique id of the study visit.", "required": true, "schema": {"title": "Studyvisituid", "type": "string", "description": "The unique id of the study visit."}, "name": "studyVisitUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Study Visit Audit Trail Study  Uid  Study Visits  Studyvisituid  Audit Trail  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyVisitVersion"}}}}}, "404": {"description": "Not Found - there exist no selection of the study visit for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/study-visit/audit-trail/": {"get": {"tags": ["Study Selections"], "summary": "List audit trail related to definition of all study visits within the specified study-uid.", "description": "\nState before:\n - Study and study visits must exist.\n\nBusiness logic:\n - List all study visit audit trail within the specified study-uid.\n - If the released or a locked version of the study is selected then only entries up to the time of the study release or lock is included.\n\nState after:\n - no change.\n \nPossible errors:\n - Invalid study-uid.\n     ", "operationId": "get_study_visits_all_audit_trail_study__uid__study_visit_audit_trail__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Study Visits All Audit Trail Study  Uid  Study Visit Audit Trail  Get", "type": "array", "items": {"$ref": "#/components/schemas/StudyVisitVersion"}}}}}, "404": {"description": "Not Found - there exist no selection of the study visit for the study provided.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-visits/allowed-visit-types": {"get": {"tags": ["Study Selections"], "summary": "Returns all allowed Visit Types for specified epoch type", "operationId": "get_allowed_visit_types_for_epoch_type_study_study_visits_allowed_visit_types_get", "parameters": [{"description": "The unique uid of the epoch type for which the allowed visit types should be returned", "required": true, "schema": {"title": "Epoch Type Uid", "type": "string", "description": "The unique uid of the epoch type for which the allowed visit types should be returned"}, "name": "epoch_type_uid", "in": "query"}, {"description": "The unique uid of the study", "required": true, "schema": {"title": "Study Uid", "type": "string", "description": "The unique uid of the study"}, "name": "study_uid", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Allowed Visit Types For Epoch Type Study Study Visits Allowed Visit Types Get", "type": "array", "items": {"$ref": "#/components/schemas/AllowedVisitTypesForEpochType"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/study-visits/allowed-time-references": {"get": {"tags": ["Study Selections"], "summary": "Returns all allowed time references for a study visit", "operationId": "get_allowed_time_references_for_given_study_study_study_visits_allowed_time_references_get", "parameters": [{"description": "The unique uid of the study", "required": true, "schema": {"title": "Study Uid", "type": "string", "description": "The unique uid of the study"}, "name": "study_uid", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Allowed Time References For Given Study Study Study Visits Allowed Time References Get", "type": "array", "items": {"$ref": "#/components/schemas/AllowedTimeReferences"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/get-amount-of-visits-in-epoch/{studyEpochUid}": {"get": {"tags": ["Study Selections"], "summary": "Counts amount of visits in a specified study epoch", "description": "\nState before:\n- Study must exist.\n\nBusiness logic:\n - Counts amount of visits in a specified study epoch.\n\nState after:\n - no change.\n\nPossible errors:\n - Invalid studyUid.\n - Invalid studyEpochUid.\n    ", "operationId": "get_amount_of_visits_in_given_epoch_study__uid__get_amount_of_visits_in_epoch__studyEpochUid__get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "The unique uid of the study epoch", "required": true, "schema": {"title": "Studyepochuid", "type": "string", "description": "The unique uid of the study epoch"}, "name": "studyEpochUid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Amount Of Visits In Given Epoch Study  Uid  Get Amount Of Visits In Epoch  Studyepochuid  Get", "type": "integer"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/global-anchor-visit": {"get": {"tags": ["Study Selections"], "summary": "List global anchor visit study visits for selected study referenced by 'uid' ", "description": "\nState before:\n- Study must exist.\n\nBusiness logic:\n - Looks for a study visit that is a global anchor visit.\n\nState after:\n - no change.\n\nPossible errors:\n - Invalid study-uid.\n    ", "operationId": "get_global_anchor_visit_study__uid__global_anchor_visit_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/SimpleStudyVisit"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/study/{uid}/anchor-visits-in-group-of-subvisits": {"get": {"tags": ["Study Selections"], "summary": "List all anchor visits for group of subvisits for selected study referenced by 'uid' ", "description": "\nState before:\n- Study must exist.\n\nBusiness logic:\n - Looks for a study visits that are anchor visits in a group of subvisits.\n\nState after:\n - no change.\n\nPossible errors:\n - Invalid study-uid.\n    ", "operationId": "get_anchor_visits_in_group_of_subvisits_study__uid__anchor_visits_in_group_of_subvisits_get", "parameters": [{"description": "The unique id of the study.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the study."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Anchor Visits In Group Of Subvisits Study  Uid  Anchor Visits In Group Of Subvisits Get", "type": "array", "items": {"$ref": "#/components/schemas/SimpleStudyVisit"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/unit-definitions": {"get": {"tags": ["Unit Definitions"], "summary": "Returns all unit definitions in their latest/newest version.", "description": "Allowed parameters include : filter on fields, sort by field name with sort direction, pagination", "operationId": "get_all_concepts_unit_definitions_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The code submission value of the unit dimension to filter, for instance 'Dose Unit'.", "required": false, "schema": {"title": "Dimension", "type": "string", "description": "The code submission value of the unit dimension to filter, for instance 'Dose Unit'."}, "name": "dimension", "in": "query"}, {"description": "The name of the unit subset to filter, for instance 'Age Unit'.", "required": false, "schema": {"title": "Subset", "type": "string", "description": "The name of the unit subset to filter, for instance 'Age Unit'."}, "name": "subset", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_UnitDefinitionModel_"}}, "text/csv": {"example": "\n\"library\",\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n                    <?xml version=\"1.0\" encoding=\"UTF-8\" ?><root><data type=\"list\"><item type=\"dict\"><uid type=\"str\">e9117175-918f-489e-9a6e-65e0025233a6</uid><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19T11:51:43.000Z</startDate><status type=\"str\">Draft</status><version type=\"str\">0.2</version><changeDescription type=\"str\">Test</changeDescription><userInitials type=\"str\">TODO Initials</userInitials></item></data></root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Unit Definitions"], "summary": "Creates a new unit definition in 'Draft' status.", "description": "This request is only valid if the unit definition\n* belongs to a library that allows creating (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n* The unit definition template will be linked to a library.\n\n", "operationId": "post_concepts_unit_definitions_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Unit Definition Post Input", "allOf": [{"$ref": "#/components/schemas/UnitDefinitionPostInput"}], "description": "The concept that shall be created."}}}}, "responses": {"201": {"description": "Created - The concept was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/UnitDefinitionModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The concept name is not valid.\n- The library does not allow to create concept.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The library with the specified 'libraryName' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/unit-definitions/headers": {"get": {"tags": ["Unit Definitions"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_concepts_unit_definitions_headers_get", "parameters": [{"required": false, "schema": {"title": "Libraryname", "type": "string"}, "name": "libraryName", "in": "query"}, {"description": "The code submission value of the unit dimension to filter, for instance 'Dose Unit'.", "required": false, "schema": {"title": "Dimension", "type": "string", "description": "The code submission value of the unit dimension to filter, for instance 'Dose Unit'."}, "name": "dimension", "in": "query"}, {"description": "The name of the unit subset to filter, for instance 'Age Unit'.", "required": false, "schema": {"title": "Subset", "type": "string", "description": "The name of the unit subset to filter, for instance 'Age Unit'."}, "name": "subset", "in": "query"}, {"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Concepts Unit Definitions Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/unit-definitions/{uid}": {"get": {"tags": ["Unit Definitions"], "summary": "Returns the latest/newest version of a specific Unit definition identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_by_uid_concepts_unit_definitions__uid__get", "parameters": [{"description": "The unique id of unit definition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of unit definition."}, "name": "uid", "in": "path"}, {"description": "If specified, the latest/newest representation of the unit definition at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified, the latest/newest representation of the unit definition at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified, the representation of the unit definition in that status is returned (if existent). This may be particularly useful if the unit definition has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, the representation of the unit definition in that status is returned (if existent). This may be particularly useful if the unit definition has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "If specified, the latest/newest representation of the concept is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ...", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified, the latest/newest representation of the concept is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/UnitDefinitionModel"}}}}, "404": {"description": "Not Found - The unit definition with the specified\n            'uid' (and the specified date/time, version and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Unit Definitions"], "summary": "Deletes the unit definition identified by 'uid'.", "description": "This request is only valid if \n\n* the unit definition is in 'Draft' status and\n* the unit definition has never been in 'Final' status and\n* the unit definition belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_concepts_unit_definitions__uid__delete", "parameters": [{"description": "The unique id of unit definition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of unit definition."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The concept was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The concept is not in draft status.\n- The concept was already in final state or is in use.\n- The library does not allow to delete concept.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An concept with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Unit Definitions"], "summary": "Updates the unit definition identified by 'uid'.", "description": "This request is only valid if the unit definition\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\n", "operationId": "patch_concepts_unit_definitions__uid__patch", "parameters": [{"description": "The unique id of unit definition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of unit definition."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Patch Input", "allOf": [{"$ref": "#/components/schemas/UnitDefinitionPatchInput"}], "description": "The new content of the concept including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/UnitDefinitionModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The unit definition is not in draft status.\n- The library does not allow to edit draft versions.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The concept with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/unit-definitions/{uid}/versions": {"get": {"tags": ["Unit Definitions"], "summary": "Returns the version history of a specific concept identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_versions_concepts_unit_definitions__uid__versions_get", "parameters": [{"description": "The unique id of unit definition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of unit definition."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Concepts Unit Definitions  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/UnitDefinitionModel"}}}, "text/csv": {"example": "\n\"library\";\"uid\";\"name\";\"startDate\";\"endDate\";\"status\";\"version\";\"changeDescription\";\"userInitials\"\n\"Sponsor\";\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\";\"First  [ComparatorIntervention]\";\"2020-10-22T10:19:29+00:00\";;\"Draft\";\"0.1\";\"Initial version\";\"NdSJ\"\n"}, "text/xml": {"example": "\n                    <?xml version=\"1.0\" encoding=\"UTF-8\" ?><root><data type=\"list\"><item type=\"dict\"><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19 11:51:43+00:00</startDate><endDate type=\"str\">None</endDate><status type=\"str\">Draft</status><version type=\"str\">0.2</version><changeDescription type=\"str\">Test</changeDescription><userInitials type=\"str\">TODO Initials</userInitials></item><item type=\"dict\"><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19 11:51:07+00:00</startDate><endDate type=\"str\">2020-11-19 11:51:43+00:00</endDate><status type=\"str\">Draft</status><version type=\"str\">0.1</version><changeDescription type=\"str\">Initial version</changeDescription><userInitials type=\"str\">TODO user initials</userInitials></item></data></root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "404": {"description": "Not Found - The concept with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/unit-definitions/{uid}/new-version": {"post": {"tags": ["Unit Definitions"], "summary": "Creates a new version of the unit definition identified by 'uid'.", "description": "This request is only valid if the unit definition\n* is in 'Final' or 'Retired' status only (so no latest 'Draft' status exists) and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The latest 'Final' or 'Retired' version will remain the same as before.\n* The status of the new version will be automatically set to 'Draft'.\n* The 'version' property of the new version will be automatically set to the version of the latest 'Final' or 'Retired' version increased by +0.1.\n\n", "operationId": "new_version_concepts_unit_definitions__uid__new_version_post", "parameters": [{"description": "The unique id of unit definition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of unit definition."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/UnitDefinitionModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The unit definition is not in final or retired status or has a draft status.\n- The library does not allow to create a new version.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The  concept with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/unit-definitions/{uid}/approve": {"post": {"tags": ["Unit Definitions"], "summary": "Approves the unit definition identified by 'uid'.", "description": "This request is only valid if the unit definition\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_concepts_unit_definitions__uid__approve_post", "parameters": [{"description": "The unique id of unit definition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of unit definition."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/UnitDefinitionModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The unit definition is not in draft status.\n- The library does not allow to approve drafts.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The unit definition with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/unit-definitions/{uid}/inactivate": {"post": {"tags": ["Unit Definitions"], "summary": "Inactivates/deactivates the unit definition identified by 'uid'.", "description": "This request is only valid if the unit definition\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_concepts_unit_definitions__uid__inactivate_post", "parameters": [{"description": "The unique id of unit definition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of unit definition."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/UnitDefinitionModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The unit definition is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The unit definition with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/concepts/unit-definitions/{uid}/reactivate": {"post": {"tags": ["Unit Definitions"], "summary": "Reactivates the unit definition identified by 'uid'.", "description": "This request is only valid if the unit definition\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_concepts_unit_definitions__uid__reactivate_post", "parameters": [{"description": "The unique id of unit definition.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of unit definition."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/UnitDefinitionModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The unit definition is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The concept with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates": {"get": {"tags": ["Parameter templates"], "summary": "Returns all parameter templates in their latest/newest version.", "operationId": "get_parameter_templates_parameter_templates_get", "parameters": [{"description": "If specified, only those parameter templates will be returned that are currently in the specified status. This may be particularly useful if the parameter template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, only those parameter templates will be returned that are currently in the specified status. This may be particularly useful if the parameter template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameter Templates Parameter Templates Get", "type": "array", "items": {"$ref": "#/components/schemas/ComplexParameterTemplate"}}}, "text/csv": {"example": "\n\"library\",\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"Sponsor\",\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n                    <?xml version=\"1.0\" encoding=\"UTF-8\" ?><root><data type=\"list\"><item type=\"dict\"><uid type=\"str\">e9117175-918f-489e-9a6e-65e0025233a6</uid><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19T11:51:43.000Z</startDate><status type=\"str\">Draft</status><version type=\"str\">0.2</version><changeDescription type=\"str\">Test</changeDescription><userInitials type=\"str\">TODO Initials</userInitials></item></data></root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["Parameter templates"], "summary": "Creates a new parameter template in 'Draft' status.", "description": "This request is only valid if the parameter template\n* belongs to a library that allows creating (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n* The parameter template will be linked to a library.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an parameter template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an parameter is created out of the complex-parameter template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe parameter template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same parameter template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [ComplexParameter].'\n\n'Intervention', 'Activity' and 'ComplexParameter' are parameters.", "operationId": "create_parameter_template_parameter_templates_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Parameter Template", "allOf": [{"$ref": "#/components/schemas/ComplexParameterTemplateCreateInput"}], "description": "The parameter template that shall be created."}}}}, "responses": {"201": {"description": "Created - The parameter template was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ComplexParameterTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The parameter template name is not valid.\n- The library does not allow to create parameter templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The library with the specified 'libraryName' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates/{uid}": {"get": {"tags": ["Parameter templates"], "summary": "Returns the latest/newest version of a specific parameter template identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_parameter_template_parameter_templates__uid__get", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"description": "If specified, the latest/newest representation of the parameter template at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified, the latest/newest representation of the parameter template at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified, the representation of the parameter template in that status is returned (if existent). This may be particularly useful if the parameter template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, the representation of the parameter template in that status is returned (if existent). This may be particularly useful if the parameter template has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "If specified, the latest/newest representation of the parameter template in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ...", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified, the latest/newest representation of the parameter template in that version is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "query"}, {"description": "if specified counts data will be returned along object", "required": false, "schema": {"title": "Return Instantiation Counts", "type": "boolean", "description": "if specified counts data will be returned along object"}, "name": "return_instantiation_counts", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ComplexParameterTemplateWithCount"}}}}, "404": {"description": "Not Found - The parameter template with the specified 'uid' (and the specified date/time and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["Parameter templates"], "summary": "Deletes the parameter template identified by 'uid'.", "description": "This request is only valid if \n\n* the parameter template is in 'Draft' status and\n* the parameter template has never been in 'Final' status and\n* the parameter template has no references to any complex-parameters and\n* the parameter template belongs to a library that allows deleting (the 'isEditable' property of the library needs to be true).", "operationId": "delete_parameter_template_parameter_templates__uid__delete", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The parameter template was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The parameter template is not in draft status.\n- The parameter template was already in final state or is in use.\n- The library does not allow to delete parameter templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An parameter template with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["Parameter templates"], "summary": "Updates the parameter template identified by 'uid'.", "description": "This request is only valid if the parameter template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\nParameters in the 'name' property can only be changed if the parameter template has never been approved.\nOnce the parameter template has been approved, only the surrounding text (excluding the parameters) can be changed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an parameter template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an parameter is created out of the complex-parameter template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe parameter template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same parameter template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [ComplexParameter].'\n\n'Intervention', 'Activity' and 'ComplexParameter' are parameters.", "operationId": "edit_parameter_templates__uid__patch", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Parameter Template", "allOf": [{"$ref": "#/components/schemas/ComplexParameterTemplateEditInput"}], "description": "The new content of the parameter template including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ComplexParameterTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The parameter template is not in draft status.\n- The parameter template name is not valid.\n- The library does not allow to edit draft versions.\n- The change of parameters of previously approved parameter templates.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The parameter template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates/{uid}/versions": {"get": {"tags": ["Parameter templates"], "summary": "Returns the version history of a specific parameter template identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_parameter_template_versions_parameter_templates__uid__versions_get", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameter Template Versions Parameter Templates  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/ComplexParameterTemplateVersion"}}}, "text/csv": {"example": "\n\"library\";\"uid\";\"name\";\"startDate\";\"endDate\";\"status\";\"version\";\"changeDescription\";\"userInitials\"\n\"Sponsor\";\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\";\"First  [ComparatorIntervention]\";\"2020-10-22T10:19:29+00:00\";;\"Draft\";\"0.1\";\"Initial version\";\"NdSJ\"\n"}, "text/xml": {"example": "\n                    <?xml version=\"1.0\" encoding=\"UTF-8\" ?><root><data type=\"list\"><item type=\"dict\"><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19 11:51:43+00:00</startDate><endDate type=\"str\">None</endDate><status type=\"str\">Draft</status><version type=\"str\">0.2</version><changeDescription type=\"str\">Test</changeDescription><userInitials type=\"str\">TODO Initials</userInitials></item><item type=\"dict\"><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19 11:51:07+00:00</startDate><endDate type=\"str\">2020-11-19 11:51:43+00:00</endDate><status type=\"str\">Draft</status><version type=\"str\">0.1</version><changeDescription type=\"str\">Initial version</changeDescription><userInitials type=\"str\">TODO user initials</userInitials></item></data></root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "404": {"description": "Not Found - The parameter template with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates/{uid}/versions/{version}": {"get": {"tags": ["Parameter templates"], "summary": "Returns a specific version of a specific parameter template identified by 'uid' and 'version'.", "description": "**Multiple versions**:\n\nTechnically, there can be multiple versions of the parameter template with the same version number. This is due to the fact, that the version number remains the same when inactivating or reactivating an parameter template (switching between 'Final' and 'Retired' status). \n\nIn that case the latest/newest representation is returned.", "operationId": "get_parameter_template_version_parameter_templates__uid__versions__version__get", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"description": "A specific version number of the parameter template. The version number is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits.\nE.g. '0.1', '0.2', '1.0', ...", "required": true, "schema": {"title": "Version", "type": "string", "description": "A specific version number of the parameter template. The version number is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits.\nE.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ComplexParameterTemplate"}}}}, "404": {"description": "Not Found - The parameter template with the specified 'uid' and 'version' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates/{uid}/new-version": {"post": {"tags": ["Parameter templates"], "summary": "Creates a new version of the parameter template identified by 'uid'.", "description": "This request is only valid if the parameter template\n* is in 'Final' or 'Retired' status only (so no latest 'Draft' status exists) and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The latest 'Final' or 'Retired' version will remain the same as before.\n* The status of the new version will be automatically set to 'Draft'.\n* The 'version' property of the new version will be automatically set to the version of the latest 'Final' or 'Retired' version increased by +0.1.\n\nParameters in the 'name' property cannot be changed with this request.\nOnly the surrounding text (excluding the parameters) can be changed.\n", "operationId": "create_new_version_parameter_templates__uid__new_version_post", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Parameter Template", "allOf": [{"$ref": "#/components/schemas/ComplexParameterTemplateEditInput"}], "description": "The content of the parameter template for the new 'Draft' version including the change description."}}}}, "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ComplexParameterTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The parameter template is not in final or retired status or has a draft status.\n- The parameter template name is not valid.\n- The library does not allow to create a new version.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The parameter template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates/{uid}/approve": {"post": {"tags": ["Parameter templates"], "summary": "Approves the parameter template identified by 'uid'.", "description": "This request is only valid if the parameter template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\nIf parameter template has any related objects status will not be updated but item will be extended with \nrelated item counts.\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_parameter_templates__uid__approve_post", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"required": false, "schema": {"title": "Cascade", "type": "boolean", "default": false}, "name": "cascade", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ComplexParameterTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The parameter template is not in draft status.\n- The library does not allow to approve drafts.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The parameter template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "409": {"description": "Conflict - there are parameters created from template and cascade is false", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates/{uid}/approve_cascading": {"post": {"tags": ["Parameter templates"], "summary": "Approves the parameter template identified by 'uid'. Updates all related items", "description": "This request is only valid if the parameter template\n* is in 'Draft' status and\n* belongs to a library that allows editing (the 'isEditable' property of the library needs to be true).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_cascading_parameter_templates__uid__approve_cascading_post", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ComplexParameterTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The parameter template is not in draft status.\n- The library does not allow to approve drafts.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The parameter template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates/{uid}/inactivate": {"post": {"tags": ["Parameter templates"], "summary": "Inactivates/deactivates the parameter template identified by 'uid'.", "description": "This request is only valid if the parameter template\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_parameter_templates__uid__inactivate_post", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ComplexParameterTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The parameter template is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The parameter template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates/{uid}/reactivate": {"post": {"tags": ["Parameter templates"], "summary": "Reactivates the parameter template identified by 'uid'.", "description": "This request is only valid if the parameter template\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_parameter_templates__uid__reactivate_post", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ComplexParameterTemplate"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The parameter template is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The parameter template with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates/{uid}/parameters": {"get": {"tags": ["Parameter templates"], "summary": "Returns all parameters used in the parameter template identified by 'uid'. Includes the available values per parameter.", "description": "The returned parameters are ordered\n0. as they occur in the parameter template\n\nPer parameter, the parameter.values are ordered by\n0. value.name ascending\n\nNote that parameters may be used multiple times in templates.\nIn that case, the same parameter (with the same values) is included multiple times in the response.\n    ", "operationId": "get_parameters_parameter_templates__uid__parameters_get", "parameters": [{"description": "The unique id of the parameter template.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Parameters Parameter Templates  Uid  Parameters Get", "type": "array", "items": {"$ref": "#/components/schemas/ComplexTemplateParameter"}}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/parameter-templates/pre-validate": {"post": {"tags": ["Parameter templates"], "summary": "Validates the content of an parameter template without actually processing it.", "description": "Be aware that - even if this request is accepted - there is no guarantee that\na following request to e.g. *[POST] /parameter-templates* or *[PATCH] /complex-parameter-templates/{uid}*\nwith the same content will succeed.\n\n**Parameters in the 'name' property**:\n\nThe 'name' of an parameter template may contain parameters, that can - and usually will - be replaced with\nconcrete values once an parameter is created out of the complex-parameter template.\n\nParameters are referenced by simple strings in square brackets [] that match existing parameters defined in the MDR repository.\n\nSee the *[GET] /parameter-templates/* endpoint for available values.\n\nThe parameter template will be linked to those parameters defined in the 'name' property.\n\nYou may use an arbitrary number of parameters and you may use the same parameter multiple times within the same parameter template 'name'.\n\n*Example*:\n\nname='MORE TESTING of the superiority in the efficacy of [Intervention] with [Activity] and [Activity] in [ComplexParameter].'\n\n'Intervention', 'Activity' and 'ComplexParameter' are parameters.", "operationId": "pre_validate_parameter_templates_pre_validate_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Parameter Template", "allOf": [{"$ref": "#/components/schemas/ComplexParameterTemplateNameInput"}], "description": "The content of the parameter template that shall be validated."}}}}, "responses": {"202": {"description": "Accepted. The content is valid and may be submitted in another request.", "content": {"application/json": {"schema": {}}}}, "403": {"description": "Forbidden. The content is invalid - Reasons include e.g.: \n- The syntax of the 'name' is not valid.\n- One of the parameters wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/metadata": {"get": {"tags": ["Listing metadata"], "summary": "Metadata for datasets", "operationId": "get_metadata_listings_metadata_get", "parameters": [{"description": "Optional parameter to specify which legacy dataset(s) to get metadata for. Multiple datasets are separated by commas", "required": false, "schema": {"title": "Dataset Name", "type": "string", "description": "Optional parameter to specify which legacy dataset(s) to get metadata for. Multiple datasets are separated by commas"}, "name": "dataset_name", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_MetaData_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/metadata/headers": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_values_for_header_listings_metadata_headers_get", "parameters": [{"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Values For Header Listings Metadata Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/libraries/all/gcmd/topic-cd-def": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "List library metadata for Activities in the legacy format for CDW-MMA General Clinical Metadata", "operationId": "get_all_activities_report_listings_libraries_all_gcmd_topic_cd_def_get", "parameters": [{"description": "Optional parameter to specify the retrieve the status of the MDR at a specific timepoint, ISO Format with timezone, compatible with Neo4j e.g. 2021-01-01T09:00:00Z", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "Optional parameter to specify the retrieve the status of the MDR at a specific timepoint, ISO Format with timezone, compatible with Neo4j e.g. 2021-01-01T09:00:00Z", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_TopicCdDef_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/libraries/all/gcmd/topic-cd-def/headers": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_topic_cd_def_values_for_header_listings_libraries_all_gcmd_topic_cd_def_headers_get", "parameters": [{"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Topic Cd Def Values For Header Listings Libraries All Gcmd Topic Cd Def Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/libraries/all/gcmd/cdisc_ct_ver": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "CDW-MMA legacy dataset cdisc_ct_ver", "operationId": "get_cdisc_ct_ver_data_listings_libraries_all_gcmd_cdisc_ct_ver_get", "parameters": [{"description": "If specified, only codelists from given catalogue are returned. Multiple catalogues are separated by commas e.g. ADAM CT, SDTM CT", "required": false, "schema": {"title": "Cataloguename", "type": "string", "description": "If specified, only codelists from given catalogue are returned. Multiple catalogues are separated by commas e.g. ADAM CT, SDTM CT"}, "name": "cataloguename", "in": "query"}, {"description": "If specified, only codelists from packages with effective date after this date are returned.Date must be in ISO format e.g. 2021-01-01", "required": false, "schema": {"title": "Afterspecifieddate", "type": "string", "description": "If specified, only codelists from packages with effective date after this date are returned.Date must be in ISO format e.g. 2021-01-01"}, "name": "afterSpecifiedDate", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CDISCCTVer_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/libraries/all/gcmd/cdisc_ct_ver/headers": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_cdisc_ct_ver_values_for_header_listings_libraries_all_gcmd_cdisc_ct_ver_headers_get", "parameters": [{"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Cdisc Ct Ver Values For Header Listings Libraries All Gcmd Cdisc Ct Ver Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/libraries/all/gcmd/cdisc_ct_pkg": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "CDW-MMA legacy dataset cdisc_ct_pkg", "operationId": "get_cdisc_ct_pkg_data_listings_libraries_all_gcmd_cdisc_ct_pkg_get", "parameters": [{"description": "If specified, only codelists from given catalogue are returned. Multiple catalogues are separated by commas e.g. ADAM CT, SDTM CT", "required": false, "schema": {"title": "Cataloguename", "type": "string", "description": "If specified, only codelists from given catalogue are returned. Multiple catalogues are separated by commas e.g. ADAM CT, SDTM CT"}, "name": "cataloguename", "in": "query"}, {"description": "If specified, only codelists from packages with effective date after this date are returned.Date must be in ISO format e.g. 2021-01-01", "required": false, "schema": {"title": "Afterspecifieddate", "type": "string", "description": "If specified, only codelists from packages with effective date after this date are returned.Date must be in ISO format e.g. 2021-01-01"}, "name": "afterSpecifiedDate", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CDISCCTPkg_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/libraries/all/gcmd/cdisc_ct_pkg/headers": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_cdisc_ct_pkg_values_for_header_listings_libraries_all_gcmd_cdisc_ct_pkg_headers_get", "parameters": [{"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Cdisc Ct Pkg Values For Header Listings Libraries All Gcmd Cdisc Ct Pkg Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/libraries/all/gcmd/cdisc_ct_list": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "CDW-MMA legacy dataset cdisc_ct_list", "operationId": "get_cdisc_ct_list_data_listings_libraries_all_gcmd_cdisc_ct_list_get", "parameters": [{"description": "If specified, only codelists from given catalogue are returned. Multiple catalogues are separated by commas e.g. ADAM CT, SDTM CT", "required": false, "schema": {"title": "Cataloguename", "type": "string", "description": "If specified, only codelists from given catalogue are returned. Multiple catalogues are separated by commas e.g. ADAM CT, SDTM CT"}, "name": "cataloguename", "in": "query"}, {"description": "If specified, only codelists from given package are returned.Multiple packages are separated by commas e.g. SDTM CT 2021-06-25, SDTM CT 2021-09-24", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only codelists from given package are returned.Multiple packages are separated by commas e.g. SDTM CT 2021-06-25, SDTM CT 2021-09-24"}, "name": "package", "in": "query"}, {"description": "If specified, only codelists from packages with effective date after this date are returned.Date must be in ISO format e.g. 2021-01-01", "required": false, "schema": {"title": "Afterspecifieddate", "type": "string", "description": "If specified, only codelists from packages with effective date after this date are returned.Date must be in ISO format e.g. 2021-01-01"}, "name": "afterSpecifiedDate", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CDISCCTList_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/libraries/all/gcmd/cdisc_ct_list/headers": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_cdisc_ct_list_values_for_header_listings_libraries_all_gcmd_cdisc_ct_list_headers_get", "parameters": [{"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Cdisc Ct List Values For Header Listings Libraries All Gcmd Cdisc Ct List Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/libraries/all/gcmd/cdisc_ct_val": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "CDW-MMA legacy dataset cdisc_ct_val", "operationId": "get_cdisc_ct_val_data_listings_libraries_all_gcmd_cdisc_ct_val_get", "parameters": [{"description": "If specified, only codelist values from given catalogue are returned. Multiple catalogues are separated by commas e.g. ADAM CT, SDTM CT", "required": false, "schema": {"title": "Cataloguename", "type": "string", "description": "If specified, only codelist values from given catalogue are returned. Multiple catalogues are separated by commas e.g. ADAM CT, SDTM CT"}, "name": "cataloguename", "in": "query"}, {"description": "If specified, only codelist values from given package are returned.Multiple packages are separated by commas e.g. SDTM CT 2021-06-25, SDTM CT 2021-09-24", "required": false, "schema": {"title": "Package", "type": "string", "description": "If specified, only codelist values from given package are returned.Multiple packages are separated by commas e.g. SDTM CT 2021-06-25, SDTM CT 2021-09-24"}, "name": "package", "in": "query"}, {"description": "If specified, only codelist values from packages with effective date after this date are returned.Date must be in ISO format e.g. 2021-01-01", "required": false, "schema": {"title": "Afterspecifieddate", "type": "string", "description": "If specified, only codelist values from packages with effective date after this date are returned.Date must be in ISO format e.g. 2021-01-01"}, "name": "afterSpecifiedDate", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_CDISCCTVal_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/libraries/all/gcmd/cdisc_ct_val/headers": {"get": {"tags": ["Listing Legacy CDW MMA"], "summary": "Returns possible values from the database for a given header", "description": "Allowed parameters include : field name for which to get possible\n    values, search string to provide filtering for the field name, additional filters to apply on other fields", "operationId": "get_distinct_cdisc_ct_val_values_for_header_listings_libraries_all_gcmd_cdisc_ct_val_headers_get", "parameters": [{"description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified", "required": true, "schema": {"title": "Fieldname", "type": "string", "description": "The field name for which to lookup possible values in the database.\n\nFunctionality: searches for possible values (aka 'headers') of this field in the database.Errors: invalid field name specified"}, "name": "fieldName", "in": "query"}, {"description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "required": false, "schema": {"title": "Searchstring", "type": "string", "description": "Optionally, a (part of the) text for a given field.\nThe query result will be values of the field that contain the provided search string.", "default": ""}, "name": "searchString", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, the number of results to return. Default = 10.", "required": false, "schema": {"title": "Resultcount", "type": "integer", "description": "Optionally, the number of results to return. Default = 10.", "default": 10}, "name": "resultCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Distinct Cdisc Ct Val Values For Header Listings Libraries All Gcmd Cdisc Ct Val Headers Get", "type": "array", "items": {}}}}}, "404": {"description": "Not Found - Invalid field name specified", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/studies/all/SDTM/TV/{study_uid}": {"get": {"tags": ["SDTM study design listings"], "summary": "SDTM TV domain listing", "operationId": "get_tv_listings_studies_all_SDTM_TV__study_uid__get", "parameters": [{"description": "Return study visit data of a given study in SDTM TV domain format.", "required": true, "schema": {"title": "Study Uid", "type": "string", "description": "Return study visit data of a given study in SDTM TV domain format."}, "name": "study_uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudyVisitListing_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/studies/all/SDTM/TA/{study_uid}": {"get": {"tags": ["SDTM study design listings"], "summary": "SDTM TA domain listing", "operationId": "get_ta_listings_studies_all_SDTM_TA__study_uid__get", "parameters": [{"description": "Return study arm data of a given study number in SDTM TA domain format.", "required": true, "schema": {"title": "Study Uid", "type": "string", "description": "Return study arm data of a given study number in SDTM TA domain format."}, "name": "study_uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudyArmListing_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/studies/all/SDTM/TI/{study_uid}": {"get": {"tags": ["SDTM study design listings"], "summary": "SDTM TI domain listing", "operationId": "get_ti_listings_studies_all_SDTM_TI__study_uid__get", "parameters": [{"description": "Return study criterion data of a given study in SDTM TI domain format.", "required": true, "schema": {"title": "Study Uid", "type": "string", "description": "Return study criterion data of a given study in SDTM TI domain format."}, "name": "study_uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudyCriterionListing_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/studies/all/SDTM/TS/{study_uid}": {"get": {"tags": ["SDTM study design listings"], "summary": "SDTM TS domain listing", "operationId": "get_ts_listings_studies_all_SDTM_TS__study_uid__get", "parameters": [{"description": "Return study summary data of a given study in SDTM TS domain format.", "required": true, "schema": {"title": "Study Uid", "type": "string", "description": "Return study summary data of a given study in SDTM TS domain format."}, "name": "study_uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudySummaryListing_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/studies/all/SDTM/TE/{study_uid}": {"get": {"tags": ["SDTM study design listings"], "summary": "SDTM TE domain listing", "operationId": "get_te_listings_studies_all_SDTM_TE__study_uid__get", "parameters": [{"description": "Return study element data of a given study number in SDTM TE domain format.", "required": true, "schema": {"title": "Study Uid", "type": "string", "description": "Return study element data of a given study number in SDTM TE domain format."}, "name": "study_uid", "in": "path"}, {"description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "required": false, "schema": {"title": "Sortby", "type": "string", "description": "Optionally, a dictionary of fieldNames and isAscending boolean.\n\nDefault: {} (no sorting)\n\nFunctionality: sorts the results. First by first key with direction indicated by value, then second key, etc...\n\nExample: {\"topicCode\": true, \"name\": false}", "format": "json-string"}, "name": "sortBy", "in": "query"}, {"description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "required": false, "schema": {"title": "Pagenumber", "minimum": 1.0, "type": "integer", "description": "Optionally, the page number of the results to display.\n\nFunctionality : provided together with pageSize, selects a page to retrieve for paginated results.Errors: pageSize not provided, pageNumber must be equal or greater than 1.", "default": 1}, "name": "pageNumber", "in": "query"}, {"description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "required": false, "schema": {"title": "Pagesize", "type": "integer", "description": "Optionally, the number of results to display per page.\n\nDefault: 0 (all data)\n\nFunctionality: provided together with pageNumber, selects the number of results per page.\n\nErrors: pageNumber not provided.", "default": 0}, "name": "pageSize", "in": "query"}, {"description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "required": false, "schema": {"title": "Filters", "type": "string", "description": "Optionally, a dictionary of fieldNames and searchStrings with a choice of operators.\n\nDefault: {} (no filtering)\n\nFunctionality: filters the return values based on the provided search strings and operators.\n\nThe expected format is the following :\n    {\"labelName\":{\"v\":[list of values to filter against], \"op\":\"comparison operator\"}, \"otherLabelName\":{...}}\n\nIf a list of values is provided for a given labelName, it will execute an OR on these values.\n\nSupported comparison operators are the following : eq (default, =), ne (not equals), co (string contains), ge (greater or equal to),\n    gt (greater than), le (less or equal to), lt (less than), bw (between - exactly two values are required).\n\nNote that this is not just for string filtering. For example, this works as filter : {\"isGlobalStandard\": {\"v\": [false]}}\n\nWildcard filtering is also supported. To do this, provide * as labelName, with\n    the same structure for values and operator : {\"*\":{\"v\":[\"searchString\"]}}\n\nWildcard only supports searching strings, on labels of type string ; with a contains operator (set as default in this case).\n\nFinally, you can filter on items that have an empty value for a field. To achieve this, just set the \"v\" list to the empty array [].\n\n", "format": "json-string"}, "example": "{\"name\":{ \"v\": [\"Jimbo\", \"Jumbo\"], \"op\": \"co\" },\n\"startDate\": {\"v\": [\"2021-04-01T12:00:00+00.000\"], \"op\": \"ge\"}, \"*\":{ \"v\": [\"wildcardSearch\"], \"op\": \"co\" }}", "name": "filters", "in": "query"}, {"description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "required": false, "schema": {"title": "Operator", "type": "string", "description": "Optionally, if the filter must be done on several fields, the and/or operator to use.\n\nDefault: and (all field names have to match their filter).\n\nFunctionality: and/or apply to all fields. 'and' will require filters to match, 'or' will require any filters to match.\n\n", "default": "and"}, "name": "operator", "in": "query"}, {"description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "required": false, "schema": {"title": "Totalcount", "type": "boolean", "description": "Optionally, a boolean.\n\nFunctionality: retrieve a total count of the number of returned elements in the context of paginated results.\n\n", "default": false}, "name": "totalCount", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CustomPage_StudyElementListing_"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/studies/listing/{study_number}/study-title": {"get": {"tags": ["study design listings"], "summary": "Retrieve study title from a given study number", "operationId": "get_study_title_listings_studies_listing__study_number__study_title_get", "parameters": [{"description": "Return study title for specific study number", "required": true, "schema": {"title": "Study Number", "type": "integer", "description": "Return study title for specific study number"}, "name": "study_number", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyDescriptionJsonModel"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - No study with the specified 'study_number'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/studies/listing/{study_number}/registry-identifiers": {"get": {"tags": ["study design listings"], "summary": "Retrieve study registry identifiers from a given study number", "operationId": "get_study_registry_identifiers_listings_studies_listing__study_number__registry_identifiers_get", "parameters": [{"description": "Return study registry identifiers for specific study number", "required": true, "schema": {"title": "Study Number", "type": "integer", "description": "Return study registry identifiers for specific study number"}, "name": "study_number", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/RegistryIdentifiersListingModel"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - No study with the specified 'study_number'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/studies/listing/{study_number}/study-type": {"get": {"tags": ["study design listings"], "summary": "Retrieve study type from a given study number", "operationId": "get_study_type_listings_studies_listing__study_number__study_type_get", "parameters": [{"description": "Return study type for specific study number", "required": true, "schema": {"title": "Study Number", "type": "integer", "description": "Return study type for specific study number"}, "name": "study_number", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyTypeListingModel"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - No study with the specified 'study_number'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/listings/studies/listing/{study_number}/study-population": {"get": {"tags": ["study design listings"], "summary": "Retrieve study population from a given study number", "operationId": "get_study_population_listings_studies_listing__study_number__study_population_get", "parameters": [{"description": "Return study population for specific study number", "required": true, "schema": {"title": "Study Number", "type": "integer", "description": "Return study population for specific study number"}, "name": "study_number", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/StudyPopulationListingModel"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - No study with the specified 'study_number'.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/configurations": {"get": {"tags": ["configuration", "Study Fields", "Field definition"], "summary": "Returns all configurations in their latest/newest version.", "operationId": "get_all_configurations_get", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get All Configurations Get", "type": "array", "items": {"$ref": "#/components/schemas/CTConfigModel"}}}, "text/csv": {"example": "\n\"uid\",\"name\",\"startDate\",\"endDate\",\"status\",\"version\",\"changeDescription\",\"userInitials\"\n\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\",\"First  [ComparatorIntervention]\",\"2020-10-22T10:19:29+00:00\",,\"Draft\",\"0.1\",\"Initial version\",\"NdSJ\"\n"}, "text/xml": {"example": "\n                    <?xml version=\"1.0\" encoding=\"UTF-8\" ?><root><data type=\"list\"><item type=\"dict\"><uid type=\"str\">e9117175-918f-489e-9a6e-65e0025233a6</uid><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19T11:51:43.000Z</startDate><status type=\"str\">Draft</status><version type=\"str\">0.2</version><changeDescription type=\"str\">Test</changeDescription><userInitials type=\"str\">TODO Initials</userInitials></item></data></root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["configuration", "Study Fields", "Field definition"], "summary": "Creates a new configuration in 'Draft' status.", "description": "\n\nIf the request succeeds:\n* The status will be automatically set to 'Draft'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be set to '0.1'.\n\n", "operationId": "post_configurations_post", "parameters": [{"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Post Input", "allOf": [{"$ref": "#/components/schemas/CTConfigPostInput"}], "description": "The configuration that shall be created."}}}}, "responses": {"201": {"description": "Created - The configuration was successfully created.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTConfigModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The configuration name is not valid.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/configurations/{uid}": {"get": {"tags": ["configuration", "Study Fields", "Field definition"], "summary": "Returns the latest/newest version of a specific configuration identified by 'uid'.", "description": "If multiple request query parameters are used, then they need to\n    match all at the same time (they are combined with the AND operation).", "operationId": "get_by_uid_configurations__uid__get", "parameters": [{"description": "The unique id of configuration.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of configuration."}, "name": "uid", "in": "path"}, {"description": "If specified, the latest/newest representation of the configuration at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "required": false, "schema": {"title": "Atspecifieddatetime", "type": "string", "description": "If specified, the latest/newest representation of the configuration at this point in time is returned.\nThe point in time needs to be specified in ISO 8601 format including the timezone, e.g.: '2020-10-31T16:00:00+02:00' for October 31, 2020 at 4pm in UTC+2 timezone. If the timezone is ommitted, UTC\u00b10 is assumed.", "format": "date-time"}, "name": "atSpecifiedDateTime", "in": "query"}, {"description": "If specified, the representation of the configuration in that status is returned (if existent). This may be particularly useful if the configuration has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'.", "required": false, "schema": {"title": "Status", "type": "string", "description": "If specified, the representation of the configuration in that status is returned (if existent). This may be particularly useful if the configuration has a) a 'Draft' and a 'Final' status or b) a 'Draft' and a 'Retired' status at the same time and you are interested in the 'Final' or 'Retired' status.\nValid values are: 'Final', 'Draft' or 'Retired'."}, "name": "status", "in": "query"}, {"description": "If specified, the latest/newest representation of the configuration is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ...", "required": false, "schema": {"title": "Version", "type": "string", "description": "If specified, the latest/newest representation of the configuration is returned. Only exact matches are considered. The version is specified in the following format: \\<major\\>.\\<minor\\> where \\<major\\> and \\<minor\\> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "name": "version", "in": "query"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTConfigModel"}}}}, "404": {"description": "Not Found - The configuration with the specified 'uid'\n            (and the specified date/time, version and/or status) wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["configuration", "Study Fields", "Field definition"], "summary": "Deletes the configuration identified by 'uid'.", "description": "This request is only valid if \n\n* the configuration is in 'Draft' status and\n* the configuration has never been in 'Final' status.\n", "operationId": "delete_configurations__uid__delete", "parameters": [{"description": "The unique id of configuration.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of configuration."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"204": {"description": "No Content - The configuration was successfully deleted."}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The configuration is not in draft status.\n- The configuration was already in final state or is in use.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - An configuration with the specified uid could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "patch": {"tags": ["configuration", "Study Fields", "Field definition"], "summary": "Updates the configuration identified by 'uid'.", "description": "This request is only valid if the configuration\n* is in 'Draft' status and\n\nIf the request succeeds:\n* The 'version' property will be increased automatically by +0.1.\n* The status will remain in 'Draft'.\n\n", "operationId": "patch_configurations__uid__patch", "parameters": [{"description": "The unique id of configuration.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of configuration."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Patch Input", "allOf": [{"$ref": "#/components/schemas/CTConfigPatchInput"}], "description": "The new content of the configuration including the change description."}}}}, "responses": {"200": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTConfigModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The configuration is not in draft status.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The configuration with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/configurations/{uid}/versions": {"get": {"tags": ["configuration", "Study Fields", "Field definition"], "summary": "Returns the version history of a specific configuration identified by 'uid'.", "description": "The returned versions are ordered by\n0. startDate descending (newest entries first)", "operationId": "get_versions_configurations__uid__versions_get", "parameters": [{"description": "The unique id of configuration.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of configuration."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"title": "Response Get Versions Configurations  Uid  Versions Get", "type": "array", "items": {"$ref": "#/components/schemas/CTConfigModel"}}}, "text/csv": {"example": "\n\"uid\";\"name\";\"startDate\";\"endDate\";\"status\";\"version\";\"changeDescription\";\"userInitials\"\n\"826d80a7-0b6a-419d-8ef1-80aa241d7ac7\";\"First  [ComparatorIntervention]\";\"2020-10-22T10:19:29+00:00\";;\"Draft\";\"0.1\";\"Initial version\";\"NdSJ\"\n"}, "text/xml": {"example": "\n                    <?xml version=\"1.0\" encoding=\"UTF-8\" ?><root><data type=\"list\"><item type=\"dict\"><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19 11:51:43+00:00</startDate><endDate type=\"str\">None</endDate><status type=\"str\">Draft</status><version type=\"str\">0.2</version><changeDescription type=\"str\">Test</changeDescription><userInitials type=\"str\">TODO Initials</userInitials></item><item type=\"dict\"><name type=\"str\">Alamakota</name><startDate type=\"str\">2020-11-19 11:51:07+00:00</startDate><endDate type=\"str\">2020-11-19 11:51:43+00:00</endDate><status type=\"str\">Draft</status><version type=\"str\">0.1</version><changeDescription type=\"str\">Initial version</changeDescription><userInitials type=\"str\">TODO user initials</userInitials></item></data></root>\n"}, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {}}}, "404": {"description": "Not Found - The configuration with the specified 'uid' wasn't found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/configurations/{uid}/new-version": {"post": {"tags": ["configuration", "Study Fields", "Field definition"], "summary": "Creates a new version of the configuration identified by 'uid'.", "description": "This request is only valid if the configuration\n* is in 'Final' or 'Retired' status only (so no latest 'Draft' status exists) \n\nIf the request succeeds:\n* The latest 'Final' or 'Retired' version will remain the same as before.\n* The status of the new version will be automatically set to 'Draft'.\n* The 'version' property of the new version will be automatically set to the version of the latest 'Final' or 'Retired' version increased by +0.1.\n\n", "operationId": "new_version_configurations__uid__new_version_post", "parameters": [{"description": "The unique id of configuration.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of configuration."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTConfigModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The configuration is not in final or retired status or has a draft status.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The  configuration with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/configurations/{uid}/approve": {"post": {"tags": ["configuration", "Study Fields", "Field definition"], "summary": "Approves the configuration identified by 'uid'.", "description": "This request is only valid if the configuration\n* is in 'Draft' status\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will be increased automatically to the next major version.\n    ", "operationId": "approve_configurations__uid__approve_post", "parameters": [{"description": "The unique id of configuration.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of configuration."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTConfigModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The configuration is not in draft status.\n", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The configuration with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/configurations/{uid}/inactivate": {"post": {"tags": ["configuration", "Study Fields", "Field definition"], "summary": "Inactivates/deactivates the configuration identified by 'uid'.", "description": "This request is only valid if the configuration\n* is in 'Final' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Retired'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will remain the same as before.\n    ", "operationId": "inactivate_configurations__uid__inactivate_post", "parameters": [{"description": "The unique id of configuration.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of configuration."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTConfigModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The configuration is not in final status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The configuration with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/configurations/{uid}/reactivate": {"post": {"tags": ["configuration", "Study Fields", "Field definition"], "summary": "Reactivates the configuration identified by 'uid'.", "description": "This request is only valid if the configuration\n* is in 'Retired' status only (so no latest 'Draft' status exists).\n\nIf the request succeeds:\n* The status will be automatically set to 'Final'.\n* The 'changeDescription' property will be set automatically.\n* The 'version' property will remain the same as before.\n    ", "operationId": "reactivate_configurations__uid__reactivate_post", "parameters": [{"description": "The unique id of configuration.", "required": true, "schema": {"title": "Uid", "type": "string", "description": "The unique id of configuration."}, "name": "uid", "in": "path"}, {"description": "A value to be injected into service as user id.", "required": false, "schema": {"title": "X-Test-User-Id", "type": "string", "description": "A value to be injected into service as user id.", "default": "unknown-user"}, "name": "x-test-user-id", "in": "header"}], "responses": {"201": {"description": "OK.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CTConfigModel"}}}}, "403": {"description": "Forbidden - Reasons include e.g.: \n- The configuration is not in retired status.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "404": {"description": "Not Found - The configuration with the specified 'uid' could not be found.", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "500": {"description": "Internal Server Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/ErrorResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}}, "components": {"schemas": {"Activity": {"title": "Activity", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "activitySubGroup": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "activityGroup": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}}}, "ActivityCreateInput": {"title": "ActivityCreateInput", "required": ["libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "activitySubGroup": {"title": "Activitysubgroup", "type": "string"}}}, "ActivityDescriptionTemplate": {"title": "ActivityDescriptionTemplate", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) activity description template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of\n        the activity description template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) activity description template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) activity description template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the activity description template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the activity description template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the activity description template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the activity description template belongs."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "activities": {"title": "Activities", "type": "array", "items": {"$ref": "#/components/schemas/Activity"}, "description": "The activities in scope for the template"}, "activityGroups": {"title": "Activitygroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityGroup"}, "description": "The activity groups in scope for the template"}, "activitySubGroups": {"title": "Activitysubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivitySubGroup"}, "description": "The activity sub groups in scope for the template"}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}}}, "ActivityDescriptionTemplateCreateInput": {"title": "ActivityDescriptionTemplateCreateInput", "required": ["name", "activityGroupUids", "activitySubGroupUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "libraryName": {"title": "Libraryname", "type": "string", "description": "If specified: The name of the library to which the activity description template will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* endpoint can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true.", "default": "Sponsor"}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values to be used as default for this template. The values are ordered as they occur in the template name."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited. Defaults to False.", "default": false}, "indicationUids": {"title": "Indicationuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the study indications, conditions, diseases or disorders to attach the template to."}, "activityUids": {"title": "Activityuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the activities to attach the template to."}, "activityGroupUids": {"title": "Activitygroupuids", "minItems": 1, "type": "array", "items": {"type": "string"}}, "activitySubGroupUids": {"title": "Activitysubgroupuids", "minItems": 1, "type": "array", "items": {"type": "string"}}}}, "ActivityDescriptionTemplateEditGroupingsInput": {"title": "ActivityDescriptionTemplateEditGroupingsInput", "type": "object", "properties": {"indicationUids": {"title": "Indicationuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the study indications, conditions, diseases or disorders to attach the template to."}, "activityUids": {"title": "Activityuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the activities to attach the template to."}, "activityGroupUids": {"title": "Activitygroupuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the activity groups to attach the template to."}, "activitySubGroupUids": {"title": "Activitysubgroupuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the activity sub groups to attach the template to."}}}, "ActivityDescriptionTemplateEditInput": {"title": "ActivityDescriptionTemplateEditInput", "required": ["name", "changeDescription"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}}}, "ActivityDescriptionTemplateNameInput": {"title": "ActivityDescriptionTemplateNameInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}}}, "ActivityDescriptionTemplateVersion": {"title": "ActivityDescriptionTemplateVersion", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) activity description template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of\n        the activity description template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) activity description template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) activity description template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the activity description template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the activity description template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the activity description template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the activity description template belongs."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "activities": {"title": "Activities", "type": "array", "items": {"$ref": "#/components/schemas/Activity"}, "description": "The activities in scope for the template"}, "activityGroups": {"title": "Activitygroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityGroup"}, "description": "The activity groups in scope for the template"}, "activitySubGroups": {"title": "Activitysubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivitySubGroup"}, "description": "The activity sub groups in scope for the template"}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the activity description template (e.g. name, startDate, ..)."}}, "description": "Class for storing Activity Description Templates and calculation of differences"}, "ActivityDescriptionTemplateWithCount": {"title": "ActivityDescriptionTemplateWithCount", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the activity description template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) activity description template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of\n        the activity description template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) activity description template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) activity description template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the activity description template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the activity description template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the activity description template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the activity description template belongs."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "activities": {"title": "Activities", "type": "array", "items": {"$ref": "#/components/schemas/Activity"}, "description": "The activities in scope for the template"}, "activityGroups": {"title": "Activitygroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityGroup"}, "description": "The activity groups in scope for the template"}, "activitySubGroups": {"title": "Activitysubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivitySubGroup"}, "description": "The activity sub groups in scope for the template"}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}, "counts": {"title": "Counts", "allOf": [{"$ref": "#/components/schemas/ItemCounts"}], "description": "Optional counts of activity description instatiations"}}}, "ActivityEditInput": {"title": "ActivityEditInput", "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "activitySubGroup": {"title": "Activitysubgroup", "type": "string"}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "ActivityGroup": {"title": "ActivityGroup", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}}}, "ActivityGroupCreateInput": {"title": "ActivityGroupCreateInput", "required": ["libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}}}, "ActivityGroupEditInput": {"title": "ActivityGroupEditInput", "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "ActivityHierarchySimpleModel": {"title": "ActivityHierarchySimpleModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}}}, "ActivityInstance": {"title": "ActivityInstance", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "topicCode", "adamParamCode", "sdtmVariable", "sdtmSubcat", "sdtmCat", "sdtmDomain", "activities", "activitySubgroups", "activityGroups", "specimen"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "type": {"title": "type", "type": "string", "description": "The subtype of ActivityInstance"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmSubcat": {"title": "sdtmSubcat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmCat": {"title": "sdtmCat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmDomain": {"title": "sdtmDomain", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "activities": {"title": "activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity unique identifiers"}, "activitySubgroups": {"title": "activitySubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity sub group unique identifiers"}, "activityGroups": {"title": "activityGroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity group unique identifiers"}, "specimen": {"title": "specimen", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}}}, "ActivityInstructionCreateInput": {"title": "ActivityInstructionCreateInput", "required": ["activityInstructionTemplateUid", "parameterValues"], "type": "object", "properties": {"activityInstructionTemplateUid": {"title": "activityInstructionTemplateUid", "type": "string", "description": "The unique id of the activity instruction template that is used as the basis for the new activity instruction."}, "nameOverride": {"title": "name", "type": "string", "description": "Optionally, a name to override the name inherited from the template."}, "parameterValues": {"title": "parameterValues", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterMultiSelectInput"}, "description": "An ordered list of selected parameter values that are used to replace the parameters of the activity instruction template."}, "libraryName": {"title": "libraryName", "type": "string", "description": "If specified: The name of the library to which the criteria will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* criteria can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true. \n\nIf not specified: The library of the criteria template will be used."}}}, "ActivitySubGroup": {"title": "ActivitySubGroup", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "activityGroup"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "activityGroup": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}}}, "ActivitySubGroupCreateInput": {"title": "ActivitySubGroupCreateInput", "required": ["libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "activityGroup": {"title": "Activitygroup", "type": "string"}}}, "ActivitySubGroupEditInput": {"title": "ActivitySubGroupEditInput", "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "activityGroup": {"title": "Activitygroup", "type": "string"}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "AllowedTimeReferences": {"title": "AllowedTimeReferences", "required": ["timeReferenceUid", "timeReferenceName"], "type": "object", "properties": {"timeReferenceUid": {"title": "Timereferenceuid", "type": "string"}, "timeReferenceName": {"title": "Timereferencename", "type": "string"}}}, "AllowedVisitTypesForEpochType": {"title": "AllowedVisitTypesForEpochType", "required": ["visit_type_uid", "visit_type_name"], "type": "object", "properties": {"visit_type_uid": {"title": "visit type uid", "type": "string", "description": "Visit Type Term uid"}, "visit_type_name": {"title": "visit type name", "type": "string", "description": "Visit type Term name"}}}, "BatchErrorResponse": {"title": "BatchErrorResponse", "required": ["time"], "type": "object", "properties": {"message": {"title": "Message", "type": "string", "description": "More information about the error."}, "time": {"title": "Time", "type": "string", "description": "The point in time when the error occurred.", "format": "date-time"}}}, "Body_patch_default_parameter_values_activity_description_templates__uid__default_parameter_values_patch": {"title": "Body_patch_default_parameter_values_activity_description_templates__uid__default_parameter_values_patch", "type": "object", "properties": {"setNumber": {"title": "Setnumber", "type": "integer", "description": "Optionally, the set number of the default parameter values to be patched. If not set, a new set will be created."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "The set of default parameter values.\nIf empty and an existing set_number is passed, the set will be deleted."}}}, "Body_patch_default_parameter_values_criteria_templates__uid__default_parameter_values_patch": {"title": "Body_patch_default_parameter_values_criteria_templates__uid__default_parameter_values_patch", "type": "object", "properties": {"setNumber": {"title": "Setnumber", "type": "integer", "description": "Optionally, the set number of the default parameter values to be patched. If not set, a new set will be created."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "The set of default parameter values.\nIf empty and an existing set_number is passed, the set will be deleted."}}}, "Body_patch_default_parameter_values_endpoint_templates__uid__default_parameter_values_patch": {"title": "Body_patch_default_parameter_values_endpoint_templates__uid__default_parameter_values_patch", "type": "object", "properties": {"setNumber": {"title": "Setnumber", "type": "integer", "description": "Optionally, the set number of the default parameter values to be patched. If not set, a new set will be created."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "The set of default parameter values.\nIf empty and an existing set_number is passed, the set will be deleted."}}}, "Body_patch_default_parameter_values_objective_templates__uid__default_parameter_values_patch": {"title": "Body_patch_default_parameter_values_objective_templates__uid__default_parameter_values_patch", "type": "object", "properties": {"setNumber": {"title": "Setnumber", "type": "integer", "description": "Optionally, the set number of the default parameter values to be patched. If not set, a new set will be created."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "The set of default parameter values.\nIf empty and an existing set_number is passed, the set will be deleted."}}}, "Brand": {"title": "Brand", "required": ["uid", "name"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string", "description": "The unique id of the Brand."}, "name": {"title": "name", "type": "string"}}}, "BrandCreateInput": {"title": "BrandCreateInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "name", "type": "string"}}}, "CDISCCTList": {"title": "CDISCCTList", "type": "object", "properties": {"ct_cd_list_cd": {"title": "CT codelist", "type": "string", "description": "CT codelist"}, "ct_cd_list_extensible": {"title": "CT codelist extensible", "type": "string", "description": "Is CT codelist extensible"}, "ct_cd_list_nm": {"title": "CT codelist name", "type": "string", "description": "Name of CT codelist"}, "ct_cd_list_submval": {"title": "CT codelist submission value", "type": "string", "description": "CT codelist submission value"}, "ct_scope": {"title": "CT scope", "type": "string", "description": "CT scope"}, "ct_ver": {"title": "CT version", "type": "string", "description": "CT version"}, "definition": {"title": "definition", "type": "string", "description": "definition"}, "nci_pref_term": {"title": "NCI preferred term", "type": "string", "description": "NCI preferred term"}, "pkg_nm": {"title": "Package name", "type": "string", "description": "Package name"}, "synonyms": {"title": "Synonyms", "type": "string", "description": "Synonyms"}}}, "CDISCCTPkg": {"title": "CDISCCTPkg", "type": "object", "properties": {"pkg_scope": {"title": "Package scope", "type": "string", "description": "Scope"}, "pkg_nm": {"title": "Package name", "type": "string", "description": "Package name"}}}, "CDISCCTVal": {"title": "CDISCCTVal", "type": "object", "properties": {"ct_cd": {"title": "CT Code", "type": "string", "description": "CT Code"}, "ct_cd_list_submval": {"title": "CT codelist submission value", "type": "string", "description": "CT codelist submission value"}, "ct_scope": {"title": "CT scope", "type": "string", "description": "CT scope"}, "ct_submval": {"title": "CT code submission value", "type": "string", "description": "CT code submission value"}, "ct_ver": {"title": "CT version", "type": "string", "description": "CT version"}, "definition": {"title": "definition", "type": "string", "description": "definition"}, "nci_pref_term": {"title": "NCI preferred term", "type": "string", "description": "NCI preferred term"}, "pkg_nm": {"title": "Package name", "type": "string", "description": "Package name"}, "synonyms": {"title": "Synonyms", "type": "string", "description": "Synonyms"}}}, "CDISCCTVer": {"title": "CDISCCTVer", "type": "object", "properties": {"ct_scope": {"title": "CT scope", "type": "string", "description": "Scope"}, "ct_ver": {"title": "ct_ver", "type": "string", "description": "CT version"}, "pkg_nm": {"title": "Package name", "type": "string", "description": "Package name"}}}, "CTCatalogue": {"title": "CTCatalogue", "required": ["name", "libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string"}, "libraryName": {"title": "libraryName", "type": "string"}}}, "CTCatalogueChanges": {"title": "CTCatalogueChanges", "required": ["startDatetime", "endDatetime", "newCodelists", "deletedCodelists", "updatedCodelists", "newTerms", "deletedTerms", "updatedTerms"], "type": "object", "properties": {"startDatetime": {"title": "Startdatetime", "type": "string", "format": "date-time"}, "endDatetime": {"title": "Enddatetime", "type": "string", "format": "date-time"}, "newCodelists": {"title": "Newcodelists", "type": "array", "items": {"$ref": "#/components/schemas/CodelistChangeItem"}}, "deletedCodelists": {"title": "Deletedcodelists", "type": "array", "items": {"$ref": "#/components/schemas/CodelistChangeItem"}}, "updatedCodelists": {"title": "Updatedcodelists", "type": "array", "items": {"$ref": "#/components/schemas/CodelistChangeItem"}}, "newTerms": {"title": "Newterms", "type": "array", "items": {"$ref": "#/components/schemas/TermChangeItem"}}, "deletedTerms": {"title": "Deletedterms", "type": "array", "items": {"$ref": "#/components/schemas/TermChangeItem"}}, "updatedTerms": {"title": "Updatedterms", "type": "array", "items": {"$ref": "#/components/schemas/TermChangeItem"}}}}, "CTCodelist": {"title": "CTCodelist", "required": ["catalogueName", "codelistUid", "parentCodelistUid", "childCodelistUids", "name", "submissionValue", "nciPreferredName", "definition", "extensible", "sponsorPreferredName", "templateParameter", "libraryName"], "type": "object", "properties": {"catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "parentCodelistUid": {"title": "parentCodelistUid", "type": "string"}, "childCodelistUids": {"title": "childCodelistUids", "type": "array", "items": {"type": "string"}}, "name": {"title": "name", "type": "string"}, "submissionValue": {"title": "submissionValue", "type": "string"}, "nciPreferredName": {"title": "nciPreferredName", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "extensible": {"title": "extensible", "type": "boolean"}, "sponsorPreferredName": {"title": "sponsorPreferredName", "type": "string"}, "templateParameter": {"title": "templateParameter", "type": "boolean"}, "libraryName": {"title": "Libraryname", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the CTCodelistAttributes. Actions are: 'approve', 'edit', 'newVersion'."}}}, "CTCodelistAttributes": {"title": "CTCodelistAttributes", "required": ["name", "submissionValue", "nciPreferredName", "definition", "extensible"], "type": "object", "properties": {"catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "parentCodelistUid": {"title": "parentCodelistUid", "type": "string"}, "childCodelistUids": {"title": "childCodelistUids", "type": "array", "items": {"type": "string"}}, "name": {"title": "name", "type": "string"}, "submissionValue": {"title": "submissionValue", "type": "string"}, "nciPreferredName": {"title": "nciPreferredName", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "extensible": {"title": "extensible", "type": "boolean"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the CTCodelistAttributes. Actions are: 'approve', 'edit', 'newVersion'."}}}, "CTCodelistAttributesEditInput": {"title": "CTCodelistAttributesEditInput", "type": "object", "properties": {"name": {"title": "name", "type": "string"}, "submissionValue": {"title": "submissionValue", "type": "string"}, "nciPreferredName": {"title": "nciPreferredName", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "extensible": {"title": "extensible", "type": "boolean"}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "CTCodelistAttributesSimpleModel": {"title": "CTCodelistAttributesSimpleModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}, "submissionValue": {"title": "submissionValue", "type": "string"}, "preferredTerm": {"title": "preferredTerm", "type": "string"}}}, "CTCodelistAttributesVersion": {"title": "CTCodelistAttributesVersion", "required": ["name", "submissionValue", "nciPreferredName", "definition", "extensible"], "type": "object", "properties": {"catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "parentCodelistUid": {"title": "parentCodelistUid", "type": "string"}, "childCodelistUids": {"title": "childCodelistUids", "type": "array", "items": {"type": "string"}}, "name": {"title": "name", "type": "string"}, "submissionValue": {"title": "submissionValue", "type": "string"}, "nciPreferredName": {"title": "nciPreferredName", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "extensible": {"title": "extensible", "type": "boolean"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the CTCodelistAttributes. Actions are: 'approve', 'edit', 'newVersion'."}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the objective (e.g. name, startDate, ..)."}}, "description": "Class for storing CTCodelistAttributes and calculation of differences"}, "CTCodelistCreateInput": {"title": "CTCodelistCreateInput", "required": ["catalogueName", "name", "submissionValue", "nciPreferredName", "definition", "extensible", "sponsorPreferredName", "templateParameter", "terms", "libraryName"], "type": "object", "properties": {"catalogueName": {"title": "catalogueName", "type": "string"}, "name": {"title": "name", "type": "string"}, "submissionValue": {"title": "submissionValue", "type": "string"}, "nciPreferredName": {"title": "nciPreferredName", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "extensible": {"title": "extensible", "type": "boolean"}, "sponsorPreferredName": {"title": "sponsorPreferredName", "type": "string"}, "templateParameter": {"title": "templateParameter", "type": "boolean"}, "parentCodelistUid": {"title": "parentCodelistUid", "type": "string"}, "terms": {"title": "Terms", "type": "array", "items": {"$ref": "#/components/schemas/CTCodelistTermInput"}}, "libraryName": {"title": "Libraryname", "type": "string"}}}, "CTCodelistName": {"title": "CTCodelistName", "required": ["name", "templateParameter"], "type": "object", "properties": {"catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "name": {"title": "name", "type": "string"}, "templateParameter": {"title": "templateParameter", "type": "boolean"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the CTCodelistName. Actions are: 'approve', 'edit', 'newVersion'."}}}, "CTCodelistNameAndAttributes": {"title": "CTCodelistNameAndAttributes", "required": ["catalogueName", "codelistUid", "libraryName", "name", "attributes"], "type": "object", "properties": {"catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "parentCodelistUid": {"title": "parentCodelistUid", "type": "string"}, "childCodelistUids": {"title": "childCodelistUids", "type": "array", "items": {}}, "libraryName": {"title": "Libraryname", "type": "string"}, "name": {"title": "CTCodelistName", "allOf": [{"$ref": "#/components/schemas/CTCodelistName"}]}, "attributes": {"title": "CTCodelistAttributes", "allOf": [{"$ref": "#/components/schemas/CTCodelistAttributes"}]}}}, "CTCodelistNameEditInput": {"title": "CTCodelistNameEditInput", "type": "object", "properties": {"name": {"title": "name", "type": "string"}, "templateParameter": {"title": "templateParameter", "type": "boolean"}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "CTCodelistNameVersion": {"title": "CTCodelistNameVersion", "required": ["name", "templateParameter"], "type": "object", "properties": {"catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "name": {"title": "name", "type": "string"}, "templateParameter": {"title": "templateParameter", "type": "boolean"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the CTCodelistName. Actions are: 'approve', 'edit', 'newVersion'."}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the objective (e.g. name, startDate, ..)."}}, "description": "Class for storing CTCodelistAttributes and calculation of differences"}, "CTCodelistTermInput": {"title": "CTCodelistTermInput", "required": ["termUid"], "type": "object", "properties": {"termUid": {"title": "termUid", "type": "string"}, "order": {"title": "order", "type": "integer", "default": 999999}}}, "CTConfigModel": {"title": "CTConfigModel", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "studyFieldName": {"title": "Studyfieldname", "type": "string"}, "studyFieldDataType": {"title": "Studyfielddatatype", "type": "string"}, "studyFieldNullValueCode": {"title": "Studyfieldnullvaluecode", "type": "string"}, "configuredCodelistUid": {"title": "Configuredcodelistuid", "type": "string"}, "configuredTermUid": {"title": "Configuredtermuid", "type": "string"}, "studyFieldGrouping": {"title": "Studyfieldgrouping", "type": "string"}, "studyFieldNameProperty": {"title": "Studyfieldnameproperty", "type": "string"}, "studyFieldNameApi": {"title": "Studyfieldnameapi", "type": "string"}}}, "CTConfigPatchInput": {"title": "CTConfigPatchInput", "required": ["changeDescription"], "type": "object", "properties": {"studyFieldName": {"title": "Studyfieldname", "type": "string"}, "studyFieldDataType": {"title": "Studyfielddatatype", "type": "string"}, "studyFieldNullValueCode": {"title": "Studyfieldnullvaluecode", "type": "string"}, "configuredCodelistUid": {"title": "Configuredcodelistuid", "type": "string"}, "configuredTermUid": {"title": "Configuredtermuid", "type": "string"}, "studyFieldGrouping": {"title": "Studyfieldgrouping", "type": "string"}, "studyFieldNameProperty": {"title": "Studyfieldnameproperty", "type": "string"}, "studyFieldNameApi": {"title": "Studyfieldnameapi", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}}}, "CTConfigPostInput": {"title": "CTConfigPostInput", "type": "object", "properties": {"studyFieldName": {"title": "Studyfieldname", "type": "string"}, "studyFieldDataType": {"title": "Studyfielddatatype", "type": "string"}, "studyFieldNullValueCode": {"title": "Studyfieldnullvaluecode", "type": "string"}, "configuredCodelistUid": {"title": "Configuredcodelistuid", "type": "string"}, "configuredTermUid": {"title": "Configuredtermuid", "type": "string"}, "studyFieldGrouping": {"title": "Studyfieldgrouping", "type": "string"}, "studyFieldNameProperty": {"title": "Studyfieldnameproperty", "type": "string"}, "studyFieldNameApi": {"title": "Studyfieldnameapi", "type": "string"}, "configuredCodelistName": {"title": "Configuredcodelistname", "type": "string"}}}, "CTPackage": {"title": "CTPackage", "required": ["uid", "catalogueName", "name", "importDate", "effectiveDate", "userInitials"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "catalogueName": {"title": "catalogueName", "type": "string"}, "name": {"title": "name", "type": "string"}, "label": {"title": "label", "type": "string"}, "description": {"title": "description", "type": "string"}, "href": {"title": "href", "type": "string"}, "registrationStatus": {"title": "registrationStatus", "type": "string"}, "source": {"title": "source", "type": "string"}, "importDate": {"title": "importDate", "type": "string", "format": "date-time"}, "effectiveDate": {"title": "effectiveDate", "type": "string", "format": "date"}, "userInitials": {"title": "userInitials", "type": "string"}}}, "CTPackageChanges": {"title": "CTPackageChanges", "required": ["fromPackage", "toPackage", "newCodelists", "deletedCodelists", "updatedCodelists", "newTerms", "deletedTerms", "updatedTerms"], "type": "object", "properties": {"fromPackage": {"title": "Frompackage", "type": "string"}, "toPackage": {"title": "Topackage", "type": "string"}, "newCodelists": {"title": "Newcodelists", "type": "array", "items": {"$ref": "#/components/schemas/CodelistChangeItem"}}, "deletedCodelists": {"title": "Deletedcodelists", "type": "array", "items": {"$ref": "#/components/schemas/CodelistChangeItem"}}, "updatedCodelists": {"title": "Updatedcodelists", "type": "array", "items": {"$ref": "#/components/schemas/CodelistChangeItem"}}, "newTerms": {"title": "Newterms", "type": "array", "items": {"$ref": "#/components/schemas/TermChangeItem"}}, "deletedTerms": {"title": "Deletedterms", "type": "array", "items": {"$ref": "#/components/schemas/TermChangeItem"}}, "updatedTerms": {"title": "Updatedterms", "type": "array", "items": {"$ref": "#/components/schemas/TermChangeItem"}}}}, "CTPackageChangesSpecificCodelist": {"title": "CTPackageChangesSpecificCodelist", "required": ["fromPackage", "toPackage", "newCodelists", "deletedCodelists", "updatedCodelists", "newTerms", "deletedTerms", "updatedTerms", "notModifiedTerms"], "type": "object", "properties": {"fromPackage": {"title": "Frompackage", "type": "string"}, "toPackage": {"title": "Topackage", "type": "string"}, "newCodelists": {"title": "Newcodelists", "type": "array", "items": {"$ref": "#/components/schemas/CodelistChangeItem"}}, "deletedCodelists": {"title": "Deletedcodelists", "type": "array", "items": {"$ref": "#/components/schemas/CodelistChangeItem"}}, "updatedCodelists": {"title": "Updatedcodelists", "type": "array", "items": {"$ref": "#/components/schemas/CodelistChangeItem"}}, "newTerms": {"title": "Newterms", "type": "array", "items": {"$ref": "#/components/schemas/TermChangeItem"}}, "deletedTerms": {"title": "Deletedterms", "type": "array", "items": {"$ref": "#/components/schemas/TermChangeItem"}}, "updatedTerms": {"title": "Updatedterms", "type": "array", "items": {"$ref": "#/components/schemas/TermChangeItem"}}, "notModifiedTerms": {"title": "Notmodifiedterms", "type": "array", "items": {"$ref": "#/components/schemas/TermChangeItem"}}}}, "CTPackageDates": {"title": "CTPackageDates", "required": ["catalogueName", "effectiveDates"], "type": "object", "properties": {"catalogueName": {"title": "catalogueName", "type": "string"}, "effectiveDates": {"title": "effectiveDates", "type": "array", "items": {"type": "string", "format": "date"}}}}, "CTStats": {"title": "CTStats", "required": ["catalogues", "packages", "codelistCounts", "termCounts", "codelistChangePercentage", "termChangePercentage", "codelistChangeDetails", "termChangeDetails", "latestAddedCodelists"], "type": "object", "properties": {"catalogues": {"title": "catalogues", "type": "integer", "description": "Number of catalogues in the database"}, "packages": {"title": "packages", "type": "integer", "description": "Number of packages in the database"}, "codelistCounts": {"title": "codelistCounts", "type": "array", "items": {"$ref": "#/components/schemas/CodelistCount"}, "description": "Count of codelists grouped by Library"}, "termCounts": {"title": "termCounts", "type": "array", "items": {"$ref": "#/components/schemas/TermCount"}, "description": "Count of terms grouped by Library"}, "codelistChangePercentage": {"title": "codelistChangePercentage", "type": "number", "description": "Mean percentage of evolution for codelists"}, "termChangePercentage": {"title": "termChangePercentage", "type": "number", "description": "Mean percentage of evolution for terms"}, "codelistChangeDetails": {"title": "codelistChangeDetails", "type": "array", "items": {"$ref": "#/components/schemas/CountByTypeByYear"}, "description": "Codelist changes, grouped by type and year"}, "termChangeDetails": {"title": "termChangeDetails", "type": "array", "items": {"$ref": "#/components/schemas/CountByTypeByYear"}, "description": "Term changes, grouped by type and year"}, "latestAddedCodelists": {"title": "latestAddedCodelists", "type": "array", "items": {"$ref": "#/components/schemas/CTCodelistNameAndAttributes"}, "description": "List of latest added codelists"}}}, "CTTerm": {"title": "CTTerm", "required": ["termUid", "catalogueName", "codelistUid", "conceptId", "codeSubmissionValue", "nameSubmissionValue", "nciPreferredName", "definition", "sponsorPreferredName", "sponsorPreferredNameSentenceCase", "libraryName"], "type": "object", "properties": {"termUid": {"title": "termUid", "type": "string"}, "catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "conceptId": {"title": "conceptId", "type": "string"}, "codeSubmissionValue": {"title": "codeSubmissionValue", "type": "string"}, "nameSubmissionValue": {"title": "nameSubmissionValue", "type": "string"}, "nciPreferredName": {"title": "nciPreferredName", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "sponsorPreferredName": {"title": "sponsorPreferredName", "type": "string"}, "sponsorPreferredNameSentenceCase": {"title": "sponsorPreferredNameSentenceCase", "type": "string"}, "order": {"title": "order", "type": "integer", "default": 999999}, "libraryName": {"title": "Libraryname", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the CTTerm. Actions are: 'approve', 'edit', 'newVersion'."}}}, "CTTermAttributes": {"title": "CTTermAttributes", "required": ["conceptId", "codeSubmissionValue", "nameSubmissionValue", "nciPreferredName", "definition"], "type": "object", "properties": {"termUid": {"title": "termUid", "type": "string"}, "catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "conceptId": {"title": "conceptId", "type": "string"}, "codeSubmissionValue": {"title": "codeSubmissionValue", "type": "string"}, "nameSubmissionValue": {"title": "nameSubmissionValue", "type": "string"}, "nciPreferredName": {"title": "nciPreferredName", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the CTTermAttributes. Actions are: 'approve', 'edit', 'newVersion'."}}}, "CTTermAttributesEditInput": {"title": "CTTermAttributesEditInput", "type": "object", "properties": {"codeSubmissionValue": {"title": "codeSubmissionValue", "type": "string"}, "nameSubmissionValue": {"title": "nameSubmissionValue", "type": "string"}, "nciPreferredName": {"title": "nciPreferredName", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "CTTermAttributesVersion": {"title": "CTTermAttributesVersion", "required": ["conceptId", "codeSubmissionValue", "nameSubmissionValue", "nciPreferredName", "definition"], "type": "object", "properties": {"termUid": {"title": "termUid", "type": "string"}, "catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "conceptId": {"title": "conceptId", "type": "string"}, "codeSubmissionValue": {"title": "codeSubmissionValue", "type": "string"}, "nameSubmissionValue": {"title": "nameSubmissionValue", "type": "string"}, "nciPreferredName": {"title": "nciPreferredName", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the CTTermAttributes. Actions are: 'approve', 'edit', 'newVersion'."}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the objective (e.g. name, startDate, ..)."}}, "description": "Class for storing CTTermAttributes and calculation of differences"}, "CTTermCreateInput": {"title": "CTTermCreateInput", "required": ["catalogueName", "codelistUid", "codeSubmissionValue", "nciPreferredName", "definition", "sponsorPreferredName", "sponsorPreferredNameSentenceCase", "libraryName"], "type": "object", "properties": {"catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "codeSubmissionValue": {"title": "codeSubmissionValue", "type": "string"}, "nameSubmissionValue": {"title": "nameSubmissionValue", "type": "string"}, "nciPreferredName": {"title": "nciPreferredName", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "sponsorPreferredName": {"title": "sponsorPreferredName", "type": "string"}, "sponsorPreferredNameSentenceCase": {"title": "sponsorPreferredNameSentenceCase", "type": "string"}, "order": {"title": "order", "type": "integer", "default": 999999}, "libraryName": {"title": "libraryName", "type": "string"}}}, "CTTermName": {"title": "CTTermName", "required": ["sponsorPreferredName", "sponsorPreferredNameSentenceCase"], "type": "object", "properties": {"termUid": {"title": "termUid", "type": "string"}, "catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "sponsorPreferredName": {"title": "sponsorPreferredName", "type": "string"}, "sponsorPreferredNameSentenceCase": {"title": "sponsorPreferredNameSentenceCase", "type": "string"}, "order": {"title": "order", "type": "integer", "default": 999999}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the CTTermName. Actions are: 'approve', 'edit', 'newVersion'."}}}, "CTTermNameAndAttributes": {"title": "CTTermNameAndAttributes", "required": ["termUid", "catalogueName", "codelistUid", "name", "attributes"], "type": "object", "properties": {"termUid": {"title": "codelistUid", "type": "string"}, "catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "name": {"title": "CTTermName", "allOf": [{"$ref": "#/components/schemas/CTTermName"}]}, "attributes": {"title": "CTTermAttributes", "allOf": [{"$ref": "#/components/schemas/CTTermAttributes"}]}}}, "CTTermNameEditInput": {"title": "CTTermNameEditInput", "type": "object", "properties": {"sponsorPreferredName": {"title": "sponsorPreferredName", "type": "string"}, "sponsorPreferredNameSentenceCase": {"title": "sponsorPreferredNameSentenceCase", "type": "string"}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "CTTermNameVersion": {"title": "CTTermNameVersion", "required": ["sponsorPreferredName", "sponsorPreferredNameSentenceCase"], "type": "object", "properties": {"termUid": {"title": "termUid", "type": "string"}, "catalogueName": {"title": "catalogueName", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "sponsorPreferredName": {"title": "sponsorPreferredName", "type": "string"}, "sponsorPreferredNameSentenceCase": {"title": "sponsorPreferredNameSentenceCase", "type": "string"}, "order": {"title": "order", "type": "integer", "default": 999999}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the CTTermName. Actions are: 'approve', 'edit', 'newVersion'."}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the objective (e.g. name, startDate, ..)."}}, "description": "Class for storing CTTermName and calculation of differences"}, "CTTermNewOrder": {"title": "CTTermNewOrder", "required": ["codelistUid"], "type": "object", "properties": {"codelistUid": {"title": "codelistUid", "type": "string"}, "newOrder": {"title": "newOrder", "type": "integer", "default": 999999}}}, "CategoricFinding": {"title": "CategoricFinding", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "topicCode", "adamParamCode", "sdtmVariable", "sdtmSubcat", "sdtmCat", "sdtmDomain", "activities", "activitySubgroups", "activityGroups"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "type": {"title": "type", "type": "string", "description": "The subtype of ActivityInstance"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmSubcat": {"title": "sdtmSubcat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmCat": {"title": "sdtmCat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmDomain": {"title": "sdtmDomain", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "activities": {"title": "activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity unique identifiers"}, "activitySubgroups": {"title": "activitySubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity sub group unique identifiers"}, "activityGroups": {"title": "activityGroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity group unique identifiers"}, "specimen": {"$ref": "#/components/schemas/SimpleTermModel"}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "testCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "categoricResponseValue": {"$ref": "#/components/schemas/SimpleTermModel"}, "categoricResponseList": {"$ref": "#/components/schemas/SimpleTermModel"}}}, "CategoricFindingCreateInput": {"title": "CategoricFindingCreateInput", "required": ["name", "libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "specimen": {"title": "Specimen", "type": "string"}, "testCode": {"title": "Testcode", "type": "string"}, "categoricResponseValue": {"title": "Categoricresponsevalue", "type": "string"}, "categoricResponseList": {"title": "Categoricresponselist", "type": "string"}}}, "CategoricFindingEditInput": {"title": "CategoricFindingEditInput", "required": ["changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "specimen": {"title": "Specimen", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "changeDescription": {"title": "changeDescription", "type": "string"}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "testCode": {"title": "Testcode", "type": "string"}, "categoricResponseValue": {"title": "Categoricresponsevalue", "type": "string"}, "categoricResponseList": {"title": "Categoricresponselist", "type": "string"}}}, "ClinicalProgramme": {"title": "ClinicalProgramme", "required": ["uid", "name"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string", "description": "The unique id of the ClinicalProgramme value."}, "name": {"title": "name", "type": "string"}}}, "ClinicalProgrammeInput": {"title": "ClinicalProgrammeInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "name", "type": "string"}}}, "CodelistChangeItem": {"title": "CodelistChangeItem", "required": ["uid", "value_node", "change_date", "is_change_of_codelist"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "value_node": {"title": "Value Node", "type": "object"}, "change_date": {"title": "Change Date", "type": "string", "format": "date-time"}, "is_change_of_codelist": {"title": "Is Change Of Codelist", "type": "boolean"}}}, "CodelistCount": {"title": "CodelistCount", "required": ["libraryName", "count"], "type": "object", "properties": {"libraryName": {"title": "Libraryname", "type": "string"}, "count": {"title": "Count", "type": "integer"}}}, "ComplexParameterTemplate": {"title": "ComplexParameterTemplate", "required": ["uid"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "\n            The actual value/content. It may include parameters\n            referenced by simple strings in square brackets [].\n            "}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "startDate": {"title": "Startdate", "type": "string", "description": "\n            Part of the metadata: The point in time when the\n            (version of the) timeframe template was created.\n            The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00'\n            for October 31, 2020 at 6pm in UTC+2 timezone.\n            ", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the timeframe template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) timeframe template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) timeframe template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the timeframe template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the timeframe template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the timeframe template."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the timeframe template belongs."}}}, "ComplexParameterTemplateCreateInput": {"title": "ComplexParameterTemplateCreateInput", "required": ["name", "parameterName"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "parameterName": {"title": "Parametername", "type": "string", "description": "If specified: The name of the library to which the timeframe template will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* endpoint can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true."}, "libraryName": {"title": "Libraryname", "type": "string", "description": "If specified: The name of the library to which the timeframe template will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* endpoint can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true.", "default": "Sponsor"}}}, "ComplexParameterTemplateEditInput": {"title": "ComplexParameterTemplateEditInput", "required": ["name", "changeDescription"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}}}, "ComplexParameterTemplateNameInput": {"title": "ComplexParameterTemplateNameInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}}}, "ComplexParameterTemplateVersion": {"title": "ComplexParameterTemplateVersion", "required": ["uid"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "\n            The actual value/content. It may include parameters\n            referenced by simple strings in square brackets [].\n            "}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "startDate": {"title": "Startdate", "type": "string", "description": "\n            Part of the metadata: The point in time when the\n            (version of the) timeframe template was created.\n            The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00'\n            for October 31, 2020 at 6pm in UTC+2 timezone.\n            ", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the timeframe template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) timeframe template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) timeframe template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the timeframe template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the timeframe template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the timeframe template."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the timeframe template belongs."}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the timeframe template (e.g. name, startDate, ..)."}}, "description": "Class for storing ComplexParameter Templates and calculation of differences"}, "ComplexParameterTemplateWithCount": {"title": "ComplexParameterTemplateWithCount", "required": ["uid"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "\n            The actual value/content. It may include parameters\n            referenced by simple strings in square brackets [].\n            "}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the parameter template."}, "startDate": {"title": "Startdate", "type": "string", "description": "\n            Part of the metadata: The point in time when the\n            (version of the) timeframe template was created.\n            The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00'\n            for October 31, 2020 at 6pm in UTC+2 timezone.\n            ", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the timeframe template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) timeframe template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) timeframe template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the timeframe template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the timeframe template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the timeframe template."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the timeframe template belongs."}, "counts": {"title": "Counts", "allOf": [{"$ref": "#/components/schemas/ItemCounts"}], "description": "Optional counts of objective instatiations"}}}, "ComplexTemplateParameter": {"title": "ComplexTemplateParameter", "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "format": {"title": "Format", "type": "string"}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}}, "values": {"title": "values", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterValue"}, "description": "The possible values of the template parameter."}}}, "Compound": {"title": "Compound", "required": ["uid", "name", "libraryName", "possibleActions"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on Compounds. Actions are: 'approve', 'edit', 'newVersion'."}, "analyteNumber": {"title": "Analytenumber", "type": "string"}, "nncShortNumber": {"title": "Nncshortnumber", "type": "string"}, "nncLongNumber": {"title": "Nnclongnumber", "type": "string"}, "isSponsorCompound": {"title": "Issponsorcompound", "type": "boolean", "default": true}, "isNameInn": {"title": "Isnameinn", "type": "boolean", "default": true}, "substances": {"title": "Substances", "type": "array", "items": {"$ref": "#/components/schemas/CompoundSubstance"}}, "doseValues": {"title": "Dosevalues", "type": "array", "items": {"$ref": "#/components/schemas/SimpleNumericValueWithUnit"}}, "strengthValues": {"title": "Strengthvalues", "type": "array", "items": {"$ref": "#/components/schemas/SimpleNumericValueWithUnit"}}, "lagTimes": {"title": "Lagtimes", "type": "array", "items": {"$ref": "#/components/schemas/SimpleLagTime"}}, "deliveryDevices": {"title": "Deliverydevices", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "dispensers": {"title": "Dispensers", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "projects": {"title": "Projects", "type": "array", "items": {"$ref": "#/components/schemas/Project"}}, "brands": {"title": "Brands", "type": "array", "items": {"$ref": "#/components/schemas/Brand"}}, "halfLife": {"$ref": "#/components/schemas/SimpleNumericValueWithUnit"}, "doseFrequencies": {"title": "Dosefrequencies", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "dosageForms": {"title": "Dosageforms", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "routesOfAdministration": {"title": "Routesofadministration", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}}}, "CompoundAlias": {"title": "CompoundAlias", "required": ["uid", "name", "libraryName", "possibleActions", "compound"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on CompoundAliass. Actions are: 'approve', 'edit', 'newVersion'."}, "compound": {"$ref": "#/components/schemas/SimpleCompound"}, "isPreferredSynonym": {"title": "Ispreferredsynonym", "type": "boolean", "default": false}}}, "CompoundAliasCreateInput": {"title": "CompoundAliasCreateInput", "required": ["compoundUid"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "compoundUid": {"title": "Compounduid", "type": "string"}, "isPreferredSynonym": {"title": "Ispreferredsynonym", "type": "boolean", "default": false}}}, "CompoundAliasEditInput": {"title": "CompoundAliasEditInput", "required": ["compoundUid", "changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "compoundUid": {"title": "Compounduid", "type": "string"}, "isPreferredSynonym": {"title": "Ispreferredsynonym", "type": "boolean", "default": false}, "changeDescription": {"title": "Changedescription", "type": "string"}}}, "CompoundCreateInput": {"title": "CompoundCreateInput", "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "analyteNumber": {"title": "Analytenumber", "type": "string"}, "nncShortNumber": {"title": "Nncshortnumber", "type": "string"}, "nncLongNumber": {"title": "Nnclongnumber", "type": "string"}, "isSponsorCompound": {"title": "Issponsorcompound", "type": "boolean", "default": true}, "isNameInn": {"title": "Isnameinn", "type": "boolean", "default": true}, "substanceTermsUids": {"title": "Substancetermsuids", "type": "array", "items": {"type": "string"}, "default": []}, "doseValuesUids": {"title": "Dosevaluesuids", "type": "array", "items": {"type": "string"}, "default": []}, "strengthValuesUids": {"title": "Strengthvaluesuids", "type": "array", "items": {"type": "string"}, "default": []}, "lagTimesUids": {"title": "Lagtimesuids", "type": "array", "items": {"type": "string"}, "default": []}, "deliveryDevicesUids": {"title": "Deliverydevicesuids", "type": "array", "items": {"type": "string"}, "default": []}, "dispensersUids": {"title": "Dispensersuids", "type": "array", "items": {"type": "string"}, "default": []}, "projectsUids": {"title": "Projectsuids", "type": "array", "items": {"type": "string"}, "default": []}, "brandsUids": {"title": "Brandsuids", "type": "array", "items": {"type": "string"}, "default": []}, "doseFrequencyUids": {"title": "Dosefrequencyuids", "type": "array", "items": {"type": "string"}, "default": []}, "dosageFormUids": {"title": "Dosageformuids", "type": "array", "items": {"type": "string"}, "default": []}, "routeOfAdministrationUids": {"title": "Routeofadministrationuids", "type": "array", "items": {"type": "string"}, "default": []}, "halfLifeUid": {"title": "Halflifeuid", "type": "string"}}}, "CompoundDosing": {"title": "CompoundDosing", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "topicCode", "adamParamCode", "sdtmVariable", "sdtmSubcat", "sdtmCat", "sdtmDomain", "activities", "activitySubgroups", "activityGroups", "specimen"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "type": {"title": "type", "type": "string", "description": "The subtype of ActivityInstance"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmSubcat": {"title": "sdtmSubcat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmCat": {"title": "sdtmCat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmDomain": {"title": "sdtmDomain", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "activities": {"title": "activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity unique identifiers"}, "activitySubgroups": {"title": "activitySubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity sub group unique identifiers"}, "activityGroups": {"title": "activityGroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity group unique identifiers"}, "specimen": {"title": "specimen", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}}}, "CompoundDosingCreateInput": {"title": "CompoundDosingCreateInput", "required": ["name", "libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}}}, "CompoundDosingEditInput": {"title": "CompoundDosingEditInput", "required": ["changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "specimen": {"title": "specimen", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "CompoundEditInput": {"title": "CompoundEditInput", "required": ["changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "analyteNumber": {"title": "Analytenumber", "type": "string"}, "nncShortNumber": {"title": "Nncshortnumber", "type": "string"}, "nncLongNumber": {"title": "Nnclongnumber", "type": "string"}, "isSponsorCompound": {"title": "Issponsorcompound", "type": "boolean"}, "isNameInn": {"title": "Isnameinn", "type": "boolean"}, "substanceTermsUids": {"title": "Substancetermsuids", "type": "array", "items": {"type": "string"}, "default": []}, "doseValuesUids": {"title": "Dosevaluesuids", "type": "array", "items": {"type": "string"}, "default": []}, "strengthValuesUids": {"title": "Strengthvaluesuids", "type": "array", "items": {"type": "string"}, "default": []}, "lagTimesUids": {"title": "Lagtimesuids", "type": "array", "items": {"type": "string"}, "default": []}, "deliveryDevicesUids": {"title": "Deliverydevicesuids", "type": "array", "items": {"type": "string"}, "default": []}, "dispensersUids": {"title": "Dispensersuids", "type": "array", "items": {"type": "string"}, "default": []}, "projectsUids": {"title": "Projectsuids", "type": "array", "items": {"type": "string"}, "default": []}, "brandsUids": {"title": "Brandsuids", "type": "array", "items": {"type": "string"}, "default": []}, "halfLifeUid": {"title": "Halflifeuid", "type": "string"}, "doseFrequencyUids": {"title": "Dosefrequencyuids", "type": "array", "items": {"type": "string"}, "default": []}, "dosageFormUids": {"title": "Dosageformuids", "type": "array", "items": {"type": "string"}, "default": []}, "routeOfAdministrationUids": {"title": "Routeofadministrationuids", "type": "array", "items": {"type": "string"}, "default": []}, "changeDescription": {"title": "Changedescription", "type": "string"}}}, "CompoundSubstance": {"title": "CompoundSubstance", "required": ["substanceTermUid", "substanceName", "substanceUnii"], "type": "object", "properties": {"substanceTermUid": {"title": "Substancetermuid", "type": "string"}, "substanceName": {"title": "Substancename", "type": "string"}, "substanceUnii": {"title": "Substanceunii", "type": "string"}, "pclassTermUid": {"title": "Pclasstermuid", "type": "string"}, "pclassName": {"title": "Pclassname", "type": "string"}, "pclassId": {"title": "Pclassid", "type": "string"}}}, "CountByType": {"title": "CountByType", "required": ["type", "count"], "type": "object", "properties": {"type": {"$ref": "#/components/schemas/CountTypeEnum"}, "count": {"title": "Count", "type": "integer"}}}, "CountByTypeByYear": {"title": "CountByTypeByYear", "required": ["year", "counts"], "type": "object", "properties": {"year": {"title": "Year", "type": "integer"}, "counts": {"title": "Counts", "type": "array", "items": {"$ref": "#/components/schemas/CountByType"}}}}, "CountTypeEnum": {"title": "CountTypeEnum", "enum": ["added", "deleted", "updated"], "type": "string", "description": "An enumeration."}, "Criteria": {"title": "Criteria", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "namePlain": {"title": "Nameplain", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the criteria. Actions are: None"}, "criteriaTemplate": {"$ref": "#/components/schemas/CriteriaTemplateNameUid"}, "parameterValues": {"title": "Parametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values that are used within the criteria. The values are ordered as they occur in the criteria name."}, "library": {"$ref": "#/components/schemas/Library"}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing criteria"}}}, "CriteriaCreateInput": {"title": "CriteriaCreateInput", "required": ["parameterValues", "criteriaTemplateUid"], "type": "object", "properties": {"parameterValues": {"title": "parameterValues", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterMultiSelectInput"}, "description": "An ordered list of selected parameter values that are used to replace the parameters of the criteria template."}, "criteriaTemplateUid": {"title": "criteriaTemplateUid", "type": "string", "description": "The unique id of the criteria template that is used as the basis for the new criteria."}, "nameOverride": {"title": "name", "type": "string", "description": "Optionally, a name to override the name inherited from the template."}, "libraryName": {"title": "libraryName", "type": "string", "description": "If specified: The name of the library to which the criteria will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* criteria can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true. \n\nIf not specified: The library of the criteria template will be used."}}}, "CriteriaEditInput": {"title": "CriteriaEditInput", "required": ["parameterValues", "changeDescription"], "type": "object", "properties": {"parameterValues": {"title": "parameterValues", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterMultiSelectInput"}, "description": "An ordered list of selected parameter values that are used to replace the parameters of the criteria template."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}}}, "CriteriaTemplate": {"title": "CriteriaTemplate", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) criteria template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the criteria template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) criteria template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) criteria template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the criteria template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the criteria template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the criteria template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the criteria template belongs."}, "type": {"title": "Type", "allOf": [{"$ref": "#/components/schemas/CTTermNameAndAttributes"}], "description": "The criteria type."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "categories": {"title": "Categories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of categories the template belongs to."}, "subCategories": {"title": "Subcategories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of sub-categories the template belongs to."}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}}}, "CriteriaTemplateCreateInput": {"title": "CriteriaTemplateCreateInput", "required": ["name", "typeUid"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "studyUid": {"title": "Studyuid", "type": "string", "description": "The UID of the Study in scope of which given template is being created."}, "libraryName": {"title": "Libraryname", "type": "string", "description": "If specified: The name of the library to which the criteria template will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* endpoint can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true.", "default": "Sponsor"}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values to be used as default for this\n        template. The values are ordered as they occur in the template name. \nThese default parameter values will be created as set#0."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited. Defaults to False.", "default": false}, "typeUid": {"title": "Typeuid", "type": "string", "description": "The UID of the criteria type to attach the template to."}, "indicationUids": {"title": "Indicationuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the study indications, conditions, diseases or disorders to attach the template to."}, "categoryUids": {"title": "Categoryuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the categories to attach the template to."}, "subCategoryUids": {"title": "Subcategoryuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the sub_categories to attach the template to."}}}, "CriteriaTemplateEditGroupingsInput": {"title": "CriteriaTemplateEditGroupingsInput", "type": "object", "properties": {"indicationUids": {"title": "Indicationuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the study indications, conditions, diseases or disorders to attach the template to."}, "categoryUids": {"title": "Categoryuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the categories to attach the template to."}, "subCategoryUids": {"title": "Subcategoryuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the sub_categories to attach the template to."}}}, "CriteriaTemplateEditInput": {"title": "CriteriaTemplateEditInput", "required": ["name", "changeDescription"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}}}, "CriteriaTemplateNameInput": {"title": "CriteriaTemplateNameInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}}}, "CriteriaTemplateNameUid": {"title": "CriteriaTemplateNameUid", "required": ["uid"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}}}, "CriteriaTemplateVersion": {"title": "CriteriaTemplateVersion", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) criteria template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the criteria template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) criteria template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) criteria template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the criteria template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the criteria template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the criteria template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the criteria template belongs."}, "type": {"title": "Type", "allOf": [{"$ref": "#/components/schemas/CTTermNameAndAttributes"}], "description": "The criteria type."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "categories": {"title": "Categories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of categories the template belongs to."}, "subCategories": {"title": "Subcategories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of sub-categories the template belongs to."}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the criteria template (e.g. name, startDate, ..)."}}, "description": "Class for storing Criteria Templates and calculation of differences"}, "CriteriaTemplateWithCount": {"title": "CriteriaTemplateWithCount", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the criteria template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) criteria template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the criteria template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) criteria template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) criteria template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the criteria template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the criteria template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the criteria template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the criteria template belongs."}, "type": {"title": "Type", "allOf": [{"$ref": "#/components/schemas/CTTermNameAndAttributes"}], "description": "The criteria type."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "categories": {"title": "Categories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of categories the template belongs to."}, "subCategories": {"title": "Subcategories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of sub-categories the template belongs to."}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}, "counts": {"title": "Counts", "allOf": [{"$ref": "#/components/schemas/ItemCounts"}], "description": "Optional counts of criteria instatiations"}}}, "CriteriaVersion": {"title": "CriteriaVersion", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "namePlain": {"title": "Nameplain", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the criteria. Actions are: None"}, "criteriaTemplate": {"$ref": "#/components/schemas/CriteriaTemplateNameUid"}, "parameterValues": {"title": "Parametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values that are used within the criteria. The values are ordered as they occur in the criteria name."}, "library": {"$ref": "#/components/schemas/Library"}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing criteria"}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the criteria (e.g. name, startDate, ..)."}}, "description": "Class for storing Criteria and calculation of differences"}, "CustomPage_ActivityDescriptionTemplate_": {"title": "CustomPage[ActivityDescriptionTemplate]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/ActivityDescriptionTemplate"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_ActivityGroup_": {"title": "CustomPage[ActivityGroup]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/ActivityGroup"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_ActivityInstance_": {"title": "CustomPage[ActivityInstance]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/ActivityInstance"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_ActivitySubGroup_": {"title": "CustomPage[ActivitySubGroup]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/ActivitySubGroup"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_Activity_": {"title": "CustomPage[Activity]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/Activity"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CDISCCTList_": {"title": "CustomPage[CDISCCTList]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CDISCCTList"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CDISCCTPkg_": {"title": "CustomPage[CDISCCTPkg]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CDISCCTPkg"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CDISCCTVal_": {"title": "CustomPage[CDISCCTVal]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CDISCCTVal"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CDISCCTVer_": {"title": "CustomPage[CDISCCTVer]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CDISCCTVer"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CTCodelistAttributes_": {"title": "CustomPage[CTCodelistAttributes]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CTCodelistAttributes"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CTCodelistNameAndAttributes_": {"title": "CustomPage[CTCodelistNameAndAttributes]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CTCodelistNameAndAttributes"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CTCodelistName_": {"title": "CustomPage[CTCodelistName]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CTCodelistName"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CTTermAttributes_": {"title": "CustomPage[CTTermAttributes]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CTTermAttributes"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CTTermNameAndAttributes_": {"title": "CustomPage[CTTermNameAndAttributes]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CTTermName_": {"title": "CustomPage[CTTermName]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CTTermName"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CategoricFinding_": {"title": "CustomPage[CategoricFinding]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CategoricFinding"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CompoundAlias_": {"title": "CustomPage[CompoundAlias]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CompoundAlias"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CompoundDosing_": {"title": "CustomPage[CompoundDosing]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CompoundDosing"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_Compound_": {"title": "CustomPage[Compound]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/Compound"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_CriteriaTemplate_": {"title": "CustomPage[CriteriaTemplate]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/CriteriaTemplate"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_DictionaryCodelist_": {"title": "CustomPage[DictionaryCodelist]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryCodelist"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_DictionaryTermSubstance_": {"title": "CustomPage[DictionaryTermSubstance]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTermSubstance"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_DictionaryTerm_": {"title": "CustomPage[DictionaryTerm]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_EndpointTemplate_": {"title": "CustomPage[EndpointTemplate]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/EndpointTemplate"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_Endpoint_": {"title": "CustomPage[Endpoint]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/Endpoint"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_Event_": {"title": "CustomPage[Event]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/Event"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_LaboratoryActivity_": {"title": "CustomPage[LaboratoryActivity]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/LaboratoryActivity"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_LagTime_": {"title": "CustomPage[LagTime]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/LagTime"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_MetaData_": {"title": "CustomPage[MetaData]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/MetaData"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_NumericFinding_": {"title": "CustomPage[NumericFinding]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/NumericFinding"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_NumericValueWithUnit_": {"title": "CustomPage[NumericValueWithUnit]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/NumericValueWithUnit"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_NumericValue_": {"title": "CustomPage[NumericValue]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/NumericValue"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_ObjectiveTemplate_": {"title": "CustomPage[ObjectiveTemplate]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/ObjectiveTemplate"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_Objective_": {"title": "CustomPage[Objective]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/Objective"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmAlias_": {"title": "CustomPage[OdmAlias]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmAlias"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmCondition_": {"title": "CustomPage[OdmCondition]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmCondition"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmDescription_": {"title": "CustomPage[OdmDescription]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmDescription"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmForm_": {"title": "CustomPage[OdmForm]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmForm"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmFormalExpression_": {"title": "CustomPage[OdmFormalExpression]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmFormalExpression"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmItemGroup_": {"title": "CustomPage[OdmItemGroup]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemGroup"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmItem_": {"title": "CustomPage[OdmItem]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmItem"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmMethod_": {"title": "CustomPage[OdmMethod]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmMethod"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmTemplate_": {"title": "CustomPage[OdmTemplate]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmTemplate"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmXmlExtensionAttribute_": {"title": "CustomPage[OdmXmlExtensionAttribute]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionAttribute"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmXmlExtensionTag_": {"title": "CustomPage[OdmXmlExtensionTag]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionTag"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_OdmXmlExtension_": {"title": "CustomPage[OdmXmlExtension]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtension"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_RatingScale_": {"title": "CustomPage[RatingScale]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/RatingScale"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_Reminder_": {"title": "CustomPage[Reminder]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/Reminder"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_SimpleCompound_": {"title": "CustomPage[SimpleCompound]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/SimpleCompound"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_SpecialPurpose_": {"title": "CustomPage[SpecialPurpose]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/SpecialPurpose"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudyActivityInstruction_": {"title": "CustomPage[StudyActivityInstruction]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudyActivityInstruction"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudyArmListing_": {"title": "CustomPage[StudyArmListing]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudyArmListing"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudyCriterionListing_": {"title": "CustomPage[StudyCriterionListing]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudyCriterionListing"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudyElementListing_": {"title": "CustomPage[StudyElementListing]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudyElementListing"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudyEpoch_": {"title": "CustomPage[StudyEpoch]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudyEpoch"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudySelectionActivity_": {"title": "CustomPage[StudySelectionActivity]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionActivity"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudySelectionArmWithConnectedBranchArms_": {"title": "CustomPage[StudySelectionArmWithConnectedBranchArms]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionArmWithConnectedBranchArms"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudySelectionCohort_": {"title": "CustomPage[StudySelectionCohort]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCohort"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudySelectionCompound_": {"title": "CustomPage[StudySelectionCompound]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCompound"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudySelectionCriteria_": {"title": "CustomPage[StudySelectionCriteria]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCriteria"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudySelectionElement_": {"title": "CustomPage[StudySelectionElement]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionElement"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudySelectionEndpoint_": {"title": "CustomPage[StudySelectionEndpoint]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudySelectionObjective_": {"title": "CustomPage[StudySelectionObjective]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionObjective"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudySummaryListing_": {"title": "CustomPage[StudySummaryListing]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySummaryListing"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudyVisitListing_": {"title": "CustomPage[StudyVisitListing]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudyVisitListing"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_StudyVisit_": {"title": "CustomPage[StudyVisit]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudyVisit"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_Study_": {"title": "CustomPage[Study]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/Study"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_TextValue_": {"title": "CustomPage[TextValue]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/TextValue"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_TextualFinding_": {"title": "CustomPage[TextualFinding]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/TextualFinding"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_TimePoint_": {"title": "CustomPage[TimePoint]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/TimePoint"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_TimeframeTemplate_": {"title": "CustomPage[TimeframeTemplate]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/TimeframeTemplate"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_Timeframe_": {"title": "CustomPage[Timeframe]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/Timeframe"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_TopicCdDef_": {"title": "CustomPage[TopicCdDef]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/TopicCdDef"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_UnitDefinitionModel_": {"title": "CustomPage[UnitDefinitionModel]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/UnitDefinitionModel"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "CustomPage_VisitName_": {"title": "CustomPage[VisitName]", "required": ["items", "total", "page", "size"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/VisitName"}}, "total": {"title": "Total", "minimum": 0.0, "type": "integer"}, "page": {"title": "Page", "minimum": 0.0, "type": "integer"}, "size": {"title": "Size", "minimum": 0.0, "type": "integer"}}}, "DictionaryCodelist": {"title": "DictionaryCodelist", "required": ["codelistUid", "name", "templateParameter", "possibleActions", "libraryName"], "type": "object", "properties": {"codelistUid": {"title": "codelistUid", "type": "string"}, "name": {"title": "name", "type": "string"}, "templateParameter": {"title": "templateParameter", "type": "boolean"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the DictionaryCodelist. Actions are: 'approve', 'edit', 'newVersion'."}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}}}, "DictionaryCodelistCreateInput": {"title": "DictionaryCodelistCreateInput", "required": ["libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string"}, "templateParameter": {"title": "templateParameter", "type": "boolean"}, "libraryName": {"title": "Libraryname", "type": "string"}}}, "DictionaryCodelistEditInput": {"title": "DictionaryCodelistEditInput", "type": "object", "properties": {"name": {"title": "name", "type": "string"}, "templateParameter": {"title": "templateParameter", "type": "boolean"}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "DictionaryCodelistTermInput": {"title": "DictionaryCodelistTermInput", "required": ["termUid"], "type": "object", "properties": {"termUid": {"title": "termUid", "type": "string"}}}, "DictionaryCodelistVersion": {"title": "DictionaryCodelistVersion", "required": ["codelistUid", "name", "templateParameter", "possibleActions", "libraryName"], "type": "object", "properties": {"codelistUid": {"title": "codelistUid", "type": "string"}, "name": {"title": "name", "type": "string"}, "templateParameter": {"title": "templateParameter", "type": "boolean"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the DictionaryCodelist. Actions are: 'approve', 'edit', 'newVersion'."}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the objective (e.g. name, startDate, ..)."}}, "description": "Class for storing DictionaryCodelist and calculation of differences"}, "DictionaryTerm": {"title": "DictionaryTerm", "required": ["termUid", "dictionaryId", "name", "nameSentenceCase", "possibleActions", "libraryName"], "type": "object", "properties": {"termUid": {"title": "Termuid", "type": "string"}, "dictionaryId": {"title": "Dictionaryid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "Namesentencecase", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "definition": {"title": "Definition", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the DictionaryTerm. Actions are: 'approve', 'edit', 'newVersion'."}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}}}, "DictionaryTermCreateInput": {"title": "DictionaryTermCreateInput", "required": ["dictionaryId", "name", "codelistUid", "libraryName"], "type": "object", "properties": {"dictionaryId": {"title": "Dictionaryid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "Namesentencecase", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "definition": {"title": "Definition", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}}}, "DictionaryTermEditInput": {"title": "DictionaryTermEditInput", "type": "object", "properties": {"dictionaryId": {"title": "Dictionaryid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "Namesentencecase", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "definition": {"title": "Definition", "type": "string"}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "DictionaryTermSubstance": {"title": "DictionaryTermSubstance", "required": ["termUid", "dictionaryId", "name", "nameSentenceCase", "possibleActions", "libraryName"], "type": "object", "properties": {"termUid": {"title": "Termuid", "type": "string"}, "dictionaryId": {"title": "Dictionaryid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "Namesentencecase", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "definition": {"title": "Definition", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the DictionaryTerm. Actions are: 'approve', 'edit', 'newVersion'."}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "pclass": {"$ref": "#/components/schemas/SimpleDictionaryTermModel"}}}, "DictionaryTermSubstanceCreateInput": {"title": "DictionaryTermSubstanceCreateInput", "required": ["dictionaryId", "name", "codelistUid", "libraryName"], "type": "object", "properties": {"dictionaryId": {"title": "Dictionaryid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "Namesentencecase", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "definition": {"title": "Definition", "type": "string"}, "codelistUid": {"title": "codelistUid", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "pclassUid": {"title": "Pclassuid", "type": "string"}}}, "DictionaryTermSubstanceEditInput": {"title": "DictionaryTermSubstanceEditInput", "type": "object", "properties": {"dictionaryId": {"title": "Dictionaryid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "Namesentencecase", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "definition": {"title": "Definition", "type": "string"}, "changeDescription": {"title": "changeDescription", "type": "string"}, "pclassUid": {"title": "Pclassuid", "type": "string"}}}, "DictionaryTermVersion": {"title": "DictionaryTermVersion", "required": ["termUid", "dictionaryId", "name", "nameSentenceCase", "possibleActions", "libraryName"], "type": "object", "properties": {"termUid": {"title": "Termuid", "type": "string"}, "dictionaryId": {"title": "Dictionaryid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "Namesentencecase", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "definition": {"title": "Definition", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the DictionaryTerm. Actions are: 'approve', 'edit', 'newVersion'."}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the objective (e.g. name, startDate, ..)."}}, "description": "Class for storing DictionaryTerm and calculation of differences"}, "DurationJsonModel": {"title": "Duration", "type": "object", "properties": {"durationValue": {"title": "Durationvalue", "type": "integer"}, "durationUnitCode": {"$ref": "#/components/schemas/UnitDefinitionSimpleModel"}}}, "Endpoint": {"title": "Endpoint", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "namePlain": {"title": "Nameplain", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the endpoint. Actions are: 'approve', 'edit', 'inactivate', 'reactivate' and 'delete'."}, "endpointTemplate": {"$ref": "#/components/schemas/EndpointTemplateNameUid"}, "parameterValues": {"title": "Parametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values that are used within the endpoint. The values are ordered as they occur in the endpoint name."}, "library": {"$ref": "#/components/schemas/Library"}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing endpoint"}}}, "EndpointCreateInput": {"title": "EndpointCreateInput", "required": ["parameterValues", "endpointTemplateUid"], "type": "object", "properties": {"parameterValues": {"title": "parameterValues", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterMultiSelectInput"}, "description": "An ordered list of selected parameter values that are used to replace the parameters of the endpoint template."}, "endpointTemplateUid": {"title": "endpointTemplateUid", "type": "string", "description": "The unique id of the endpoint template that is used as the basis for the new endpoint."}, "nameOverride": {"title": "name", "type": "string", "description": "Optionally, a name to override the name inherited from the template."}, "libraryName": {"title": "libraryName", "type": "string", "description": "If specified: The name of the library to which the endpoint will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* endpoint can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true. \n\nIf not specified: The library of the endpoint template will be used."}}}, "EndpointEditInput": {"title": "EndpointEditInput", "required": ["parameterValues", "changeDescription"], "type": "object", "properties": {"parameterValues": {"title": "parameterValues", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterMultiSelectInput"}, "description": "An ordered list of selected parameter values that are used to replace the parameters of the endpoint template."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}}}, "EndpointTemplate": {"title": "EndpointTemplate", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) endpoint template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the endpoint template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) endpoint template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) endpoint template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the endpoint template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the endpoint template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the endpoint template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the endpoint template belongs."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "categories": {"title": "Categories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of categories the template belongs to."}, "subCategories": {"title": "Subcategories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of sub-categories the template belongs to."}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}}}, "EndpointTemplateCreateInput": {"title": "EndpointTemplateCreateInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "studyUid": {"title": "Studyuid", "type": "string", "description": "The UID of the Study in scope of which given template is being created."}, "libraryName": {"title": "Libraryname", "type": "string", "description": "If specified: The name of the library to which the endpoint template will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* endpoint can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true.", "default": "Sponsor"}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values to be used as default for this template. The values are ordered as they occur in the template name."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited. Defaults to False.", "default": false}, "indicationUids": {"title": "Indicationuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the study indications, conditions, diseases or disorders to attach the template to."}, "categoryUids": {"title": "Categoryuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the categories to attach the template to."}, "subCategoryUids": {"title": "Subcategoryuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the sub_categories to attach the template to."}}}, "EndpointTemplateEditGroupingsInput": {"title": "EndpointTemplateEditGroupingsInput", "type": "object", "properties": {"indicationUids": {"title": "Indicationuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the study indications, conditions, diseases or disorders to attach the template to."}, "categoryUids": {"title": "Categoryuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the categories to attach the template to."}, "subCategoryUids": {"title": "Subcategoryuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the sub_categories to attach the template to."}}}, "EndpointTemplateEditInput": {"title": "EndpointTemplateEditInput", "required": ["name", "changeDescription"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited. Defaults to False.", "default": false}}}, "EndpointTemplateNameInput": {"title": "EndpointTemplateNameInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}}}, "EndpointTemplateNameUid": {"title": "EndpointTemplateNameUid", "required": ["uid"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}}}, "EndpointTemplateVersion": {"title": "EndpointTemplateVersion", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) endpoint template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the endpoint template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) endpoint template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) endpoint template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the endpoint template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the endpoint template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the endpoint template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the endpoint template belongs."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "categories": {"title": "Categories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of categories the template belongs to."}, "subCategories": {"title": "Subcategories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of sub-categories the template belongs to."}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the endpoint template (e.g. name, startDate, ..)."}}}, "EndpointTemplateWithCount": {"title": "EndpointTemplateWithCount", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the endpoint template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) endpoint template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the endpoint template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) endpoint template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) endpoint template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the endpoint template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the endpoint template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the endpoint template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the endpoint template belongs."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "categories": {"title": "Categories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of categories the template belongs to."}, "subCategories": {"title": "Subcategories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of sub-categories the template belongs to."}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}, "counts": {"title": "Counts", "allOf": [{"$ref": "#/components/schemas/ItemCounts"}], "description": "Optional counts of objective instatiations"}}}, "EndpointUnits": {"title": "EndpointUnits", "required": ["units"], "type": "object", "properties": {"units": {"title": "units", "type": "array", "items": {"type": "string"}, "description": "the endpoint units selected for the study endpoint"}, "separator": {"title": "separator", "type": "string", "description": "the endpoint units selected for the study endpoint"}}}, "EndpointVersion": {"title": "EndpointVersion", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "namePlain": {"title": "Nameplain", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the endpoint. Actions are: 'approve', 'edit', 'inactivate', 'reactivate' and 'delete'."}, "endpointTemplate": {"$ref": "#/components/schemas/EndpointTemplateNameUid"}, "parameterValues": {"title": "Parametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values that are used within the endpoint. The values are ordered as they occur in the endpoint name."}, "library": {"$ref": "#/components/schemas/Library"}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing endpoint"}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the endpoint (e.g. name, startDate, ..)."}}}, "ErrorResponse": {"title": "ErrorResponse", "required": ["type", "message", "time", "path", "method"], "type": "object", "properties": {"type": {"title": "Type", "type": "string", "description": "Exception class."}, "message": {"title": "Message", "type": "string", "description": "More information about the error."}, "time": {"title": "Time", "type": "string", "description": "The point in time when the error occurred.", "format": "date-time"}, "path": {"title": "Path", "type": "string", "description": "The url/path of the request."}, "method": {"title": "Method", "type": "string", "description": "The HTTP method of the request."}}}, "Event": {"title": "Event", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "topicCode", "adamParamCode", "sdtmVariable", "sdtmSubcat", "sdtmCat", "sdtmDomain", "activities", "activitySubgroups", "activityGroups", "specimen"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "type": {"title": "type", "type": "string", "description": "The subtype of ActivityInstance"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmSubcat": {"title": "sdtmSubcat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmCat": {"title": "sdtmCat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmDomain": {"title": "sdtmDomain", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "activities": {"title": "activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity unique identifiers"}, "activitySubgroups": {"title": "activitySubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity sub group unique identifiers"}, "activityGroups": {"title": "activityGroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity group unique identifiers"}, "specimen": {"title": "specimen", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}}}, "EventCreateInput": {"title": "EventCreateInput", "required": ["name", "libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}}}, "EventEditInput": {"title": "EventEditInput", "required": ["changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "specimen": {"title": "specimen", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "GenericFilteringReturn_StudyCompoundDosing_": {"title": "GenericFilteringReturn[StudyCompoundDosing]", "required": ["items", "total_count"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudyCompoundDosing"}}, "total_count": {"title": "Total Count", "minimum": 0.0, "type": "integer"}}}, "GenericFilteringReturn_StudySelectionCompound_": {"title": "GenericFilteringReturn[StudySelectionCompound]", "required": ["items", "total_count"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionCompound"}}, "total_count": {"title": "Total Count", "minimum": 0.0, "type": "integer"}}}, "GenericFilteringReturn_StudySelectionEndpoint_": {"title": "GenericFilteringReturn[StudySelectionEndpoint]", "required": ["items", "total_count"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionEndpoint"}}, "total_count": {"title": "Total Count", "minimum": 0.0, "type": "integer"}}}, "GenericFilteringReturn_StudySelectionObjective_": {"title": "GenericFilteringReturn[StudySelectionObjective]", "required": ["items", "total_count"], "type": "object", "properties": {"items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionObjective"}}, "total_count": {"title": "Total Count", "minimum": 0.0, "type": "integer"}}}, "HTTPValidationError": {"title": "HTTPValidationError", "type": "object", "properties": {"detail": {"title": "Detail", "type": "array", "items": {"$ref": "#/components/schemas/ValidationError"}}}}, "HighLevelStudyDesignJsonModel": {"title": "HighLevelStudyDesign", "type": "object", "properties": {"studyTypeCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "studyTypeNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "trialTypesCodes": {"title": "Trialtypescodes", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "trialTypesNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "trialPhaseCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "trialPhaseNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "isExtensionTrial": {"title": "Isextensiontrial", "type": "boolean"}, "isExtensionTrialNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "isAdaptiveDesign": {"title": "Isadaptivedesign", "type": "boolean"}, "isAdaptiveDesignNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "studyStopRules": {"title": "Studystoprules", "type": "string"}, "studyStopRulesNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "confirmedResponseMinimumDuration": {"$ref": "#/components/schemas/DurationJsonModel"}, "confirmedResponseMinimumDurationNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "postAuthIndicator": {"title": "Postauthindicator", "type": "boolean"}, "postAuthIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}}}, "IndexedTemplateParameterValue": {"title": "IndexedTemplateParameterValue", "required": ["uid", "name", "type", "index"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string", "description": "The unique id of the template parameter value."}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Lipids', 'Haematology', 'Body Temperature', ..."}, "type": {"title": "type", "type": "string", "description": "the type of template parameter, E.g. 'NumericFinding', 'CategoricFinding'"}, "index": {"title": "index", "type": "integer", "description": "The index of the template parameter value in the given template position."}}}, "ItemCounts": {"title": "ItemCounts", "type": "object", "properties": {"total": {"title": "Total", "type": "integer", "description": "Total count of instantiations", "default": 0}, "draft": {"title": "Draft", "type": "integer", "description": "Count of instantiations in draft status", "default": 0}, "retired": {"title": "Retired", "type": "integer", "description": "Count of instantiations in retired status", "default": 0}, "final": {"title": "Final", "type": "integer", "description": "Count of instantiations in final status", "default": 0}}, "description": "Model used for expressing counts of instantiations of objective, endpoint etc.\ntemplates."}, "LaboratoryActivity": {"title": "LaboratoryActivity", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "topicCode", "adamParamCode", "sdtmVariable", "sdtmSubcat", "sdtmCat", "sdtmDomain", "activities", "activitySubgroups", "activityGroups"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "type": {"title": "type", "type": "string", "description": "The subtype of ActivityInstance"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmSubcat": {"title": "sdtmSubcat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmCat": {"title": "sdtmCat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmDomain": {"title": "sdtmDomain", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "activities": {"title": "activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity unique identifiers"}, "activitySubgroups": {"title": "activitySubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity sub group unique identifiers"}, "activityGroups": {"title": "activityGroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity group unique identifiers"}, "specimen": {"$ref": "#/components/schemas/SimpleTermModel"}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "testCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "categoricResponseValue": {"$ref": "#/components/schemas/SimpleTermModel"}, "categoricResponseList": {"$ref": "#/components/schemas/SimpleTermModel"}}}, "LaboratoryActivityCreateInput": {"title": "LaboratoryActivityCreateInput", "required": ["name", "libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "specimen": {"title": "Specimen", "type": "string"}, "testCode": {"title": "Testcode", "type": "string"}, "categoricResponseValue": {"title": "Categoricresponsevalue", "type": "string"}, "categoricResponseList": {"title": "Categoricresponselist", "type": "string"}}}, "LaboratoryActivityEditInput": {"title": "LaboratoryActivityEditInput", "required": ["changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "specimen": {"title": "Specimen", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "changeDescription": {"title": "changeDescription", "type": "string"}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "testCode": {"title": "Testcode", "type": "string"}, "categoricResponseValue": {"title": "Categoricresponsevalue", "type": "string"}, "categoricResponseList": {"title": "Categoricresponselist", "type": "string"}}}, "LagTime": {"title": "LagTime", "required": ["uid", "name", "libraryName", "templateParameter", "value", "unitDefinitionUid", "sdtmDomainUid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean"}, "value": {"title": "Value", "type": "number"}, "unitDefinitionUid": {"title": "Unitdefinitionuid", "type": "string"}, "sdtmDomainUid": {"title": "Sdtmdomainuid", "type": "string"}}}, "LagTimeInput": {"title": "LagTimeInput", "required": ["value", "unitDefinitionUid", "sdtmDomainUid"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean", "default": false}, "value": {"title": "Value", "type": "number"}, "unitDefinitionUid": {"title": "Unitdefinitionuid", "type": "string"}, "sdtmDomainUid": {"title": "Sdtmdomainuid", "type": "string"}}}, "Library": {"title": "Library", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The name of the library and at the same time the unique identifier for a library entity."}, "isEditable": {"title": "Iseditable", "type": "boolean", "description": "Denotes whether or not the library allows to \n\n* create new entities (e.g. objective templates, objectives, ...) and \n* change existing entities."}}}, "MetaData": {"title": "MetaData", "type": "object", "properties": {"dataset_name": {"title": "dataset_name", "type": "string", "description": "name of dataset"}, "dataset_label": {"title": "dataset_label", "type": "string", "description": "label of dataset"}, "name": {"title": "name", "type": "string", "description": "name of variable"}, "type": {"title": "type", "type": "string", "description": "type of variable"}, "length": {"title": "length", "type": "number", "description": "length of variable"}, "label": {"title": "label", "type": "string", "description": "label of variable"}, "format": {"title": "format", "type": "string", "description": "SAS format of variable"}, "informat": {"title": "informat", "type": "string", "description": "SAS informat of variable"}}}, "MultiTemplateParameterValue": {"title": "MultiTemplateParameterValue", "required": ["position", "conjunction", "values"], "type": "object", "properties": {"position": {"title": "position", "type": "integer", "description": "The position in the template that the template parameter is in."}, "conjunction": {"title": "conjunction", "type": "string", "description": "If the selected template parameter value has multiple values, the conjunction string to connect them. Available values are ['and', 'or', ',']."}, "values": {"title": "values", "type": "array", "items": {"$ref": "#/components/schemas/IndexedTemplateParameterValue"}, "description": "A list of indexed template parameter values that are used at this position in the template."}}, "description": "A MultiTemplateParameterValue provides a way to select a list of template parameter values for a\ngiven position in a template.\n\nGiven the template \"To evaluate [Activity]\", and the value \"To evaluate [Activity X and Activity Y]\",\nan example value for a MultiTemplateParameterValue is:\n{\n    position: 1,\n    conjunction: 'and',\n    values: [\n         {index: 1, name: \"Activity_0001\", uid: \"39040243\"},\n         {index: 2, name: \"Activity_0002\", uid: \"32210211\"}\n    ]\n}"}, "NumericFinding": {"title": "NumericFinding", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "topicCode", "adamParamCode", "sdtmVariable", "sdtmSubcat", "sdtmCat", "sdtmDomain", "activities", "activitySubgroups", "activityGroups"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "type": {"title": "type", "type": "string", "description": "The subtype of ActivityInstance"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmSubcat": {"title": "sdtmSubcat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmCat": {"title": "sdtmCat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmDomain": {"title": "sdtmDomain", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "activities": {"title": "activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity unique identifiers"}, "activitySubgroups": {"title": "activitySubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity sub group unique identifiers"}, "activityGroups": {"title": "activityGroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity group unique identifiers"}, "specimen": {"$ref": "#/components/schemas/SimpleTermModel"}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "testCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "molecularWeight": {"title": "Molecularweight", "type": "integer"}, "convertToSiUnit": {"title": "Converttosiunit", "type": "boolean"}, "convertToUsConventionalUnit": {"title": "Converttousconventionalunit", "type": "boolean"}, "unitDimension": {"$ref": "#/components/schemas/SimpleTermModel"}, "unitDefinition": {"$ref": "#/components/schemas/SimpleTermModel"}}}, "NumericFindingCreateInput": {"title": "NumericFindingCreateInput", "required": ["name", "libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "specimen": {"title": "Specimen", "type": "string"}, "testCode": {"title": "Testcode", "type": "string"}, "molecularWeight": {"title": "Molecularweight", "type": "integer"}, "convertToSiUnit": {"title": "Converttosiunit", "type": "boolean"}, "convertToUsConventionalUnit": {"title": "Converttousconventionalunit", "type": "boolean"}, "unitDimension": {"title": "Unitdimension", "type": "string"}, "unitDefinition": {"title": "Unitdefinition", "type": "string"}}}, "NumericFindingEditInput": {"title": "NumericFindingEditInput", "required": ["changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "specimen": {"title": "Specimen", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "changeDescription": {"title": "changeDescription", "type": "string"}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "testCode": {"title": "Testcode", "type": "string"}, "molecularWeight": {"title": "Molecularweight", "type": "integer"}, "convertToSiUnit": {"title": "Converttosiunit", "type": "boolean"}, "convertToUsConventionalUnit": {"title": "Converttousconventionalunit", "type": "boolean"}, "unitDimension": {"title": "Unitdimension", "type": "string"}, "unitDefinition": {"title": "Unitdefinition", "type": "string"}}}, "NumericValue": {"title": "NumericValue", "required": ["uid", "name", "libraryName", "templateParameter", "value"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean"}, "value": {"title": "Value", "type": "number"}}}, "NumericValueInput": {"title": "NumericValueInput", "required": ["value"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean", "default": false}, "value": {"title": "Value", "type": "number"}}}, "NumericValueWithUnit": {"title": "NumericValueWithUnit", "required": ["uid", "name", "libraryName", "templateParameter", "value", "unitDefinitionUid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean"}, "value": {"title": "Value", "type": "number"}, "unitDefinitionUid": {"title": "Unitdefinitionuid", "type": "string"}}}, "NumericValueWithUnitInput": {"title": "NumericValueWithUnitInput", "required": ["value", "unitDefinitionUid"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean", "default": false}, "value": {"title": "Value", "type": "number"}, "unitDefinitionUid": {"title": "Unitdefinitionuid", "type": "string"}}}, "Objective": {"title": "Objective", "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "namePlain": {"title": "Nameplain", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the objective. Actions are: 'approve', 'edit', 'inactivate', 'reactivate' and 'delete'."}, "objectiveTemplate": {"$ref": "#/components/schemas/ObjectiveTemplateNameUid"}, "parameterValues": {"title": "Parametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values that are used within the objective. The values are ordered as they occur in the objective name."}, "library": {"$ref": "#/components/schemas/Library"}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing objective"}}}, "ObjectiveCreateInput": {"title": "ObjectiveCreateInput", "required": ["objectiveTemplateUid"], "type": "object", "properties": {"parameterValues": {"title": "parameterValues", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterMultiSelectInput"}, "description": "An ordered list of selected parameter values that are used to replace the parameters of the objective template."}, "objectiveTemplateUid": {"title": "objectiveTemplateUid", "type": "string", "description": "The unique id of the objective template that is used as the basis for the new objective."}, "nameOverride": {"title": "name", "type": "string", "description": "Optionally, a name to override the name inherited from the template."}, "libraryName": {"title": "libraryName", "type": "string", "description": "If specified: The name of the library to which the objective will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* endpoint can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true. \n\nIf not specified: The library of the objective template will be used."}}}, "ObjectiveEditInput": {"title": "ObjectiveEditInput", "required": ["changeDescription"], "type": "object", "properties": {"parameterValues": {"title": "parameterValues", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterMultiSelectInput"}, "description": "An ordered list of selected parameter values that are used to replace the parameters of the objective template."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}}}, "ObjectiveTemplate": {"title": "ObjectiveTemplate", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) objective template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the objective template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) objective template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) objective template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the objective template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the objective template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the objective template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the objective template belongs."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "confirmatoryTesting": {"title": "Confirmatorytesting", "type": "boolean", "description": "Indicates if template is related to confirmatory testing."}, "categories": {"title": "Categories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of categories the template belongs to."}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}}}, "ObjectiveTemplateCreateInput": {"title": "ObjectiveTemplateCreateInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "studyUid": {"title": "Studyuid", "type": "string", "description": "The UID of the Study in scope of which given template is being created."}, "libraryName": {"title": "Libraryname", "type": "string", "description": "If specified: The name of the library to which the objective template will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* endpoint can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true.", "default": "Sponsor"}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values to be used as default for this\n        template. The values are ordered as they occur in the template name. \nThese default parameter values will be created as set#0."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited. Defaults to False.", "default": false}, "indicationUids": {"title": "Indicationuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the study indications, conditions, diseases or disorders to attach the template to."}, "confirmatoryTesting": {"title": "Confirmatorytesting", "type": "boolean", "description": "Indicates if template is related to confirmatory testing."}, "categoryUids": {"title": "Categoryuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the categories to attach the template to."}}}, "ObjectiveTemplateEditGroupingsInput": {"title": "ObjectiveTemplateEditGroupingsInput", "type": "object", "properties": {"indicationUids": {"title": "Indicationuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the study indications, conditions, diseases or disorders to attach the template to."}, "categoryUids": {"title": "Categoryuids", "type": "array", "items": {"type": "string"}, "description": "A list of UID of the categories to attach the template to."}, "confirmatoryTesting": {"title": "Confirmatorytesting", "type": "boolean", "description": "Indicates if template is related to confirmatory testing."}}}, "ObjectiveTemplateEditInput": {"title": "ObjectiveTemplateEditInput", "required": ["name", "changeDescription"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}}}, "ObjectiveTemplateNameInput": {"title": "ObjectiveTemplateNameInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}}}, "ObjectiveTemplateNameUid": {"title": "ObjectiveTemplateNameUid", "required": ["uid"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}}}, "ObjectiveTemplateVersion": {"title": "ObjectiveTemplateVersion", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) objective template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the objective template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) objective template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) objective template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the objective template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the objective template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the objective template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the objective template belongs."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "confirmatoryTesting": {"title": "Confirmatorytesting", "type": "boolean", "description": "Indicates if template is related to confirmatory testing."}, "categories": {"title": "Categories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of categories the template belongs to."}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the objective template (e.g. name, startDate, ..)."}}, "description": "Class for storing Objective Templates and calculation of differences"}, "ObjectiveTemplateWithCount": {"title": "ObjectiveTemplateWithCount", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the objective template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "Part of the metadata: The point in time when the (version of the) objective template was created. The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the objective template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) objective template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) objective template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the objective template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the objective template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the objective template."}, "defaultParameterValues": {"title": "Defaultparametervalues", "type": "object", "additionalProperties": {"type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}}, "description": "Holds the default values for the parameters that are used\n        within the template. The values are ordered as they occur in the template's name."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the objective template belongs."}, "indications": {"title": "Indications", "type": "array", "items": {"$ref": "#/components/schemas/DictionaryTerm"}, "description": "The study indications, conditions, diseases or disorders in scope for the template."}, "confirmatoryTesting": {"title": "Confirmatorytesting", "type": "boolean", "description": "Indicates if template is related to confirmatory testing."}, "categories": {"title": "Categories", "type": "array", "items": {"$ref": "#/components/schemas/CTTermNameAndAttributes"}, "description": "A list of categories the template belongs to."}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing template"}, "counts": {"title": "Counts", "allOf": [{"$ref": "#/components/schemas/ItemCounts"}], "description": "Optional counts of objective instatiations"}}}, "ObjectiveVersion": {"title": "ObjectiveVersion", "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "namePlain": {"title": "Nameplain", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the objective. Actions are: 'approve', 'edit', 'inactivate', 'reactivate' and 'delete'."}, "objectiveTemplate": {"$ref": "#/components/schemas/ObjectiveTemplateNameUid"}, "parameterValues": {"title": "Parametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values that are used within the objective. The values are ordered as they occur in the objective name."}, "library": {"$ref": "#/components/schemas/Library"}, "studyCount": {"title": "Studycount", "type": "integer", "description": "Count of studies referencing objective"}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the objective (e.g. name, startDate, ..)."}}, "description": "Class for storing Objectives and calculation of differences"}, "OdmAlias": {"title": "OdmAlias", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "context", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "context": {"title": "Context", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmAliasBatchInput": {"title": "OdmAliasBatchInput", "required": ["method", "content"], "type": "object", "properties": {"method": {"title": "method", "type": "string", "description": "HTTP method corresponding to operation type"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/OdmAliasBatchPatchInput"}, {"$ref": "#/components/schemas/OdmAliasPostInput"}]}}}, "OdmAliasBatchOutput": {"title": "OdmAliasBatchOutput", "required": ["responseCode"], "type": "object", "properties": {"responseCode": {"title": "responseCode", "type": "integer", "description": "The HTTP response code related to input operation"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/OdmAlias"}, {"$ref": "#/components/schemas/BatchErrorResponse"}]}}}, "OdmAliasBatchPatchInput": {"title": "OdmAliasBatchPatchInput", "required": ["changeDescription", "uid"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "context": {"title": "Context", "type": "string"}, "uid": {"title": "Uid", "type": "string"}}}, "OdmAliasPatchInput": {"title": "OdmAliasPatchInput", "required": ["changeDescription"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "context": {"title": "Context", "type": "string"}}}, "OdmAliasPostInput": {"title": "OdmAliasPostInput", "required": ["name", "context"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "context": {"title": "Context", "type": "string"}}}, "OdmAliasSimpleModel": {"title": "OdmAliasSimpleModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}, "context": {"title": "context", "type": "string"}, "version": {"title": "version", "type": "string"}}}, "OdmCondition": {"title": "OdmCondition", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "descriptions", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "formalExpressions": {"title": "Formalexpressions", "type": "array", "items": {"$ref": "#/components/schemas/OdmFormalExpressionSimpleModel"}}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"$ref": "#/components/schemas/OdmDescriptionSimpleModel"}}, "aliases": {"title": "Aliases", "type": "array", "items": {"$ref": "#/components/schemas/OdmAliasSimpleModel"}}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmConditionPatchInput": {"title": "OdmConditionPatchInput", "required": ["changeDescription", "formalExpressionUids", "descriptionUids", "aliasUids"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "formalExpressionUids": {"title": "Formalexpressionuids", "type": "array", "items": {"type": "string"}}, "descriptionUids": {"title": "Descriptionuids", "type": "array", "items": {"type": "string"}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmConditionPostInput": {"title": "OdmConditionPostInput", "required": ["name", "formalExpressionUids", "descriptionUids", "aliasUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "formalExpressionUids": {"title": "Formalexpressionuids", "type": "array", "items": {"type": "string"}}, "descriptionUids": {"title": "Descriptionuids", "type": "array", "items": {"type": "string"}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmConditionWithRelationsPatchInput": {"title": "OdmConditionWithRelationsPatchInput", "required": ["changeDescription", "formalExpressions", "descriptions", "aliasUids"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "formalExpressions": {"title": "Formalexpressions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmFormalExpressionBatchPatchInput"}, {"$ref": "#/components/schemas/OdmFormalExpressionPostInput"}]}}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmDescriptionBatchPatchInput"}, {"$ref": "#/components/schemas/OdmDescriptionPostInput"}]}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmConditionWithRelationsPostInput": {"title": "OdmConditionWithRelationsPostInput", "required": ["name", "formalExpressions", "descriptions", "aliasUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "formalExpressions": {"title": "Formalexpressions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmFormalExpressionPostInput"}, {"type": "string"}]}}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmDescriptionPostInput"}, {"type": "string"}]}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmDescription": {"title": "OdmDescription", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "language", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "language": {"title": "Language", "type": "string"}, "description": {"title": "Description", "type": "string"}, "instruction": {"title": "Instruction", "type": "string"}, "sponsorInstruction": {"title": "Sponsorinstruction", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmDescriptionBatchInput": {"title": "OdmDescriptionBatchInput", "required": ["method", "content"], "type": "object", "properties": {"method": {"title": "method", "type": "string", "description": "HTTP method corresponding to operation type"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/OdmDescriptionBatchPatchInput"}, {"$ref": "#/components/schemas/OdmDescriptionPostInput"}]}}}, "OdmDescriptionBatchOutput": {"title": "OdmDescriptionBatchOutput", "required": ["responseCode"], "type": "object", "properties": {"responseCode": {"title": "responseCode", "type": "integer", "description": "The HTTP response code related to input operation"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/OdmDescription"}, {"$ref": "#/components/schemas/BatchErrorResponse"}]}}}, "OdmDescriptionBatchPatchInput": {"title": "OdmDescriptionBatchPatchInput", "required": ["changeDescription", "uid"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "language": {"title": "Language", "type": "string"}, "description": {"title": "Description", "type": "string"}, "instruction": {"title": "Instruction", "type": "string"}, "sponsorInstruction": {"title": "Sponsorinstruction", "type": "string"}, "uid": {"title": "Uid", "type": "string"}}}, "OdmDescriptionPatchInput": {"title": "OdmDescriptionPatchInput", "required": ["changeDescription"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "language": {"title": "Language", "type": "string"}, "description": {"title": "Description", "type": "string"}, "instruction": {"title": "Instruction", "type": "string"}, "sponsorInstruction": {"title": "Sponsorinstruction", "type": "string"}}}, "OdmDescriptionPostInput": {"title": "OdmDescriptionPostInput", "required": ["name", "language"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "language": {"title": "Language", "type": "string"}, "description": {"title": "Description", "type": "string"}, "instruction": {"title": "Instruction", "type": "string"}, "sponsorInstruction": {"title": "Sponsorinstruction", "type": "string"}}}, "OdmDescriptionSimpleModel": {"title": "OdmDescriptionSimpleModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}, "language": {"title": "language", "type": "string"}, "description": {"title": "description", "type": "string"}, "instruction": {"title": "instruction", "type": "string"}, "sponsorInstruction": {"title": "sponsorInstruction", "type": "string"}, "version": {"title": "version", "type": "string"}}}, "OdmExportTo": {"title": "OdmExportTo", "enum": ["v1", "v2", "clinspark"], "description": "\n    Enum for systems that import ODM XML exported by StudyBuilder\n    "}, "OdmForm": {"title": "OdmForm", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "descriptions", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "repeating": {"title": "Repeating", "type": "string"}, "sdtmVersion": {"title": "Sdtmversion", "type": "string"}, "scope": {"$ref": "#/components/schemas/SimpleCTTermAttributes"}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"$ref": "#/components/schemas/OdmDescriptionSimpleModel"}}, "aliases": {"title": "Aliases", "type": "array", "items": {"$ref": "#/components/schemas/OdmAliasSimpleModel"}}, "activityGroups": {"title": "Activitygroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}}, "itemGroups": {"title": "Itemgroups", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemGroupRefModel"}}, "xmlExtensionTags": {"title": "Xmlextensiontags", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionTagRelationModel"}}, "xmlExtensionAttributes": {"title": "Xmlextensionattributes", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionAttributeRelationModel"}}, "xmlExtensionTagAttributes": {"title": "Xmlextensiontagattributes", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionTagAttributeRelationModel"}}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmFormActivityGroupPostInput": {"title": "OdmFormActivityGroupPostInput", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}}}, "OdmFormItemGroupPostInput": {"title": "OdmFormItemGroupPostInput", "required": ["uid", "orderNumber", "mandatory"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "orderNumber": {"title": "Ordernumber", "type": "integer"}, "mandatory": {"title": "Mandatory", "type": "string"}, "locked": {"title": "Locked", "type": "string", "default": "No"}, "collectionExceptionConditionOid": {"title": "Collectionexceptionconditionoid", "type": "string"}}}, "OdmFormPatchInput": {"title": "OdmFormPatchInput", "required": ["changeDescription", "descriptionUids", "aliasUids"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "sdtmVersion": {"title": "Sdtmversion", "type": "string"}, "repeating": {"title": "Repeating", "type": "string"}, "scopeUid": {"title": "Scopeuid", "type": "string"}, "descriptionUids": {"title": "Descriptionuids", "type": "array", "items": {"type": "string"}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmFormPostInput": {"title": "OdmFormPostInput", "required": ["name", "repeating", "descriptionUids", "aliasUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "sdtmVersion": {"title": "Sdtmversion", "type": "string"}, "repeating": {"title": "Repeating", "type": "string"}, "scopeUid": {"title": "Scopeuid", "type": "string"}, "descriptionUids": {"title": "Descriptionuids", "type": "array", "items": {"type": "string"}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmFormRefModel": {"title": "OdmFormRefModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}, "orderNumber": {"title": "orderNumber", "type": "integer"}, "mandatory": {"title": "mandatory", "type": "string"}, "locked": {"title": "locked", "type": "string"}, "collectionExceptionConditionOid": {"title": "collectionExceptionConditionOid", "type": "string"}}}, "OdmFormWithRelationsPatchInput": {"title": "OdmFormWithRelationsPatchInput", "required": ["changeDescription", "descriptions", "aliasUids"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "sdtmVersion": {"title": "Sdtmversion", "type": "string"}, "repeating": {"title": "Repeating", "type": "string"}, "scopeUid": {"title": "Scopeuid", "type": "string"}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmDescriptionBatchPatchInput"}, {"$ref": "#/components/schemas/OdmDescriptionPostInput"}]}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmFormWithRelationsPostInput": {"title": "OdmFormWithRelationsPostInput", "required": ["name", "repeating", "descriptions", "aliasUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "sdtmVersion": {"title": "Sdtmversion", "type": "string"}, "repeating": {"title": "Repeating", "type": "string"}, "scopeUid": {"title": "Scopeuid", "type": "string"}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmDescriptionPostInput"}, {"type": "string"}]}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmFormalExpression": {"title": "OdmFormalExpression", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "libraryName", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "context": {"title": "Context", "type": "string"}, "expression": {"title": "Expression", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmFormalExpressionBatchPatchInput": {"title": "OdmFormalExpressionBatchPatchInput", "required": ["changeDescription", "uid"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "context": {"title": "Context", "type": "string"}, "expression": {"title": "Expression", "type": "string"}, "uid": {"title": "Uid", "type": "string"}}}, "OdmFormalExpressionPatchInput": {"title": "OdmFormalExpressionPatchInput", "required": ["changeDescription"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "context": {"title": "Context", "type": "string"}, "expression": {"title": "Expression", "type": "string"}}}, "OdmFormalExpressionPostInput": {"title": "OdmFormalExpressionPostInput", "required": ["context", "expression"], "type": "object", "properties": {"libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "context": {"title": "Context", "type": "string"}, "expression": {"title": "Expression", "type": "string"}}}, "OdmFormalExpressionSimpleModel": {"title": "OdmFormalExpressionSimpleModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "context": {"title": "context", "type": "string"}, "expression": {"title": "expression", "type": "string"}, "version": {"title": "version", "type": "string"}}}, "OdmItem": {"title": "OdmItem", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "prompt": {"title": "Prompt", "type": "string"}, "datatype": {"title": "Datatype", "type": "string"}, "length": {"title": "Length", "type": "integer"}, "significantDigits": {"title": "Significantdigits", "type": "integer"}, "sasFieldName": {"title": "Sasfieldname", "type": "string"}, "sdsVarName": {"title": "Sdsvarname", "type": "string"}, "origin": {"title": "Origin", "type": "string"}, "comment": {"title": "Comment", "type": "string"}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"$ref": "#/components/schemas/OdmDescriptionSimpleModel"}}, "aliases": {"title": "Aliases", "type": "array", "items": {"$ref": "#/components/schemas/OdmAliasSimpleModel"}}, "unitDefinitions": {"title": "Unitdefinitions", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemUnitDefinitionWithRelationship"}}, "codelist": {"$ref": "#/components/schemas/CTCodelistAttributesSimpleModel"}, "terms": {"title": "Terms", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemTermRelationshipModel"}}, "activities": {"title": "Activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}}, "xmlExtensionTags": {"title": "Xmlextensiontags", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionTagRelationModel"}}, "xmlExtensionAttributes": {"title": "Xmlextensionattributes", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionAttributeRelationModel"}}, "xmlExtensionTagAttributes": {"title": "Xmlextensiontagattributes", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionTagAttributeRelationModel"}}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmItemActivityPostInput": {"title": "OdmItemActivityPostInput", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}}}, "OdmItemGroup": {"title": "OdmItemGroup", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "repeating": {"title": "Repeating", "type": "string"}, "isReferenceData": {"title": "Isreferencedata", "type": "string"}, "sasDatasetName": {"title": "Sasdatasetname", "type": "string"}, "origin": {"title": "Origin", "type": "string"}, "purpose": {"title": "Purpose", "type": "string"}, "comment": {"title": "Comment", "type": "string"}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"$ref": "#/components/schemas/OdmDescriptionSimpleModel"}}, "aliases": {"title": "Aliases", "type": "array", "items": {"$ref": "#/components/schemas/OdmAliasSimpleModel"}}, "sdtmDomains": {"title": "Sdtmdomains", "type": "array", "items": {"$ref": "#/components/schemas/SimpleCTTermAttributes"}}, "activitySubGroups": {"title": "Activitysubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}}, "items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemRefModel"}}, "xmlExtensionTags": {"title": "Xmlextensiontags", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionTagRelationModel"}}, "xmlExtensionAttributes": {"title": "Xmlextensionattributes", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionAttributeRelationModel"}}, "xmlExtensionTagAttributes": {"title": "Xmlextensiontagattributes", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionTagAttributeRelationModel"}}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmItemGroupActivitySubGroupPostInput": {"title": "OdmItemGroupActivitySubGroupPostInput", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}}}, "OdmItemGroupItemPostInput": {"title": "OdmItemGroupItemPostInput", "required": ["uid", "orderNumber", "mandatory", "dataEntryRequired", "sdv", "keySequence", "methodOid", "imputationMethodOid", "role", "roleCodelistOid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "orderNumber": {"title": "Ordernumber", "type": "integer"}, "mandatory": {"title": "Mandatory", "type": "string"}, "dataEntryRequired": {"title": "Dataentryrequired", "type": "string"}, "sdv": {"title": "Sdv", "type": "string"}, "locked": {"title": "Locked", "type": "string", "default": "No"}, "keySequence": {"title": "Keysequence", "type": "string"}, "methodOid": {"title": "Methodoid", "type": "string"}, "imputationMethodOid": {"title": "Imputationmethodoid", "type": "string"}, "role": {"title": "Role", "type": "string"}, "roleCodelistOid": {"title": "Rolecodelistoid", "type": "string"}, "collectionExceptionConditionOid": {"title": "Collectionexceptionconditionoid", "type": "string"}}}, "OdmItemGroupPatchInput": {"title": "OdmItemGroupPatchInput", "required": ["changeDescription", "descriptionUids", "aliasUids", "sdtmDomainUids"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "repeating": {"title": "Repeating", "type": "string"}, "isReferenceData": {"title": "Isreferencedata", "type": "string"}, "sasDatasetName": {"title": "Sasdatasetname", "type": "string"}, "origin": {"title": "Origin", "type": "string"}, "purpose": {"title": "Purpose", "type": "string"}, "comment": {"title": "Comment", "type": "string"}, "descriptionUids": {"title": "Descriptionuids", "type": "array", "items": {"type": "string"}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}, "sdtmDomainUids": {"title": "Sdtmdomainuids", "type": "array", "items": {"type": "string"}}}}, "OdmItemGroupPostInput": {"title": "OdmItemGroupPostInput", "required": ["name", "repeating", "descriptionUids", "aliasUids", "sdtmDomainUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "repeating": {"title": "Repeating", "type": "string"}, "isReferenceData": {"title": "Isreferencedata", "type": "string"}, "sasDatasetName": {"title": "Sasdatasetname", "type": "string"}, "origin": {"title": "Origin", "type": "string"}, "purpose": {"title": "Purpose", "type": "string"}, "comment": {"title": "Comment", "type": "string"}, "descriptionUids": {"title": "Descriptionuids", "type": "array", "items": {"type": "string"}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}, "sdtmDomainUids": {"title": "Sdtmdomainuids", "type": "array", "items": {"type": "string"}}}}, "OdmItemGroupRefModel": {"title": "OdmItemGroupRefModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "oid": {"title": "oid", "type": "string"}, "name": {"title": "name", "type": "string"}, "orderNumber": {"title": "orderNumber", "type": "integer"}, "mandatory": {"title": "mandatory", "type": "string"}, "locked": {"title": "locked", "type": "string"}, "collectionExceptionConditionOid": {"title": "collectionExceptionConditionOid", "type": "string"}}}, "OdmItemGroupWithRelationsPatchInput": {"title": "OdmItemGroupWithRelationsPatchInput", "required": ["changeDescription", "descriptions", "aliasUids", "sdtmDomainUids"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "repeating": {"title": "Repeating", "type": "string"}, "isReferenceData": {"title": "Isreferencedata", "type": "string"}, "sasDatasetName": {"title": "Sasdatasetname", "type": "string"}, "origin": {"title": "Origin", "type": "string"}, "purpose": {"title": "Purpose", "type": "string"}, "comment": {"title": "Comment", "type": "string"}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmDescriptionBatchPatchInput"}, {"$ref": "#/components/schemas/OdmDescriptionPostInput"}]}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}, "sdtmDomainUids": {"title": "Sdtmdomainuids", "type": "array", "items": {"type": "string"}}}}, "OdmItemGroupWithRelationsPostInput": {"title": "OdmItemGroupWithRelationsPostInput", "required": ["name", "repeating", "descriptions", "aliasUids", "sdtmDomainUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "repeating": {"title": "Repeating", "type": "string"}, "isReferenceData": {"title": "Isreferencedata", "type": "string"}, "sasDatasetName": {"title": "Sasdatasetname", "type": "string"}, "origin": {"title": "Origin", "type": "string"}, "purpose": {"title": "Purpose", "type": "string"}, "comment": {"title": "Comment", "type": "string"}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmDescriptionPostInput"}, {"type": "string"}]}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}, "sdtmDomainUids": {"title": "Sdtmdomainuids", "type": "array", "items": {"type": "string"}}}}, "OdmItemPatchInput": {"title": "OdmItemPatchInput", "required": ["changeDescription", "descriptionUids", "aliasUids", "unitDefinitions", "terms"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "prompt": {"title": "Prompt", "type": "string"}, "datatype": {"title": "Datatype", "type": "string"}, "length": {"title": "Length", "type": "integer"}, "significantDigits": {"title": "Significantdigits", "type": "integer"}, "sasFieldName": {"title": "Sasfieldname", "type": "string"}, "sdsVarName": {"title": "Sdsvarname", "type": "string"}, "origin": {"title": "Origin", "type": "string"}, "comment": {"title": "Comment", "type": "string"}, "descriptionUids": {"title": "Descriptionuids", "type": "array", "items": {"type": "string"}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}, "unitDefinitions": {"title": "Unitdefinitions", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemUnitDefinitionRelationshipInput"}}, "codelistUid": {"title": "Codelistuid", "type": "string"}, "terms": {"title": "Terms", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemTermRelationshipInput"}}}}, "OdmItemPostInput": {"title": "OdmItemPostInput", "required": ["name", "datatype", "descriptionUids", "aliasUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "datatype": {"title": "Datatype", "type": "string"}, "prompt": {"title": "Prompt", "type": "string"}, "length": {"title": "Length", "type": "integer"}, "significantDigits": {"title": "Significantdigits", "type": "integer"}, "sasFieldName": {"title": "Sasfieldname", "type": "string"}, "sdsVarName": {"title": "Sdsvarname", "type": "string"}, "origin": {"title": "Origin", "type": "string"}, "comment": {"title": "Comment", "type": "string"}, "descriptionUids": {"title": "Descriptionuids", "type": "array", "items": {"type": "string"}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}, "codelistUid": {"title": "Codelistuid", "type": "string"}, "unitDefinitions": {"title": "Unitdefinitions", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemUnitDefinitionRelationshipInput"}, "default": []}, "terms": {"title": "Terms", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemTermRelationshipInput"}, "default": []}}}, "OdmItemRefModel": {"title": "OdmItemRefModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "oid": {"title": "oid", "type": "string"}, "name": {"title": "name", "type": "string"}, "orderNumber": {"title": "orderNumber", "type": "integer"}, "mandatory": {"title": "mandatory", "type": "string"}, "dataEntryRequired": {"title": "dataEntryRequired", "type": "string"}, "sdv": {"title": "sdv", "type": "string"}, "locked": {"title": "locked", "type": "string"}, "keySequence": {"title": "keySequence", "type": "string"}, "methodOid": {"title": "methodOid", "type": "string"}, "imputationMethodOid": {"title": "imputationMethodOid", "type": "string"}, "role": {"title": "role", "type": "string"}, "roleCodelistOid": {"title": "roleCodelistOid", "type": "string"}, "collectionExceptionConditionOid": {"title": "collectionExceptionConditionOid", "type": "string"}}}, "OdmItemTermRelationshipInput": {"title": "OdmItemTermRelationshipInput", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "mandatory": {"title": "Mandatory", "type": "boolean", "default": true}, "order": {"title": "Order", "type": "integer", "default": 999999}}}, "OdmItemTermRelationshipModel": {"title": "OdmItemTermRelationshipModel", "required": ["termUid"], "type": "object", "properties": {"termUid": {"title": "termUid", "type": "string"}, "name": {"title": "name", "type": "string"}, "mandatory": {"title": "mandatory", "type": "boolean"}, "order": {"title": "order", "type": "integer"}}}, "OdmItemUnitDefinitionRelationshipInput": {"title": "OdmItemUnitDefinitionRelationshipInput", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "mandatory": {"title": "Mandatory", "type": "boolean", "default": true}, "order": {"title": "Order", "type": "integer", "default": 999999}}}, "OdmItemUnitDefinitionWithRelationship": {"title": "OdmItemUnitDefinitionWithRelationship", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}, "mandatory": {"title": "mandatory", "type": "boolean"}, "order": {"title": "order", "type": "integer"}, "ucum": {"title": "ucum", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "ctUnits": {"title": "ucumName", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}}}, "OdmItemWithRelationsPatchInput": {"title": "OdmItemWithRelationsPatchInput", "required": ["changeDescription", "descriptions", "aliasUids", "unitDefinitions", "terms"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "datatype": {"title": "Datatype", "type": "string"}, "prompt": {"title": "Prompt", "type": "string"}, "length": {"title": "Length", "type": "integer"}, "significantDigits": {"title": "Significantdigits", "type": "integer"}, "sasFieldName": {"title": "Sasfieldname", "type": "string"}, "sdsVarName": {"title": "Sdsvarname", "type": "string"}, "origin": {"title": "Origin", "type": "string"}, "comment": {"title": "Comment", "type": "string"}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmDescriptionBatchPatchInput"}, {"$ref": "#/components/schemas/OdmDescriptionPostInput"}]}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}, "unitDefinitions": {"title": "Unitdefinitions", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemUnitDefinitionRelationshipInput"}}, "codelistUid": {"title": "Codelistuid", "type": "string"}, "terms": {"title": "Terms", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemTermRelationshipInput"}}}}, "OdmItemWithRelationsPostInput": {"title": "OdmItemWithRelationsPostInput", "required": ["name", "datatype", "descriptions", "aliasUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "datatype": {"title": "Datatype", "type": "string"}, "prompt": {"title": "Prompt", "type": "string"}, "length": {"title": "Length", "type": "integer"}, "significantDigits": {"title": "Significantdigits", "type": "integer"}, "sasFieldName": {"title": "Sasfieldname", "type": "string"}, "sdsVarName": {"title": "Sdsvarname", "type": "string"}, "origin": {"title": "Origin", "type": "string"}, "comment": {"title": "Comment", "type": "string"}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmDescriptionPostInput"}, {"type": "string"}]}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}, "codelistUid": {"title": "Codelistuid", "type": "string"}, "unitDefinitions": {"title": "Unitdefinitions", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemUnitDefinitionRelationshipInput"}, "default": []}, "terms": {"title": "Terms", "type": "array", "items": {"$ref": "#/components/schemas/OdmItemTermRelationshipInput"}, "default": []}}}, "OdmMethod": {"title": "OdmMethod", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "descriptions", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "type": {"title": "Type", "type": "string"}, "formalExpressions": {"title": "Formalexpressions", "type": "array", "items": {"$ref": "#/components/schemas/OdmFormalExpressionSimpleModel"}}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"$ref": "#/components/schemas/OdmDescriptionSimpleModel"}}, "aliases": {"title": "Aliases", "type": "array", "items": {"$ref": "#/components/schemas/OdmAliasSimpleModel"}}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmMethodPatchInput": {"title": "OdmMethodPatchInput", "required": ["changeDescription", "formalExpressionUids", "descriptionUids", "aliasUids"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "type": {"title": "Type", "type": "string"}, "formalExpressionUids": {"title": "Formalexpressionuids", "type": "array", "items": {"type": "string"}}, "descriptionUids": {"title": "Descriptionuids", "type": "array", "items": {"type": "string"}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmMethodPostInput": {"title": "OdmMethodPostInput", "required": ["name", "formalExpressionUids", "descriptionUids", "aliasUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "type": {"title": "Type", "type": "string"}, "formalExpressionUids": {"title": "Formalexpressionuids", "type": "array", "items": {"type": "string"}}, "descriptionUids": {"title": "Descriptionuids", "type": "array", "items": {"type": "string"}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmMethodWithRelationsPatchInput": {"title": "OdmMethodWithRelationsPatchInput", "required": ["changeDescription", "formalExpressions", "descriptions", "aliasUids"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "type": {"title": "Type", "type": "string"}, "formalExpressions": {"title": "Formalexpressions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmFormalExpressionBatchPatchInput"}, {"$ref": "#/components/schemas/OdmFormalExpressionPostInput"}]}}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmDescriptionBatchPatchInput"}, {"$ref": "#/components/schemas/OdmDescriptionPostInput"}]}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmMethodWithRelationsPostInput": {"title": "OdmMethodWithRelationsPostInput", "required": ["name", "formalExpressions", "descriptions", "aliasUids"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "type": {"title": "Type", "type": "string"}, "formalExpressions": {"title": "Formalexpressions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmFormalExpressionPostInput"}, {"type": "string"}]}}, "descriptions": {"title": "Descriptions", "type": "array", "items": {"anyOf": [{"$ref": "#/components/schemas/OdmDescriptionPostInput"}, {"type": "string"}]}}, "aliasUids": {"title": "Aliasuids", "type": "array", "items": {"type": "string"}}}}, "OdmTemplate": {"title": "OdmTemplate", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "effectiveDate": {"title": "Effectivedate", "type": "string", "format": "date"}, "retiredDate": {"title": "Retireddate", "type": "string", "format": "date"}, "description": {"title": "Description", "type": "string"}, "forms": {"title": "Forms", "type": "array", "items": {"$ref": "#/components/schemas/OdmFormRefModel"}}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmTemplateFormPostInput": {"title": "OdmTemplateFormPostInput", "required": ["uid", "orderNumber", "mandatory"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "orderNumber": {"title": "Ordernumber", "type": "integer"}, "mandatory": {"title": "Mandatory", "type": "string"}, "locked": {"title": "Locked", "type": "string", "default": "No"}, "collectionExceptionConditionOid": {"title": "Collectionexceptionconditionoid", "type": "string"}}}, "OdmTemplatePatchInput": {"title": "OdmTemplatePatchInput", "required": ["changeDescription"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "oid": {"title": "Oid", "type": "string"}, "effectiveDate": {"title": "Effectivedate", "type": "string", "format": "date"}, "retiredDate": {"title": "Retireddate", "type": "string", "format": "date"}, "description": {"title": "Description", "type": "string"}}}, "OdmTemplatePostInput": {"title": "OdmTemplatePostInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "oid": {"title": "Oid", "type": "string"}, "effectiveDate": {"title": "Effectivedate", "type": "string", "format": "date"}, "retiredDate": {"title": "Retireddate", "type": "string", "format": "date"}, "description": {"title": "Description", "type": "string"}}}, "OdmXmlExtension": {"title": "OdmXmlExtension", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "prefix": {"title": "Prefix", "type": "string"}, "namespace": {"title": "Namespace", "type": "string"}, "xmlExtensionTags": {"title": "Xmlextensiontags", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionTagSimpleModel"}}, "xmlExtensionAttributes": {"title": "Xmlextensionattributes", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionAttributeSimpleModel"}}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmXmlExtensionAttribute": {"title": "OdmXmlExtensionAttribute", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "xmlExtension": {"$ref": "#/components/schemas/OdmXmlExtensionSimpleModel"}, "xmlExtensionTag": {"$ref": "#/components/schemas/OdmXmlExtensionTagSimpleModel"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmXmlExtensionAttributePatchInput": {"title": "OdmXmlExtensionAttributePatchInput", "required": ["changeDescription"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}}}, "OdmXmlExtensionAttributePostInput": {"title": "OdmXmlExtensionAttributePostInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "xmlExtensionUid": {"title": "Xmlextensionuid", "type": "string"}, "xmlExtensionTagUid": {"title": "Xmlextensiontaguid", "type": "string"}}}, "OdmXmlExtensionAttributeRelationModel": {"title": "OdmXmlExtensionAttributeRelationModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}, "value": {"title": "value", "type": "string"}, "odmXmlExtensionUid": {"title": "value", "type": "string"}}}, "OdmXmlExtensionAttributeSimpleModel": {"title": "OdmXmlExtensionAttributeSimpleModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}}}, "OdmXmlExtensionPatchInput": {"title": "OdmXmlExtensionPatchInput", "required": ["changeDescription", "prefix", "namespace"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "prefix": {"title": "Prefix", "type": "string"}, "namespace": {"title": "Namespace", "type": "string"}}}, "OdmXmlExtensionPostInput": {"title": "OdmXmlExtensionPostInput", "required": ["name", "prefix", "namespace"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "prefix": {"title": "Prefix", "type": "string"}, "namespace": {"title": "Namespace", "type": "string"}}}, "OdmXmlExtensionRelationPostInput": {"title": "OdmXmlExtensionRelationPostInput", "required": ["uid", "value"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "value": {"title": "Value", "type": "string"}}}, "OdmXmlExtensionSimpleModel": {"title": "OdmXmlExtensionSimpleModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}, "prefix": {"title": "prefix", "type": "string"}, "namespace": {"title": "namespace", "type": "string"}}}, "OdmXmlExtensionTag": {"title": "OdmXmlExtensionTag", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "possibleActions"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "xmlExtension": {"$ref": "#/components/schemas/OdmXmlExtensionSimpleModel"}, "parentXmlExtensionTag": {"$ref": "#/components/schemas/OdmXmlExtensionTagSimpleModel"}, "childXmlExtensionTags": {"title": "Childxmlextensiontags", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionTagSimpleModel"}}, "xmlExtensionAttributes": {"title": "Xmlextensionattributes", "type": "array", "items": {"$ref": "#/components/schemas/OdmXmlExtensionAttributeSimpleModel"}}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}}}}, "OdmXmlExtensionTagAttributeRelationModel": {"title": "OdmXmlExtensionTagAttributeRelationModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}, "value": {"title": "value", "type": "string"}, "odmXmlExtensionTagUid": {"title": "value", "type": "string"}}}, "OdmXmlExtensionTagPatchInput": {"title": "OdmXmlExtensionTagPatchInput", "required": ["changeDescription"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}}}, "OdmXmlExtensionTagPostInput": {"title": "OdmXmlExtensionTagPostInput", "required": ["name", "xmlExtensionUid"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "xmlExtensionUid": {"title": "Xmlextensionuid", "type": "string"}, "parentXmlExtensionTagUid": {"title": "Parentxmlextensiontaguid", "type": "string"}}}, "OdmXmlExtensionTagRelationModel": {"title": "OdmXmlExtensionTagRelationModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}, "value": {"title": "value", "type": "string"}}}, "OdmXmlExtensionTagSimpleModel": {"title": "OdmXmlExtensionTagSimpleModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}}}, "Project": {"title": "Project", "required": ["uid", "projectNumber", "clinicalProgramme", "name", "description"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string", "description": "The unique id of the Project."}, "projectNumber": {"title": "projectNumber", "type": "string"}, "clinicalProgramme": {"title": "clinicalProgramme", "allOf": [{"$ref": "#/components/schemas/ClinicalProgramme"}]}, "name": {"title": "name", "type": "string"}, "description": {"title": "description", "type": "string"}}}, "ProjectCreateInput": {"title": "ProjectCreateInput", "required": ["projectNumber", "name", "description", "clinicalProgrammeUid"], "type": "object", "properties": {"projectNumber": {"title": "projectNumber", "type": "string"}, "name": {"title": "name", "type": "string"}, "description": {"title": "description", "type": "string"}, "clinicalProgrammeUid": {"title": "clinicalProgrammeUid", "type": "string"}}}, "RatingScale": {"title": "RatingScale", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "topicCode", "adamParamCode", "sdtmVariable", "sdtmSubcat", "sdtmCat", "sdtmDomain", "activities", "activitySubgroups", "activityGroups"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "type": {"title": "type", "type": "string", "description": "The subtype of ActivityInstance"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmSubcat": {"title": "sdtmSubcat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmCat": {"title": "sdtmCat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmDomain": {"title": "sdtmDomain", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "activities": {"title": "activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity unique identifiers"}, "activitySubgroups": {"title": "activitySubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity sub group unique identifiers"}, "activityGroups": {"title": "activityGroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity group unique identifiers"}, "specimen": {"$ref": "#/components/schemas/SimpleTermModel"}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "testCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "categoricResponseValue": {"$ref": "#/components/schemas/SimpleTermModel"}, "categoricResponseList": {"$ref": "#/components/schemas/SimpleTermModel"}}}, "RatingScaleCreateInput": {"title": "RatingScaleCreateInput", "required": ["name", "libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "specimen": {"title": "Specimen", "type": "string"}, "testCode": {"title": "Testcode", "type": "string"}, "categoricResponseValue": {"title": "Categoricresponsevalue", "type": "string"}, "categoricResponseList": {"title": "Categoricresponselist", "type": "string"}}}, "RatingScaleEditInput": {"title": "RatingScaleEditInput", "required": ["changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "specimen": {"title": "Specimen", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "changeDescription": {"title": "changeDescription", "type": "string"}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "testCode": {"title": "Testcode", "type": "string"}, "categoricResponseValue": {"title": "Categoricresponsevalue", "type": "string"}, "categoricResponseList": {"title": "Categoricresponselist", "type": "string"}}}, "RegistryIdentifiersJsonModel": {"title": "RegistryIdentifiersMetadata", "type": "object", "properties": {"ctGovId": {"title": "Ctgovid", "type": "string"}, "ctGovIdNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "eudractId": {"title": "Eudractid", "type": "string"}, "eudractIdNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "universalTrialNumberUTN": {"title": "Universaltrialnumberutn", "type": "string"}, "universalTrialNumberUTNNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "japaneseTrialRegistryIdJAPIC": {"title": "Japanesetrialregistryidjapic", "type": "string"}, "japaneseTrialRegistryIdJAPICNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "investigationalNewDrugApplicationNumberIND": {"title": "Investigationalnewdrugapplicationnumberind", "type": "string"}, "investigationalNewDrugApplicationNumberINDNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}}}, "RegistryIdentifiersListingModel": {"title": "Registry identifiers model for listing", "type": "object", "properties": {"ctGovId": {"title": "Ctgovid", "type": "string"}, "ctGovIdNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "eudractId": {"title": "Eudractid", "type": "string"}, "eudractIdNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "universalTrialNumberUTN": {"title": "Universaltrialnumberutn", "type": "string"}, "universalTrialNumberUTNNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "japaneseTrialRegistryIdJAPIC": {"title": "Japanesetrialregistryidjapic", "type": "string"}, "japaneseTrialRegistryIdJAPICNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "investigationalNewDrugApplicationNumberIND": {"title": "Investigationalnewdrugapplicationnumberind", "type": "string"}, "investigationalNewDrugApplicationNumberINDNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}}}, "Reminder": {"title": "Reminder", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "topicCode", "adamParamCode", "sdtmVariable", "sdtmSubcat", "sdtmCat", "sdtmDomain", "activities", "activitySubgroups", "activityGroups", "specimen"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "type": {"title": "type", "type": "string", "description": "The subtype of ActivityInstance"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmSubcat": {"title": "sdtmSubcat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmCat": {"title": "sdtmCat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmDomain": {"title": "sdtmDomain", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "activities": {"title": "activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity unique identifiers"}, "activitySubgroups": {"title": "activitySubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity sub group unique identifiers"}, "activityGroups": {"title": "activityGroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity group unique identifiers"}, "specimen": {"title": "specimen", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}}}, "ReminderCreateInput": {"title": "ReminderCreateInput", "required": ["name", "libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}}}, "ReminderEditInput": {"title": "ReminderEditInput", "required": ["changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "specimen": {"title": "specimen", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "SimpleCTTermAttributes": {"title": "SimpleCTTermAttributes", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "codeSubmissionValue": {"title": "codeSubmissionValue", "type": "string"}, "preferredTerm": {"title": "preferredTerm", "type": "string"}}}, "SimpleCompound": {"title": "SimpleCompound", "required": ["uid", "name"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}}}, "SimpleDictionaryTermModel": {"title": "SimpleDictionaryTermModel", "required": ["termUid"], "type": "object", "properties": {"termUid": {"title": "termUid", "type": "string"}, "name": {"title": "name", "type": "string"}, "dictionaryId": {"title": "dictionaryId", "type": "string", "description": "Id if item in the external dictionary"}}}, "SimpleLagTime": {"title": "SimpleLagTime", "required": ["value", "unitDefinitionUid", "unitLabel", "sdtmDomainUid", "sdtmDomainLabel"], "type": "object", "properties": {"value": {"title": "Value", "type": "number"}, "unitDefinitionUid": {"title": "Unitdefinitionuid", "type": "string"}, "unitLabel": {"title": "Unitlabel", "type": "string"}, "sdtmDomainUid": {"title": "Sdtmdomainuid", "type": "string"}, "sdtmDomainLabel": {"title": "Sdtmdomainlabel", "type": "string"}}}, "SimpleListingCTModel": {"title": "SimpleListingCTModel", "type": "object", "properties": {"id": {"title": "concept id: c code for CDISC CT, dictionary id for dictionary codes", "type": "string"}, "code": {"title": "code: submission code for CDISC CT, this doesnot exists for dictionary codes", "type": "string"}, "name": {"title": "name: submission name for CDISC CT, name for dictionary codes", "type": "string"}}}, "SimpleNumericValueWithUnit": {"title": "SimpleNumericValueWithUnit", "required": ["uid", "value", "unitDefinitionUid", "unitLabel"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "value": {"title": "Value", "type": "number"}, "unitDefinitionUid": {"title": "Unitdefinitionuid", "type": "string"}, "unitLabel": {"title": "Unitlabel", "type": "string"}}}, "SimpleStudyVisit": {"title": "SimpleStudyVisit", "required": ["uid", "visitName", "visitTypeName"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string", "description": "Uid of the visit"}, "visitName": {"title": "Visit name", "type": "string", "description": "Name of the visit"}, "visitTypeName": {"title": "Visit type name", "type": "string", "description": "Name of the visit type"}}}, "SimpleTermModel": {"title": "SimpleTermModel", "required": ["termUid"], "type": "object", "properties": {"termUid": {"title": "termUid", "type": "string"}, "name": {"title": "name", "type": "string"}}}, "SpecialPurpose": {"title": "SpecialPurpose", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "topicCode", "adamParamCode", "sdtmVariable", "sdtmSubcat", "sdtmCat", "sdtmDomain", "activities", "activitySubgroups", "activityGroups", "specimen"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "type": {"title": "type", "type": "string", "description": "The subtype of ActivityInstance"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmSubcat": {"title": "sdtmSubcat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmCat": {"title": "sdtmCat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmDomain": {"title": "sdtmDomain", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "activities": {"title": "activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity unique identifiers"}, "activitySubgroups": {"title": "activitySubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity sub group unique identifiers"}, "activityGroups": {"title": "activityGroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity group unique identifiers"}, "specimen": {"title": "specimen", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}}}, "SpecialPurposeCreateInput": {"title": "SpecialPurposeCreateInput", "required": ["name", "libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}}}, "SpecialPurposeEditInput": {"title": "SpecialPurposeEditInput", "required": ["changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "specimen": {"title": "specimen", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "changeDescription": {"title": "changeDescription", "type": "string"}}}, "Study": {"title": "Study", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string", "description": "The unique id of the study."}, "studyNumber": {"title": "studyNumber", "type": "string", "description": "DEPRECATED. Use field in currentMetadata.identificationMetadata."}, "studyId": {"title": "studyId", "type": "string", "description": "DEPRECATED. Use field in currentMetadata.identificationMetadata."}, "studyAcronym": {"title": "studyAcronym", "type": "string", "description": "DEPRECATED. Use field in currentMetadata.identificationMetadata."}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "DEPRECATED. Use field in currentMetadata.identificationMetadata."}, "studyStatus": {"title": "studyStatus", "type": "string", "description": "Current status of given StudyDefinition. Possible values are: 'DRAFT' or 'LOCKED'."}, "currentMetadata": {"$ref": "#/components/schemas/StudyMetadataJsonModel"}}}, "StudyActivityInstruction": {"title": "StudyActivityInstruction", "required": ["studyActivityInstructionUid", "studyUid", "studyActivityUid", "activityInstructionUid", "activityInstructionName", "startDate", "userInitials"], "type": "object", "properties": {"studyActivityInstructionUid": {"title": "studyActivityInstructionUid", "type": "string", "description": "uid for the study activity instruction"}, "studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "studyActivityUid": {"title": "studyActivityUid", "type": "string", "description": "uid for the study activity"}, "activityInstructionUid": {"title": "activityInstructionUid", "type": "string", "description": "The related activity instruction UID"}, "activityInstructionName": {"title": "activityInstructionName", "type": "string", "description": "The related activity instruction name"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}}}, "StudyActivityInstructionBatchInput": {"title": "StudyActivityInstructionBatchInput", "required": ["method", "content"], "type": "object", "properties": {"method": {"title": "method", "type": "string", "description": "HTTP method corresponding to operation type"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/StudyActivityInstructionCreateInput"}, {"$ref": "#/components/schemas/StudyActivityInstructionDeleteInput"}]}}}, "StudyActivityInstructionBatchOutput": {"title": "StudyActivityInstructionBatchOutput", "required": ["responseCode"], "type": "object", "properties": {"responseCode": {"title": "responseCode", "type": "integer", "description": "The HTTP response code related to input operation"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/StudyActivityInstruction"}, {"$ref": "#/components/schemas/BatchErrorResponse"}]}}}, "StudyActivityInstructionCreateInput": {"title": "StudyActivityInstructionCreateInput", "required": ["studyActivityUid"], "type": "object", "properties": {"activityInstructionData": {"title": "activityInstructionData", "allOf": [{"$ref": "#/components/schemas/ActivityInstructionCreateInput"}], "description": "Data to create new activity instruction"}, "activityInstructionUid": {"title": "activityInstructionUid", "type": "string", "description": "The uid of an existing activity instruction"}, "studyActivityUid": {"title": "studyActivityUid", "type": "string", "description": "uid for the study activity"}}}, "StudyActivityInstructionDeleteInput": {"title": "StudyActivityInstructionDeleteInput", "required": ["studyActivityInstructionUid"], "type": "object", "properties": {"studyActivityInstructionUid": {"title": "studyActivityInstructionUid", "type": "string", "description": "uid for the study activity instruction"}}}, "StudyActivitySchedule": {"title": "StudyActivitySchedule", "required": ["studyUid", "studyActivityScheduleUid", "studyActivityUid", "studyVisitUid", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "studyActivityScheduleUid": {"title": "studyActivityScheduleUid", "type": "string", "description": "uid for the study activity schedule"}, "studyActivityUid": {"title": "studyActivityUid", "type": "string", "description": "The related study activity UID"}, "studyActivityName": {"title": "studyActivityName", "type": "string", "description": "The related study activity name"}, "studyVisitUid": {"title": "studyVisitUid", "type": "string", "description": "The related study visit UID"}, "studyVisitName": {"title": "studyVisitName", "type": "string", "description": "The related study visit name"}, "note": {"title": "note", "type": "string", "description": "Foot note to display in flowchart"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}}}, "StudyActivityScheduleBatchInput": {"title": "StudyActivityScheduleBatchInput", "required": ["method", "content"], "type": "object", "properties": {"method": {"title": "method", "type": "string", "description": "HTTP method corresponding to operation type"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/StudyActivityScheduleCreateInput"}, {"$ref": "#/components/schemas/StudyActivityScheduleDeleteInput"}]}}}, "StudyActivityScheduleBatchOutput": {"title": "StudyActivityScheduleBatchOutput", "required": ["responseCode"], "type": "object", "properties": {"responseCode": {"title": "responseCode", "type": "integer", "description": "The HTTP response code related to input operation"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/StudyActivitySchedule"}, {"$ref": "#/components/schemas/BatchErrorResponse"}]}}}, "StudyActivityScheduleCreateInput": {"title": "StudyActivityScheduleCreateInput", "required": ["studyActivityUid", "studyVisitUid"], "type": "object", "properties": {"studyActivityUid": {"title": "studyActivityUid", "type": "string", "description": "The related study activity uid"}, "studyVisitUid": {"title": "studyVisitUid", "type": "string", "description": "The related study visit uid"}, "note": {"title": "note", "type": "string", "description": "A note"}}}, "StudyActivityScheduleDeleteInput": {"title": "StudyActivityScheduleDeleteInput", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string", "description": "UID of the study activity schedule to delete"}}}, "StudyActivityScheduleHistory": {"title": "StudyActivityScheduleHistory", "required": ["studyUid", "studyActivityScheduleUid", "studyActivityUid", "studyVisitUid"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "studyActivityScheduleUid": {"title": "studyActivityScheduleUid", "type": "string", "description": "uid for the study activity schedule"}, "studyActivityUid": {"title": "studyActivityUid", "type": "string", "description": "uid for the study activity"}, "studyVisitUid": {"title": "studyVisitUid", "type": "string", "description": "uid for the study visit"}, "note": {"title": "note", "type": "string", "description": "Foot note to display in flowchart"}, "modified": {"title": "modified", "type": "string", "description": "Date of last modification", "format": "date-time"}}}, "StudyArmListing": {"title": "StudyArmListing", "required": ["STUDYID", "DOMAIN"], "type": "object", "properties": {"STUDYID": {"title": "Study Identifier", "type": "string", "description": "Unique identifier for a study."}, "DOMAIN": {"title": "Domain Abbreviation", "type": "string", "description": "Two-character abbreviation for the domain"}, "ARMCD": {"title": "Planned Arm Code", "type": "string", "description": "\n        1.ARMCD is limited to 20 characters and does not have special character restrictions. \n        The maximum length of ARMCD is longer than for other \"short\" variables to accommodate \n        the kind of values that are likely to be needed for crossover trials. For example, if \n        ARMCD values for a seven- period crossover were constructed using two-character abbreviations \n        for each treatment and separating hyphens, the length of ARMCD values would be 20. 2. If the \n        timing of Visits for a trial does not depend on which ARM a subject is in, then ARMCD should be null.\n        "}, "ARM": {"title": "Description of Planned Arm", "type": "string", "description": "1. Name given to an Arm or Treatment Group. 2. If the timing\n        of Visits for a trial does not depend on which Arm a subject is in, then Arm should be left blank."}, "TAETORD": {"title": "Planned Order of Element within Arm", "type": "string", "description": "Number that gives the order of the Element within the Arm"}, "ETCD": {"title": "Element Code", "type": "string", "description": "\n        ETCD (the companion to ELEMENT) is limited to 8 characters \n        and does not have special character restrictions. These values should be\n         "}, "ELEMENT": {"title": "Description of Element", "type": "string", "description": "The name of the Element. The same Element may occur more than once within an Arm."}, "TABRANCH": {"title": "Branch", "type": "string", "description": "\n        Condition subject met, at a \u201cbranch\u201d in the trial design at the end of this Element, \n        to be included in this Arm; (e.g., randomization to DRUG X).\n         "}, "TATRANS": {"title": "Transition Rule", "type": "string", "description": " If the trial design allows a subject to transition\n        to an Element other than the next Element in sequence, \n        then the conditions for transitioning to those other Elements, \n        and the alternative Element sequences, are specified in this rule (e.g., Responders go to washout). "}, "EPOCH": {"title": "Epoch", "type": "string", "description": "Name of the Trial Epoch with which this Element of the Arm is associated."}}}, "StudyComponentEnum": {"title": "StudyComponentEnum", "enum": ["highLevelStudyDesign", "studyIntervention", "studyPopulation"], "type": "string", "description": "An enumeration."}, "StudyCompoundDosing": {"title": "StudyCompoundDosing", "required": ["studyUid", "order", "studyCompoundDosingUid", "studyCompound", "studyElement", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "studyCompoundDosingUid": {"title": "studyCompoundDosingUid", "type": "string", "description": "uid for the study compound dosing"}, "studyCompound": {"title": "studyCompound", "allOf": [{"$ref": "#/components/schemas/StudySelectionCompound"}], "description": "The related study compound"}, "studyElement": {"title": "studyElement", "allOf": [{"$ref": "#/components/schemas/StudySelectionElement"}], "description": "The related study element"}, "doseValue": {"title": "dose", "allOf": [{"$ref": "#/components/schemas/SimpleNumericValueWithUnit"}], "description": "compound dose defined for the study selection"}, "doseFrequency": {"title": "doseFrequency", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}], "description": "dose frequency defined for the study selection"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}}}, "StudyCompoundDosingInput": {"title": "StudyCompoundDosingInput", "required": ["studyCompoundUid", "studyElementUid"], "type": "object", "properties": {"studyCompoundUid": {"title": "studyCompoundUid", "type": "string", "description": "The related study compound uid"}, "studyElementUid": {"title": "studyElementUid", "type": "string", "description": "The related study element uid"}, "doseValueUid": {"title": "doseValueUid", "type": "string", "description": "compound dose defined for the study selection"}, "doseFrequencyUid": {"title": "doseFrequencyUid", "type": "string", "description": "dose frequency defined for the study selection"}}}, "StudyCreateInput": {"title": "StudyCreateInput", "type": "object", "properties": {"studyNumber": {"title": "studyNumber", "type": "string"}, "studyAcronym": {"title": "studyAcronym", "type": "string"}, "projectNumber": {"title": "projectNumber", "type": "string"}}}, "StudyCriterionListing": {"title": "StudyCriterionListing", "required": ["STUDYID", "DOMAIN", "IETESTCD"], "type": "object", "properties": {"STUDYID": {"title": "Study Identifier", "type": "string", "description": "Unique identifier for a study."}, "DOMAIN": {"title": "Domain Abbreviation", "type": "string", "description": "Two-character abbreviation for the domain"}, "IETESTCD": {"title": "Incl/Excl Criterion Short Name", "type": "string", "description": "\n        Short name IETEST. It can be used as a column name when converting a dataset from a vertical to a horizontal format.\n        The value in IETESTCD cannot be longer than 8 characters, nor can it start with a number (e.g., \"1TEST\"). IETESTCD\n        cannot contain characters other than letters, numbers, or underscores. The prefix \"IE\" is used to ensure consistency\n        with the IE domain.\n        "}, "IETEST": {"title": "Inclusion/Exclusion Criterion", "type": "string", "description": "\n        Full text of the inclusion or exclusion criterion. The prefix \"IE\" is used to ensure consistency with the IE domain.\n        "}, "IECAT": {"title": "Inclusion/Exclusion Category", "type": "string", "description": "\n        Used for categorization of the inclusion or exclusion criteria.\n        "}, "IESCAT": {"title": "Inclusion/Exclusion Subcategory", "type": "string", "description": "\n        A further categorization of the exception criterion.\n        Can be used to distinguish criteria for a sub-study or for to categorize as\n        a major or minor exceptions. Examples: MAJOR, MINOR.\n        "}, "TIRL": {"title": "Inclusion/Exclusion Criterion Rule", "type": "string", "description": "\n        Rule that expresses the criterion in computer-executable form (see assumption 4 below).\n        "}, "TIVERS": {"title": "Protocol Criteria Versions", "type": "string", "description": "The number of this version of the Inclusion/Exclusion criteria. May be omitted if there is only one version."}}}, "StudyDescriptionJsonModel": {"title": "StudyDescription", "type": "object", "properties": {"studyTitle": {"title": "Studytitle", "type": "string"}, "studyShortTitle": {"title": "Studyshorttitle", "type": "string"}}}, "StudyDesignCell": {"title": "StudyDesignCell", "required": ["studyUid", "designCellUid", "studyEpochUid", "studyEpochName", "studyElementUid", "studyElementName", "transitionRule", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "designCellUid": {"title": "designCellUid", "type": "string", "description": "uid for the study cell"}, "studyArmUid": {"title": "studyArmUid", "type": "string", "description": "the uid of the related study arm"}, "studyArmName": {"title": "studyArmName", "type": "string", "description": "the name of the related study arm"}, "studyBranchArmUid": {"title": "studyBranchArmUid", "type": "string", "description": "the uid of the related study branch arm"}, "studyBranchArmName": {"title": "studyBranchArmName", "type": "string", "description": "the name of the related study branch arm"}, "studyEpochUid": {"title": "studyEpochUid", "type": "string", "description": "the uid of the related study epoch"}, "studyEpochName": {"title": "studyEpochName", "type": "string", "description": "the name of the related study epoch"}, "studyElementUid": {"title": "studyElementUid", "type": "string", "description": "the uid of the related study element"}, "studyElementName": {"title": "studyElementName", "type": "string", "description": "the name of the related study element"}, "transitionRule": {"title": "transitionRule", "type": "string", "description": "transition rule for the cell"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}}}, "StudyDesignCellBatchInput": {"title": "StudyDesignCellBatchInput", "required": ["method", "content"], "type": "object", "properties": {"method": {"title": "method", "type": "string", "description": "HTTP method corresponding to operation type"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/StudyDesignCellCreateInput"}, {"$ref": "#/components/schemas/StudyDesignCellDeleteInput"}, {"$ref": "#/components/schemas/StudyDesignCellEditInput"}]}}}, "StudyDesignCellBatchOutput": {"title": "StudyDesignCellBatchOutput", "required": ["responseCode"], "type": "object", "properties": {"responseCode": {"title": "responseCode", "type": "integer", "description": "The HTTP response code related to input operation"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/StudyDesignCell"}, {"$ref": "#/components/schemas/BatchErrorResponse"}]}}}, "StudyDesignCellCreateInput": {"title": "StudyDesignCellCreateInput", "required": ["studyEpochUid", "studyElementUid"], "type": "object", "properties": {"studyArmUid": {"title": "studyArmUid", "type": "string", "description": "the uid of the related study arm"}, "studyBranchArmUid": {"title": "studyBranchArmUid", "type": "string", "description": "the uid of the related study branch arm"}, "studyEpochUid": {"title": "studyEpochUid", "type": "string", "description": "the uid of the related study epoch"}, "studyElementUid": {"title": "studyElementUid", "type": "string", "description": "the uid of the related study element"}, "transitionRule": {"title": "transitionRule", "type": "string", "description": "Optionally, a transition rule for the cell"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}}}, "StudyDesignCellDeleteInput": {"title": "StudyDesignCellDeleteInput", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string", "description": "UID of the study design cell to delete"}}}, "StudyDesignCellEditInput": {"title": "StudyDesignCellEditInput", "required": ["studyDesignCellUid"], "type": "object", "properties": {"studyDesignCellUid": {"title": "studyDesignCellUid", "type": "string", "description": "uid for the study design cell"}, "studyArmUid": {"title": "studyArmUid", "type": "string", "description": "the uid of the related study arm"}, "studyBranchArmUid": {"title": "studyBranchArmUid", "type": "string", "description": "the uid of the related study branch arm"}, "studyElementUid": {"title": "studyElementUid", "type": "string", "description": "the uid of the related study element"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "transitionRule": {"title": "transitionRule", "type": "string", "description": "transition rule for the cell"}}}, "StudyDesignCellVersion": {"title": "StudyDesignCellVersion", "required": ["studyUid", "studyDesignCellUid", "studyEpochUid", "changes"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "studyDesignCellUid": {"title": "studyDesignCellUid", "type": "string", "description": "uid for the study design cell"}, "studyArmUid": {"title": "studyArmUid", "type": "string", "description": "the uid of the related study arm"}, "studyBranchArmUid": {"title": "studyBranchArmUid", "type": "string", "description": "the uid of the related study branch arm"}, "studyEpochUid": {"title": "studyEpochUid", "type": "string", "description": "the uid of the related study epoch"}, "studyElementUid": {"title": "studyElementUid", "type": "string", "description": "the uid of the related study element"}, "transitionRule": {"title": "transitionRule", "type": "string", "description": "transition rule for the cell"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "modified": {"title": "modified", "type": "string", "description": "Date of last modification", "format": "date-time"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "changes": {"title": "Changes", "type": "object"}}}, "StudyElementListing": {"title": "StudyElementListing", "required": ["STUDYID", "DOMAIN"], "type": "object", "properties": {"STUDYID": {"title": "Study Identifier", "type": "string", "description": "Unique identifier for a study."}, "DOMAIN": {"title": "Domain Abbreviation", "type": "string", "description": "Two-character abbreviation for the domain"}, "ETCD": {"title": "Element Code", "type": "string", "description": "\n        ETCD (the companion to ELEMENT) is limited to 8 characters \n        and does not have special character restrictions. These values should be\n         "}, "ELEMENT": {"title": "Description of Element", "type": "string", "description": "The name of the Element. The same Element may occur more than once within an Arm."}, "TESTRL": {"title": "Rule for Start of Element", "type": "string", "description": "Rule for Start of Element Char Rule Expresses rule for beginning Element"}, "TEENRL": {"title": "Rule for End of Element", "type": "string", "description": " Rule for End of Element Char Rule Expresses rule for ending Element.\n        Either TEENRL or TEDUR must be present for each Element "}, "TEDUR": {"title": "Planned Duration of Element", "type": "string", "description": "Planned Duration of Element Char ISO 8601\n        Timing Planned Duration of Element in ISO 8601 format. \n        Used when the rule for ending the Element is applied after a fixed duration. \n        "}}}, "StudyElementTypes": {"title": "StudyElementTypes", "required": ["type", "type_name", "subtype", "subtype_name"], "type": "object", "properties": {"type": {"title": "Type uid", "type": "string", "description": "Element type uid"}, "type_name": {"title": "Type name", "type": "string", "description": "Element type name"}, "subtype": {"title": "Subtype", "type": "string", "description": "Element subtype uid"}, "subtype_name": {"title": "Subtype name", "type": "string", "description": "Element subtype name"}}}, "StudyEpoch": {"title": "StudyEpoch", "required": ["studyUid", "epochSubType", "uid", "epochName", "epochSubTypeName", "epochType", "startDate", "status", "userInitials", "possibleActions"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "startRule": {"title": "Start Description", "type": "string", "description": "Study Epoch Start description"}, "endRule": {"title": "End Description", "type": "string", "description": "Study Epoch end description"}, "epoch": {"title": "Epoch", "type": "string", "description": "Study Epoch epoch"}, "epochSubType": {"title": "Epoch Sub Type", "type": "string", "description": "Study Epoch sub type"}, "durationUnit": {"title": "Duration Unit", "type": "string", "description": "Study Epoch duration preferred unit"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "description": {"title": "Description", "type": "string", "description": "Epoch description"}, "duration": {"title": "Epoch Duration", "type": "integer", "description": "Calculated epoch duration"}, "colorHash": {"title": "Epoch Color Hash", "type": "string", "description": "Epoch Color for display", "default": "#FFFFFF"}, "uid": {"title": "Uid", "type": "string", "description": "Uid of the Epoch"}, "epochName": {"title": "Epoch name", "type": "string", "description": "Name of the epoch based on CT term"}, "epochSubTypeName": {"title": "Epoch sub type name", "type": "string", "description": "Name of the epoch sub type based on CT term"}, "epochType": {"title": "Type", "type": "string", "description": "Study Epoch type"}, "startDay": {"title": "Start Day", "type": "integer", "description": "Study Epoch start day"}, "endDay": {"title": "End Day", "type": "integer", "description": "Study Epoch end day"}, "startDate": {"title": "Modification date", "type": "string", "description": "Study Epoch last modification date"}, "status": {"title": "Status", "type": "string", "description": "Study Epoch status"}, "userInitials": {"title": "User Initials", "type": "string", "description": "Initials of user that created last modification"}, "possibleActions": {"title": "Possible actions", "type": "array", "items": {"type": "string"}, "description": "List of actions to perform on item"}, "changeDescription": {"title": "Change Description", "type": "string", "description": "Description of change reasons", "default": ""}, "studyVisitCount": {"title": "Studyvisitcount", "type": "integer", "description": "Count of Study Visits assigned to Study Epoch"}}}, "StudyEpochCreateInput": {"title": "StudyEpochCreateInput", "required": ["studyUid", "epochSubType"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "startRule": {"title": "Start Description", "type": "string", "description": "Study Epoch Start description"}, "endRule": {"title": "End Description", "type": "string", "description": "Study Epoch end description"}, "epoch": {"title": "Epoch", "type": "string", "description": "Study Epoch epoch"}, "epochSubType": {"title": "Epoch Sub Type", "type": "string", "description": "Study Epoch sub type"}, "durationUnit": {"title": "Duration Unit", "type": "string", "description": "Study Epoch duration preferred unit"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "description": {"title": "Description", "type": "string", "description": "Epoch description"}, "duration": {"title": "Epoch Duration", "type": "integer", "description": "Calculated epoch duration"}, "colorHash": {"title": "Epoch Color Hash", "type": "string", "description": "Epoch Color for display", "default": "#FFFFFF"}}}, "StudyEpochEditInput": {"title": "StudyEpochEditInput", "required": ["studyUid", "changeDescription"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "startRule": {"title": "Start Description", "type": "string", "description": "Study Epoch Start description"}, "endRule": {"title": "End Description", "type": "string", "description": "Study Epoch end description"}, "epoch": {"title": "Epoch", "type": "string", "description": "Study Epoch epoch"}, "epochSubType": {"title": "Epoch Sub Type", "type": "string", "description": "Study Epoch sub type"}, "durationUnit": {"title": "Duration Unit", "type": "string", "description": "Study Epoch duration preferred unit"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "description": {"title": "Description", "type": "string", "description": "Epoch description"}, "duration": {"title": "Epoch Duration", "type": "integer", "description": "Calculated epoch duration"}, "colorHash": {"title": "Epoch Color Hash", "type": "string", "description": "Epoch Color for display", "default": "#FFFFFF"}, "changeDescription": {"title": "Change Description", "type": "string", "description": "Description of change reasons"}}}, "StudyEpochTypes": {"title": "StudyEpochTypes", "required": ["type", "type_name", "subtype", "subtype_name"], "type": "object", "properties": {"type": {"title": "Type", "type": "string", "description": "Study Epoch type"}, "type_name": {"title": "Type Name", "type": "string"}, "subtype": {"title": "Subtype", "type": "string", "description": "Study Epoch subtype"}, "subtype_name": {"title": "Subtype Name", "type": "string"}}}, "StudyEpochVersion": {"title": "StudyEpochVersion", "required": ["studyUid", "epochSubType", "uid", "epochName", "epochSubTypeName", "epochType", "startDate", "status", "userInitials", "possibleActions", "changes"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "startRule": {"title": "Start Description", "type": "string", "description": "Study Epoch Start description"}, "endRule": {"title": "End Description", "type": "string", "description": "Study Epoch end description"}, "epoch": {"title": "Epoch", "type": "string", "description": "Study Epoch epoch"}, "epochSubType": {"title": "Epoch Sub Type", "type": "string", "description": "Study Epoch sub type"}, "durationUnit": {"title": "Duration Unit", "type": "string", "description": "Study Epoch duration preferred unit"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "description": {"title": "Description", "type": "string", "description": "Epoch description"}, "duration": {"title": "Epoch Duration", "type": "integer", "description": "Calculated epoch duration"}, "colorHash": {"title": "Epoch Color Hash", "type": "string", "description": "Epoch Color for display", "default": "#FFFFFF"}, "uid": {"title": "Uid", "type": "string", "description": "Uid of the Epoch"}, "epochName": {"title": "Epoch name", "type": "string", "description": "Name of the epoch based on CT term"}, "epochSubTypeName": {"title": "Epoch sub type name", "type": "string", "description": "Name of the epoch sub type based on CT term"}, "epochType": {"title": "Type", "type": "string", "description": "Study Epoch type"}, "startDay": {"title": "Start Day", "type": "integer", "description": "Study Epoch start day"}, "endDay": {"title": "End Day", "type": "integer", "description": "Study Epoch end day"}, "startDate": {"title": "Modification date", "type": "string", "description": "Study Epoch last modification date"}, "status": {"title": "Status", "type": "string", "description": "Study Epoch status"}, "userInitials": {"title": "User Initials", "type": "string", "description": "Initials of user that created last modification"}, "possibleActions": {"title": "Possible actions", "type": "array", "items": {"type": "string"}, "description": "List of actions to perform on item"}, "changeDescription": {"title": "Change Description", "type": "string", "description": "Description of change reasons", "default": ""}, "studyVisitCount": {"title": "Studyvisitcount", "type": "integer", "description": "Count of Study Visits assigned to Study Epoch"}, "changes": {"title": "Changes", "type": "object"}}}, "StudyFieldAuditTrailAction": {"title": "StudyFieldAuditTrailAction", "type": "object", "properties": {"section": {"title": "section", "type": "string", "description": "The section that the modified study field is in."}, "field": {"title": "field", "type": "string", "description": "The name of the study field that was changed."}, "beforeValue": {"title": "beforeValue", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}], "description": "The value of the field before the edit."}, "afterValue": {"title": "afterValue", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}], "description": "The value of the field after the edit."}, "action": {"title": "action", "type": "string", "description": "The action taken on the study field. One of (Create, edit, delete...)"}}}, "StudyFieldAuditTrailEntry": {"title": "StudyFieldAuditTrailEntry", "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The unique id of the study."}, "userInitials": {"title": "userInitials", "type": "string", "description": "The initials of the user that made the edit."}, "date": {"title": "date", "type": "string", "description": "The date that the edit was made."}, "actions": {"title": "actions", "type": "array", "items": {"$ref": "#/components/schemas/StudyFieldAuditTrailAction"}, "description": "The actions that took place as part of this audit trial entry."}}}, "StudyIdentificationMetadataJsonModel": {"title": "StudyIdentificationMetadata", "type": "object", "properties": {"studyNumber": {"title": "Studynumber", "type": "string"}, "studyAcronym": {"title": "Studyacronym", "type": "string"}, "projectNumber": {"title": "Projectnumber", "type": "string"}, "projectName": {"title": "Projectname", "type": "string"}, "clinicalProgrammeName": {"title": "Clinicalprogrammename", "type": "string"}, "studyId": {"title": "Studyid", "type": "string"}, "registryIdentifiers": {"$ref": "#/components/schemas/RegistryIdentifiersJsonModel"}}}, "StudyInterventionJsonModel": {"title": "StudyIntervention", "type": "object", "properties": {"interventionTypeCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "interventionTypeNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "addOnToExistingTreatments": {"title": "Addontoexistingtreatments", "type": "boolean"}, "addOnToExistingTreatmentsNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "controlTypeCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "controlTypeNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "interventionModelCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "interventionModelNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "isTrialRandomised": {"title": "Istrialrandomised", "type": "boolean"}, "isTrialRandomisedNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "stratificationFactor": {"title": "Stratificationfactor", "type": "string"}, "stratificationFactorNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "trialBlindingSchemaCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "trialBlindingSchemaNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "plannedStudyLength": {"$ref": "#/components/schemas/DurationJsonModel"}, "plannedStudyLengthNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "drugStudyIndication": {"title": "Drugstudyindication", "type": "boolean"}, "drugStudyIndicationNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "deviceStudyIndication": {"title": "Devicestudyindication", "type": "string"}, "deviceStudyIndicationNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "trialIntentTypesCodes": {"title": "Trialintenttypescodes", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "trialIntentTypesNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}}}, "StudyMetadataJsonModel": {"title": "StudyMetadata", "type": "object", "properties": {"identificationMetadata": {"$ref": "#/components/schemas/StudyIdentificationMetadataJsonModel"}, "versionMetadata": {"$ref": "#/components/schemas/StudyVersionMetadataJsonModel"}, "highLevelStudyDesign": {"$ref": "#/components/schemas/HighLevelStudyDesignJsonModel"}, "studyPopulation": {"$ref": "#/components/schemas/StudyPopulationJsonModel"}, "studyIntervention": {"$ref": "#/components/schemas/StudyInterventionJsonModel"}, "studyDescription": {"$ref": "#/components/schemas/StudyDescriptionJsonModel"}}}, "StudyPatchRequestJsonModel": {"title": "StudyPatchRequest", "type": "object", "properties": {"currentMetadata": {"$ref": "#/components/schemas/StudyMetadataJsonModel"}}}, "StudyPopulationJsonModel": {"title": "StudyPopulation", "type": "object", "properties": {"therapeuticAreasCodes": {"title": "Therapeuticareascodes", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "therapeuticAreasNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "diseaseConditionsOrIndicationsCodes": {"title": "Diseaseconditionsorindicationscodes", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "diseaseConditionsOrIndicationsNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "diagnosisGroupsCodes": {"title": "Diagnosisgroupscodes", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "diagnosisGroupsNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "sexOfParticipantsCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "sexOfParticipantsNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "rareDiseaseIndicator": {"title": "Rarediseaseindicator", "type": "boolean"}, "rareDiseaseIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "healthySubjectIndicator": {"title": "Healthysubjectindicator", "type": "boolean"}, "healthySubjectIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "plannedMinimumAgeOfSubjects": {"$ref": "#/components/schemas/DurationJsonModel"}, "plannedMinimumAgeOfSubjectsNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "plannedMaximumAgeOfSubjects": {"$ref": "#/components/schemas/DurationJsonModel"}, "plannedMaximumAgeOfSubjectsNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "stableDiseaseMinimumDuration": {"$ref": "#/components/schemas/DurationJsonModel"}, "stableDiseaseMinimumDurationNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "pediatricStudyIndicator": {"title": "Pediatricstudyindicator", "type": "boolean"}, "pediatricStudyIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "pediatricPostmarketStudyIndicator": {"title": "Pediatricpostmarketstudyindicator", "type": "boolean"}, "pediatricPostmarketStudyIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "pediatricInvestigationPlanIndicator": {"title": "Pediatricinvestigationplanindicator", "type": "boolean"}, "pediatricInvestigationPlanIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "relapseCriteria": {"title": "Relapsecriteria", "type": "string"}, "relapseCriteriaNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "numberOfExpectedSubjects": {"title": "Numberofexpectedsubjects", "type": "integer"}, "numberOfExpectedSubjectsNullValueCode": {"$ref": "#/components/schemas/SimpleTermModel"}}}, "StudyPopulationListingModel": {"title": "Study population model for listing", "type": "object", "properties": {"therapeuticAreasCodes": {"title": "Therapeuticareascodes", "type": "array", "items": {"$ref": "#/components/schemas/SimpleListingCTModel"}}, "therapeuticAreasNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "diseaseConditionsOrIndicationsCodes": {"title": "Diseaseconditionsorindicationscodes", "type": "array", "items": {"$ref": "#/components/schemas/SimpleListingCTModel"}}, "diseaseConditionsOrIndicationsNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "diagnosisGroupsCodes": {"title": "Diagnosisgroupscodes", "type": "array", "items": {"$ref": "#/components/schemas/SimpleListingCTModel"}}, "diagnosisGroupsNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "sexOfParticipantsCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "sexOfParticipantsNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "rareDiseaseIndicator": {"title": "Rarediseaseindicator", "type": "boolean"}, "rareDiseaseIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "healthySubjectIndicator": {"title": "Healthysubjectindicator", "type": "boolean"}, "healthySubjectIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "plannedMinimumAgeOfSubjects": {"title": "Plannedminimumageofsubjects", "type": "string"}, "plannedMinimumAgeOfSubjectsNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "plannedMaximumAgeOfSubjects": {"title": "Plannedmaximumageofsubjects", "type": "string"}, "plannedMaximumAgeOfSubjectsNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "stableDiseaseMinimumDuration": {"title": "Stablediseaseminimumduration", "type": "string"}, "stableDiseaseMinimumDurationNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "pediatricStudyIndicator": {"title": "Pediatricstudyindicator", "type": "boolean"}, "pediatricStudyIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "pediatricPostmarketStudyIndicator": {"title": "Pediatricpostmarketstudyindicator", "type": "boolean"}, "pediatricPostmarketStudyIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "pediatricInvestigationPlanIndicator": {"title": "Pediatricinvestigationplanindicator", "type": "boolean"}, "pediatricInvestigationPlanIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "relapseCriteria": {"title": "Relapsecriteria", "type": "string"}, "relapseCriteriaNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "numberOfExpectedSubjects": {"title": "Numberofexpectedsubjects", "type": "integer"}, "numberOfExpectedSubjectsNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}}}, "StudyProtocolTitle": {"title": "StudyProtocolTitle", "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The unique id of the study."}, "studyTitle": {"title": "Studytitle", "type": "string"}, "studyShortTitle": {"title": "Studyshorttitle", "type": "string"}, "eudractId": {"title": "Eudractid", "type": "string"}, "universalTrialNumberUTN": {"title": "Universaltrialnumberutn", "type": "string"}, "trialPhaseCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "indNumber": {"title": "Indnumber", "type": "string"}, "substanceName": {"title": "Substancename", "type": "string"}}}, "StudySelectionActivity": {"title": "StudySelectionActivity", "required": ["studyUid", "order", "studyActivityUid", "activity", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "showActivityGroupInProtocolFlowchart": {"title": "showActivityGroupInProtocolFlowchart", "type": "boolean", "description": "show activity group in protocol flow chart"}, "showActivitySubGroupInProtocolFlowchart": {"title": "showActivitySubGroupInProtocolFlowchart", "type": "boolean", "description": "show activity sub group in protocol flow chart"}, "showActivityInProtocolFlowchart": {"title": "showActivityInProtocolFlowchart", "type": "boolean", "description": "show activity in protocol flow chart"}, "studyActivityUid": {"title": "studyActivityUid", "type": "string", "description": "uid for the study activity"}, "activity": {"title": "activity", "allOf": [{"$ref": "#/components/schemas/Activity"}], "description": "the activity selected for the study"}, "flowchartGroup": {"title": "flowchartGroup", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "flow chart group linked to this study activity"}, "note": {"title": "note", "type": "string", "description": "Foot note to display in flowchart"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "latestActivity": {"title": "latestActivity", "allOf": [{"$ref": "#/components/schemas/Activity"}], "description": "Latest version of activity selected for study."}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete activity versions"}}}, "StudySelectionActivityBatchDeleteInput": {"title": "StudySelectionActivityBatchDeleteInput", "required": ["studyActivityUid"], "type": "object", "properties": {"studyActivityUid": {"title": "studyActivityUid", "type": "string", "description": "UID of the study activity to delete"}}}, "StudySelectionActivityBatchInput": {"title": "StudySelectionActivityBatchInput", "required": ["method", "content"], "type": "object", "properties": {"method": {"title": "method", "type": "string", "description": "HTTP method corresponding to operation type"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/StudySelectionActivityBatchUpdateInput"}, {"$ref": "#/components/schemas/StudySelectionActivityCreateInput"}, {"$ref": "#/components/schemas/StudySelectionActivityBatchDeleteInput"}]}}}, "StudySelectionActivityBatchOutput": {"title": "StudySelectionActivityBatchOutput", "required": ["responseCode"], "type": "object", "properties": {"responseCode": {"title": "responseCode", "type": "integer", "description": "The HTTP response code related to input operation"}, "content": {"title": "Content", "anyOf": [{"$ref": "#/components/schemas/StudySelectionActivity"}, {"$ref": "#/components/schemas/BatchErrorResponse"}]}}}, "StudySelectionActivityBatchUpdateInput": {"title": "StudySelectionActivityBatchUpdateInput", "required": ["studyActivityUid", "content"], "type": "object", "properties": {"studyActivityUid": {"title": "studyActivityUid", "type": "string", "description": "UID of the Study Activity to update"}, "content": {"$ref": "#/components/schemas/StudySelectionActivityInput"}}}, "StudySelectionActivityCore": {"title": "StudySelectionActivityCore", "required": ["studyUid", "order", "studyActivityUid", "activity", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "showActivityGroupInProtocolFlowchart": {"title": "showActivityGroupInProtocolFlowchart", "type": "boolean", "description": "show activity group in protocol flow chart"}, "showActivitySubGroupInProtocolFlowchart": {"title": "showActivitySubGroupInProtocolFlowchart", "type": "boolean", "description": "show activity sub group in protocol flow chart"}, "showActivityInProtocolFlowchart": {"title": "showActivityInProtocolFlowchart", "type": "boolean", "description": "show activity in protocol flow chart"}, "studyActivityUid": {"title": "studyActivityUid", "type": "string", "description": "uid for the study activity"}, "activity": {"title": "activity", "allOf": [{"$ref": "#/components/schemas/Activity"}], "description": "the activity selected for the study"}, "flowchartGroup": {"title": "flowchartGroup", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "flow chart group linked to this study activity"}, "note": {"title": "note", "type": "string", "description": "Foot note to display in flowchart"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}}}, "StudySelectionActivityCreateInput": {"title": "StudySelectionActivityCreateInput", "required": ["flowchartGroupUid", "activityUid"], "type": "object", "properties": {"flowchartGroupUid": {"title": "flowchartGroupUid", "type": "string", "description": "flowchart CT term uid"}, "activityUid": {"title": "activityUid", "type": "string", "description": "activity uid"}, "activityInstanceUid": {"title": "activityInstanceUid", "type": "string", "description": "activity instance uid"}}}, "StudySelectionActivityInput": {"title": "StudySelectionActivityInput", "type": "object", "properties": {"showActivityGroupInProtocolFlowchart": {"title": "showActivityGroupInProtocolFlowchart", "type": "boolean", "description": "show activity group in protocol flow chart"}, "showActivitySubGroupInProtocolFlowchart": {"title": "showActivitySubGroupInProtocolFlowchart", "type": "boolean", "description": "show activity sub group in protocol flow chart"}, "showActivityInProtocolFlowchart": {"title": "showActivityInProtocolFlowchart", "type": "boolean", "description": "show activity in protocol flow chart"}, "flowchartGroupUid": {"title": "flowchartGroupUid", "type": "string", "description": "flowchart CT term uid"}, "note": {"title": "note", "type": "string", "description": "Foot note to display in flowchart"}}}, "StudySelectionActivityNewOrder": {"title": "StudySelectionActivityNewOrder", "required": ["new_order"], "type": "object", "properties": {"new_order": {"title": "new_order", "type": "integer", "description": "new order selected for the study activity"}}}, "StudySelectionArm": {"title": "StudySelectionArm", "required": ["studyUid", "order", "armUid", "name", "shortName", "code", "description", "armColour", "randomizationGroup", "numberOfSubjects", "armType", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "armUid": {"title": "studyArmUid", "type": "string", "description": "uid for the study arm"}, "name": {"title": "studyArmName", "type": "string", "description": "name for the study arm"}, "shortName": {"title": "studyArmShortName", "type": "string", "description": "short name for the study arm"}, "code": {"title": "studyArmCode", "type": "string", "description": "code for the study arm"}, "description": {"title": "studyArmDescription", "type": "string", "description": "description for the study arm"}, "armColour": {"title": "studyArmColour", "type": "string", "description": "colour for the study arm"}, "randomizationGroup": {"title": "studyArmRandomizationGroup", "type": "string", "description": "randomization group for the study arm"}, "numberOfSubjects": {"title": "studyArmNumberOfSubjects", "type": "integer", "description": "number of subjects for the study arm"}, "armType": {"title": "studyArmType", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "type for the study arm"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}}}, "StudySelectionArmCreateInput": {"title": "StudySelectionArmCreateInput", "type": "object", "properties": {"name": {"title": "studyArmName", "type": "string", "description": "name for the study arm"}, "shortName": {"title": "studyArmShortName", "type": "string", "description": "short name for the study arm"}, "code": {"title": "studyArmCode", "type": "string", "description": "code for the study arm"}, "description": {"title": "studyDescription", "type": "string", "description": "description for the study arm"}, "armColour": {"title": "studyArmColour", "type": "string", "description": "colour for the study arm"}, "randomizationGroup": {"title": "studyArmRandomizationGroup", "type": "string", "description": "randomization group for the study arm"}, "numberOfSubjects": {"title": "studyArmNumberOfSubjects", "type": "integer", "description": "number of subjects for the study arm"}, "armTypeUid": {"title": "studyArmTypeUid", "type": "string", "description": "uid for the study arm"}}}, "StudySelectionArmInput": {"title": "StudySelectionArmInput", "type": "object", "properties": {"name": {"title": "studyArmName", "type": "string", "description": "name for the study arm"}, "shortName": {"title": "studyArmShortName", "type": "string", "description": "short name for the study arm"}, "code": {"title": "studyArmCode", "type": "string", "description": "code for the study arm"}, "description": {"title": "studyDescription", "type": "string", "description": "description for the study arm"}, "armColour": {"title": "studyArmColour", "type": "string", "description": "colour for the study arm"}, "randomizationGroup": {"title": "studyArmRandomizationGroup", "type": "string", "description": "randomization group for the study arm"}, "numberOfSubjects": {"title": "studyArmNumberOfSubjects", "type": "integer", "description": "number of subjects for the study arm"}, "armTypeUid": {"title": "studyArmTypeUid", "type": "string", "description": "uid for the study arm"}, "armUid": {"title": "studyArmUid", "type": "string", "description": "uid for the study arm"}}}, "StudySelectionArmNewOrder": {"title": "StudySelectionArmNewOrder", "required": ["new_order"], "type": "object", "properties": {"new_order": {"title": "new_order", "type": "integer", "description": "new order of the selected arm"}}}, "StudySelectionArmVersion": {"title": "StudySelectionArmVersion", "required": ["studyUid", "order", "armUid", "name", "shortName", "code", "description", "armColour", "randomizationGroup", "numberOfSubjects", "armType", "startDate", "userInitials", "changes"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "armUid": {"title": "studyArmUid", "type": "string", "description": "uid for the study arm"}, "name": {"title": "studyArmName", "type": "string", "description": "name for the study arm"}, "shortName": {"title": "studyArmShortName", "type": "string", "description": "short name for the study arm"}, "code": {"title": "studyArmCode", "type": "string", "description": "code for the study arm"}, "description": {"title": "studyArmDescription", "type": "string", "description": "description for the study arm"}, "armColour": {"title": "studyArmColour", "type": "string", "description": "colour for the study arm"}, "randomizationGroup": {"title": "studyArmRandomizationGroup", "type": "string", "description": "randomization group for the study arm"}, "numberOfSubjects": {"title": "studyArmNumberOfSubjects", "type": "integer", "description": "number of subjects for the study arm"}, "armType": {"title": "studyArmType", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "type for the study arm"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}, "changes": {"title": "Changes", "type": "object"}}}, "StudySelectionArmWithConnectedBranchArms": {"title": "StudySelectionArmWithConnectedBranchArms", "required": ["studyUid", "order", "armUid", "name", "shortName", "code", "description", "armColour", "randomizationGroup", "numberOfSubjects", "armType", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "armUid": {"title": "studyArmUid", "type": "string", "description": "uid for the study arm"}, "name": {"title": "studyArmName", "type": "string", "description": "name for the study arm"}, "shortName": {"title": "studyArmShortName", "type": "string", "description": "short name for the study arm"}, "code": {"title": "studyArmCode", "type": "string", "description": "code for the study arm"}, "description": {"title": "studyArmDescription", "type": "string", "description": "description for the study arm"}, "armColour": {"title": "studyArmColour", "type": "string", "description": "colour for the study arm"}, "randomizationGroup": {"title": "studyArmRandomizationGroup", "type": "string", "description": "randomization group for the study arm"}, "numberOfSubjects": {"title": "studyArmNumberOfSubjects", "type": "integer", "description": "number of subjects for the study arm"}, "armType": {"title": "studyArmType", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "type for the study arm"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}, "armConnectedBranchArms": {"title": "studyBranchArms", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionBranchArmWithoutStudyArm"}, "description": "lsit of study branch arms connected to arm"}}}, "StudySelectionBranchArm": {"title": "StudySelectionBranchArm", "required": ["studyUid", "order", "branchArmUid", "name", "shortName", "code", "description", "colourCode", "randomizationGroup", "numberOfSubjects", "startDate", "userInitials", "armRoot"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "branchArmUid": {"title": "studyBranchArmUid", "type": "string", "description": "uid for the study BranchArm"}, "name": {"title": "studyBranchArmName", "type": "string", "description": "name for the study Brancharm"}, "shortName": {"title": "studyBranchArmShortName", "type": "string", "description": "short name for the study Brancharm"}, "code": {"title": "studyBranchArmCode", "type": "string", "description": "code for the study Brancharm"}, "description": {"title": "studyBranchArmDescription", "type": "string", "description": "description for the study Brancharm"}, "colourCode": {"title": "studyBranchArmcolourCode", "type": "string", "description": "colourCode for the study Brancharm"}, "randomizationGroup": {"title": "studyBranchArmRandomizationGroup", "type": "string", "description": "randomization group for the study Brancharm"}, "numberOfSubjects": {"title": "studyBranchArmNumberOfSubjects", "type": "integer", "description": "number of subjects for the study Brancharm"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}, "armRoot": {"title": "studyArmRoot", "allOf": [{"$ref": "#/components/schemas/StudySelectionArm"}], "description": "Root for the study branch arm"}}}, "StudySelectionBranchArmCreateInput": {"title": "StudySelectionBranchArmCreateInput", "type": "object", "properties": {"name": {"title": "studyBranchArmName", "type": "string", "description": "name for the study Brancharm"}, "shortName": {"title": "studyBranchArmShortName", "type": "string", "description": "short name for the study Brancharm"}, "code": {"title": "studyBranchArmCode", "type": "string", "description": "code for the study Brancharm"}, "description": {"title": "studyDescription", "type": "string", "description": "description for the study Brancharm"}, "colourCode": {"title": "studycolourCode", "type": "string", "description": "colourCode for the study Brancharm"}, "randomizationGroup": {"title": "studyBranchArmRandomizationGroup", "type": "string", "description": "randomization group for the study Brancharm"}, "numberOfSubjects": {"title": "studyBranchArmNumberOfSubjects", "type": "integer", "description": "number of subjects for the study Brancharm"}, "armUid": {"title": "studyArmtUid", "type": "string", "description": "uid for the study arm"}}}, "StudySelectionBranchArmEditInput": {"title": "StudySelectionBranchArmEditInput", "type": "object", "properties": {"name": {"title": "studyBranchArmName", "type": "string", "description": "name for the study Brancharm"}, "shortName": {"title": "studyBranchArmShortName", "type": "string", "description": "short name for the study Brancharm"}, "code": {"title": "studyBranchArmCode", "type": "string", "description": "code for the study Brancharm"}, "description": {"title": "studyDescription", "type": "string", "description": "description for the study Brancharm"}, "colourCode": {"title": "studycolourCode", "type": "string", "description": "colourCode for the study Brancharm"}, "randomizationGroup": {"title": "studyBranchArmRandomizationGroup", "type": "string", "description": "randomization group for the study Brancharm"}, "numberOfSubjects": {"title": "studyBranchArmNumberOfSubjects", "type": "integer", "description": "number of subjects for the study Brancharm"}, "armUid": {"title": "studyArmtUid", "type": "string", "description": "uid for the study arm"}, "branchArmUid": {"title": "studyBranchArmUid", "type": "string", "description": "uid for the study branch arm"}}}, "StudySelectionBranchArmNewOrder": {"title": "StudySelectionBranchArmNewOrder", "required": ["new_order"], "type": "object", "properties": {"new_order": {"title": "new_order", "type": "integer", "description": "new order of the selected branch arm"}}}, "StudySelectionBranchArmVersion": {"title": "StudySelectionBranchArmVersion", "required": ["studyUid", "order", "branchArmUid", "name", "shortName", "code", "description", "colourCode", "randomizationGroup", "numberOfSubjects", "startDate", "userInitials", "armRootUid", "changes"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "branchArmUid": {"title": "studyBranchArmUid", "type": "string", "description": "uid for the study BranchArm"}, "name": {"title": "studyBranchArmName", "type": "string", "description": "name for the study Brancharm"}, "shortName": {"title": "studyBranchArmShortName", "type": "string", "description": "short name for the study Brancharm"}, "code": {"title": "studyBranchArmCode", "type": "string", "description": "code for the study Brancharm"}, "description": {"title": "studyBranchArmDescription", "type": "string", "description": "description for the study Brancharm"}, "colourCode": {"title": "studyBranchArmcolourCode", "type": "string", "description": "colourCode for the study Brancharm"}, "randomizationGroup": {"title": "studyBranchArmRandomizationGroup", "type": "string", "description": "randomization group for the study Brancharm"}, "numberOfSubjects": {"title": "studyBranchArmNumberOfSubjects", "type": "integer", "description": "number of subjects for the study Brancharm"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}, "armRootUid": {"title": "studyArmRootUid", "type": "string", "description": "Uid Root for the study branch arm"}, "changes": {"title": "Changes", "type": "object"}}, "description": "Class created to describe Study BranchArm History, it specifies the ArmRootUid instead of ArmRoot to handle non longer existent Arms"}, "StudySelectionBranchArmWithoutStudyArm": {"title": "StudySelectionBranchArmWithoutStudyArm", "required": ["studyUid", "order", "branchArmUid", "name", "shortName", "code", "description", "colourCode", "randomizationGroup", "numberOfSubjects", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "branchArmUid": {"title": "studyBranchArmUid", "type": "string", "description": "uid for the study BranchArm"}, "name": {"title": "studyBranchArmName", "type": "string", "description": "name for the study Brancharm"}, "shortName": {"title": "studyBranchArmShortName", "type": "string", "description": "short name for the study Brancharm"}, "code": {"title": "studyBranchArmCode", "type": "string", "description": "code for the study Brancharm"}, "description": {"title": "studyBranchArmDescription", "type": "string", "description": "description for the study Brancharm"}, "colourCode": {"title": "studyBranchArmcolourCode", "type": "string", "description": "colourCode for the study Brancharm"}, "randomizationGroup": {"title": "studyBranchArmRandomizationGroup", "type": "string", "description": "randomization group for the study Brancharm"}, "numberOfSubjects": {"title": "studyBranchArmNumberOfSubjects", "type": "integer", "description": "number of subjects for the study Brancharm"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}}}, "StudySelectionCohort": {"title": "StudySelectionCohort", "required": ["studyUid", "order", "cohortUid", "name", "shortName", "description", "colourCode", "numberOfSubjects", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "cohortUid": {"title": "studyCohortUid", "type": "string", "description": "uid for the study Cohort"}, "name": {"title": "studyCohortName", "type": "string", "description": "name for the study Cohort"}, "shortName": {"title": "studyCohortShortName", "type": "string", "description": "short name for the study Cohort"}, "code": {"title": "studyCohortCode", "type": "string", "description": "code for the study Cohort"}, "description": {"title": "studyCohortDescription", "type": "string", "description": "description for the study Cohort"}, "colourCode": {"title": "studyCohortColourCode", "type": "string", "description": "colour code for the study Cohort"}, "numberOfSubjects": {"title": "studyCohortNumberOfSubjects", "type": "integer", "description": "number of subjects for the study Cohort"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}, "branchArmRoots": {"title": "studyBranchArmRoots", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionBranchArm"}, "description": "Branch Arm Roots for the study Cohort"}, "armRoots": {"title": "studyArmRoots", "type": "array", "items": {"$ref": "#/components/schemas/StudySelectionArm"}, "description": "ArmRoots for the study Cohort"}}}, "StudySelectionCohortCreateInput": {"title": "StudySelectionCohortCreateInput", "type": "object", "properties": {"name": {"title": "studyCohortName", "type": "string", "description": "name for the study Cohort"}, "shortName": {"title": "studyCohortShortName", "type": "string", "description": "short name for the study Cohort"}, "code": {"title": "studyCohortCode", "type": "string", "description": "code for the study Cohort"}, "description": {"title": "studyDescription", "type": "string", "description": "description for the study Cohort"}, "colourCode": {"title": "studyCohortColourCode", "type": "string", "description": "colour code for the study Cohort"}, "numberOfSubjects": {"title": "studyCohortNumberOfSubjects", "type": "integer", "description": "number of subjects for the study Cohort"}, "branchArmUids": {"title": "studybranchArmUid", "type": "array", "items": {"type": "string"}, "description": "uid for the study branch arm"}, "armUids": {"title": "studyArmtUid", "type": "array", "items": {"type": "string"}, "description": "uid for the study arm"}}}, "StudySelectionCohortEditInput": {"title": "StudySelectionCohortEditInput", "type": "object", "properties": {"name": {"title": "studyCohortName", "type": "string", "description": "name for the study Cohort"}, "shortName": {"title": "studyCohortShortName", "type": "string", "description": "short name for the study Cohort"}, "code": {"title": "studyCohortCode", "type": "string", "description": "code for the study Cohort"}, "description": {"title": "studyDescription", "type": "string", "description": "description for the study Cohort"}, "colourCode": {"title": "studyCohortColourCode", "type": "string", "description": "colour code for the study Cohort"}, "numberOfSubjects": {"title": "studyCohortNumberOfSubjects", "type": "integer", "description": "number of subjects for the study Cohort"}, "branchArmUids": {"title": "studybranchArmUid", "type": "array", "items": {"type": "string"}, "description": "uid for the study branch arm"}, "armUids": {"title": "studyArmtUid", "type": "array", "items": {"type": "string"}, "description": "uid for the study arm"}, "cohortUid": {"title": "studyCohortUid", "type": "string", "description": "uid for the study Cohort"}}}, "StudySelectionCohortNewOrder": {"title": "StudySelectionCohortNewOrder", "required": ["new_order"], "type": "object", "properties": {"new_order": {"title": "new_order", "type": "integer", "description": "new order of the selected Cohort"}}}, "StudySelectionCohortVersion": {"title": "StudySelectionCohortVersion", "required": ["studyUid", "order", "cohortUid", "name", "shortName", "description", "colourCode", "numberOfSubjects", "startDate", "userInitials", "changes"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "cohortUid": {"title": "studyCohortUid", "type": "string", "description": "uid for the study Cohort"}, "name": {"title": "studyCohortName", "type": "string", "description": "name for the study Cohort"}, "shortName": {"title": "studyCohortShortName", "type": "string", "description": "short name for the study Cohort"}, "code": {"title": "studyCohortCode", "type": "string", "description": "code for the study Cohort"}, "description": {"title": "studyCohortDescription", "type": "string", "description": "description for the study Cohort"}, "colourCode": {"title": "studyCohortColourCode", "type": "string", "description": "colour code for the study Cohort"}, "numberOfSubjects": {"title": "studyCohortNumberOfSubjects", "type": "integer", "description": "number of subjects for the study Cohort"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}, "branchArmRootsUids": {"title": "studyBranchArmRootsUids", "type": "array", "items": {"type": "string"}, "description": "Branch Arm Roots Uids for the study Cohort"}, "armRootsUids": {"title": "studyArmRootsUids", "type": "array", "items": {"type": "string"}, "description": "ArmRoots Uids for the study Cohort"}, "changes": {"title": "Changes", "type": "object"}}}, "StudySelectionCompound": {"title": "StudySelectionCompound", "required": ["studyUid", "order", "studyCompoundUid", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "studyCompoundUid": {"title": "studyCompoundUid", "type": "string", "description": "uid for the study compound"}, "compound": {"title": "compound", "allOf": [{"$ref": "#/components/schemas/Compound"}], "description": "the connected compound model"}, "compoundAlias": {"title": "compoundAlias", "allOf": [{"$ref": "#/components/schemas/CompoundAlias"}], "description": "the connected compound alias"}, "typeOfTreatment": {"title": "typeOfTreatment", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}], "description": "type of treatment uid defined for the selection"}, "routeOfAdministration": {"title": "routeOfAdministration", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}], "description": "route of administration defined for the study selection"}, "strengthValue": {"title": "strength", "allOf": [{"$ref": "#/components/schemas/SimpleNumericValueWithUnit"}], "description": "compound strength defined for the study selection"}, "dosageForm": {"title": "dosageForm", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}], "description": "dosage form defined for the study selection"}, "dispensedIn": {"title": "dispensedIn", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}], "description": "dispense method defined for the study selection"}, "device": {"title": "device", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}], "description": "device used for the compound in the study selection"}, "formulation": {"title": "formulation", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}], "description": "formulation defined for the study selection"}, "otherInfo": {"title": "otherInfo", "type": "string", "description": "any other information logged regarding the study compound"}, "reasonForMissingNullValue": {"title": "reasonForMissingNullValue", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}], "description": "Reason why no compound is used in the study selection, e.g. exploratory study"}, "studyCompoundDosingCount": {"title": "Studycompounddosingcount", "type": "integer", "description": "Number of compound dosing linked to Study Compound"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "End date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}}}, "StudySelectionCompoundInput": {"title": "StudySelectionCompoundInput", "type": "object", "properties": {"compoundAliasUid": {"title": "compoundAliasUid", "type": "string", "description": "uid for the library compound alias"}, "typeOfTreatmentUid": {"title": "typeOfTreatmentUid", "type": "string", "description": "type of treatment defined for the selection"}, "routeOfAdministrationUid": {"title": "routeOfAdministrationUid", "type": "string", "description": "route of administration defined for the study selection"}, "strengthValueUid": {"title": "strengthValueUid", "type": "string", "description": "compound strength defined for the study selection"}, "dosageFormUid": {"title": "dosageFormUid", "type": "string", "description": "dosage form defined for the study selection"}, "dispensedInUid": {"title": "dispensedInUid", "type": "string", "description": "dispense method defined for the study selection"}, "deviceUid": {"title": "deviceUid", "type": "string", "description": "device used for the compound in the study selection"}, "formulationUid": {"title": "formulationUid", "type": "string", "description": "formulation defined for the study selection"}, "otherInfo": {"title": "otherInfo", "type": "string", "description": "any other information logged regarding the study compound"}, "reasonForMissingNullValueUid": {"title": "reasonForMissingNullValueUid", "type": "string", "description": "Reason why no compound is used in the study selection, e.g. exploratory study"}}}, "StudySelectionCompoundNewOrder": {"title": "StudySelectionCompoundNewOrder", "required": ["new_order"], "type": "object", "properties": {"new_order": {"title": "new_order", "type": "integer", "description": "new order selected for the study compound"}}}, "StudySelectionCriteria": {"title": "StudySelectionCriteria", "required": ["studyUid", "order", "studyCriteriaUid", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "studyCriteriaUid": {"title": "studyCriteriaUid", "type": "string", "description": "uid for the study criteria"}, "criteriaType": {"title": "criteriaType", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "Type of criteria"}, "criteria": {"title": "criteria", "allOf": [{"$ref": "#/components/schemas/Criteria"}], "description": "the criteria selected for the study"}, "criteriaTemplate": {"title": "criteriaTemplate", "allOf": [{"$ref": "#/components/schemas/CriteriaTemplate"}], "description": "the criteria template selected for the study"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "keyCriteria": {"title": "keyCriteria", "type": "boolean", "default": false}, "latestCriteria": {"title": "latestCriteria", "allOf": [{"$ref": "#/components/schemas/Criteria"}], "description": "Latest version of criteria selected for study."}, "latestTemplate": {"title": "latestTemplate", "allOf": [{"$ref": "#/components/schemas/CriteriaTemplate"}], "description": "Latest version of criteria template selected for study."}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete criteria versions"}}}, "StudySelectionCriteriaCore": {"title": "StudySelectionCriteriaCore", "required": ["studyUid", "order", "studyCriteriaUid", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "studyCriteriaUid": {"title": "studyCriteriaUid", "type": "string", "description": "uid for the study criteria"}, "criteriaType": {"title": "criteriaType", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "Type of criteria"}, "criteria": {"title": "criteria", "allOf": [{"$ref": "#/components/schemas/Criteria"}], "description": "the criteria selected for the study"}, "criteriaTemplate": {"title": "criteriaTemplate", "allOf": [{"$ref": "#/components/schemas/CriteriaTemplate"}], "description": "the criteria template selected for the study"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "keyCriteria": {"title": "keyCriteria", "type": "boolean", "default": false}}}, "StudySelectionCriteriaCreateInput": {"title": "StudySelectionCriteriaCreateInput", "required": ["criteriaData"], "type": "object", "properties": {"criteriaData": {"title": "criteriaData", "allOf": [{"$ref": "#/components/schemas/CriteriaCreateInput"}], "description": "Criteria data to create new criteria"}}}, "StudySelectionCriteriaKeyCriteria": {"title": "StudySelectionCriteriaKeyCriteria", "required": ["key_criteria"], "type": "object", "properties": {"key_criteria": {"title": "key_criteria", "type": "boolean", "description": "New value to set for the key_criteria property of the selection"}}}, "StudySelectionCriteriaNewOrder": {"title": "StudySelectionCriteriaNewOrder", "required": ["new_order"], "type": "object", "properties": {"new_order": {"title": "new_order", "type": "integer", "description": "New value to set for the order property of the selection"}}}, "StudySelectionCriteriaTemplateSelectInput": {"title": "StudySelectionCriteriaTemplateSelectInput", "required": ["criteriaTemplateUid"], "type": "object", "properties": {"criteriaTemplateUid": {"title": "criteriaTemplateUid", "type": "string", "description": "The unique id of the criteria template that is to be selected."}, "libraryName": {"title": "libraryName", "type": "string", "description": "If specified: The name of the library to which the criteria will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* criteria can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true. \n\nIf not specified: The library of the criteria template will be used."}}}, "StudySelectionElement": {"title": "StudySelectionElement", "required": ["studyUid", "order", "elementUid", "name", "shortName", "code", "description", "plannedDuration", "startRule", "endRule", "elementColour", "elementSubType", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "elementUid": {"title": "studyElementUid", "type": "string", "description": "uid for the study element"}, "name": {"title": "studyElementName", "type": "string", "description": "name for the study element"}, "shortName": {"title": "studyElementShortName", "type": "string", "description": "short name for the study element"}, "code": {"title": "studyElementCode", "type": "string", "description": "code for the study element"}, "description": {"title": "studyElementDescription", "type": "string", "description": "description for the study element"}, "plannedDuration": {"title": "studyElementPlannedDuration", "allOf": [{"$ref": "#/components/schemas/DurationJsonModel"}], "description": "planned_duration for the study element"}, "startRule": {"title": "studyElementStartRule", "type": "string", "description": "start_rule for the study element"}, "endRule": {"title": "studyElementEndRule", "type": "string", "description": "end_rule for the study element"}, "elementColour": {"title": "studyElementelementColour", "type": "string", "description": "elementColour for the study element"}, "elementSubType": {"title": "studyElementSubType", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "subtype for the study element"}, "studyCompoundDosingCount": {"title": "Studycompounddosingcount", "type": "integer", "description": "Number of compound dosing linked to Study Element"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}}}, "StudySelectionElementCreateInput": {"title": "StudySelectionElementCreateInput", "type": "object", "properties": {"name": {"title": "studyElementName", "type": "string", "description": "name for the study element"}, "shortName": {"title": "studyElementShortName", "type": "string", "description": "short name for the study element"}, "code": {"title": "studyElementCode", "type": "string", "description": "code for the study element"}, "description": {"title": "studyDescription", "type": "string", "description": "description for the study element"}, "plannedDuration": {"title": "studyElementPlannedDuration", "allOf": [{"$ref": "#/components/schemas/DurationJsonModel"}], "description": "planned_duration for the study element"}, "startRule": {"title": "studyElementStartRule", "type": "string", "description": "start_rule for the study element"}, "endRule": {"title": "studyElementEndRule", "type": "string", "description": "end_rule for the study element"}, "elementColour": {"title": "studyelementColour", "type": "string", "description": "element_colour for the study element"}, "elementSubTypeUid": {"title": "studyElementSubTypeUid", "type": "string", "description": "uid for the study element"}}}, "StudySelectionElementInput": {"title": "StudySelectionElementInput", "type": "object", "properties": {"name": {"title": "studyElementName", "type": "string", "description": "name for the study element"}, "shortName": {"title": "studyElementShortName", "type": "string", "description": "short name for the study element"}, "code": {"title": "studyElementCode", "type": "string", "description": "code for the study element"}, "description": {"title": "studyDescription", "type": "string", "description": "description for the study element"}, "plannedDuration": {"title": "studyElementPlannedDuration", "allOf": [{"$ref": "#/components/schemas/DurationJsonModel"}], "description": "planned_duration for the study element"}, "startRule": {"title": "studyElementStartRule", "type": "string", "description": "start_rule for the study element"}, "endRule": {"title": "studyElementEndRule", "type": "string", "description": "end_rule for the study element"}, "elementColour": {"title": "studyelementColour", "type": "string", "description": "element_colour for the study element"}, "elementSubTypeUid": {"title": "studyElementSubTypeUid", "type": "string", "description": "uid for the study element"}, "elementUid": {"title": "studyElementUid", "type": "string", "description": "uid for the study element"}}}, "StudySelectionElementNewOrder": {"title": "StudySelectionElementNewOrder", "required": ["new_order"], "type": "object", "properties": {"new_order": {"title": "new_order", "type": "integer", "description": "new order of the selected element"}}}, "StudySelectionElementVersion": {"title": "StudySelectionElementVersion", "required": ["studyUid", "order", "elementUid", "name", "shortName", "code", "description", "plannedDuration", "startRule", "endRule", "elementColour", "elementSubType", "startDate", "userInitials", "changes"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "elementUid": {"title": "studyElementUid", "type": "string", "description": "uid for the study element"}, "name": {"title": "studyElementName", "type": "string", "description": "name for the study element"}, "shortName": {"title": "studyElementShortName", "type": "string", "description": "short name for the study element"}, "code": {"title": "studyElementCode", "type": "string", "description": "code for the study element"}, "description": {"title": "studyElementDescription", "type": "string", "description": "description for the study element"}, "plannedDuration": {"title": "studyElementPlannedDuration", "allOf": [{"$ref": "#/components/schemas/DurationJsonModel"}], "description": "planned_duration for the study element"}, "startRule": {"title": "studyElementStartRule", "type": "string", "description": "start_rule for the study element"}, "endRule": {"title": "studyElementEndRule", "type": "string", "description": "end_rule for the study element"}, "elementColour": {"title": "studyElementelementColour", "type": "string", "description": "elementColour for the study element"}, "elementSubType": {"title": "studyElementSubType", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "subtype for the study element"}, "studyCompoundDosingCount": {"title": "Studycompounddosingcount", "type": "integer", "description": "Number of compound dosing linked to Study Element"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}, "changes": {"title": "Changes", "type": "object"}}}, "StudySelectionEndpoint": {"title": "StudySelectionEndpoint", "required": ["studyUid", "order", "studyEndpointUid", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "studyEndpointUid": {"title": "studyEndpointUid", "type": "string", "description": "uid for the study endpoint"}, "studyObjective": {"title": "studyObjectiveUid", "allOf": [{"$ref": "#/components/schemas/StudySelectionObjective"}], "description": "uid for the study objective which the study endpoints connects to"}, "endpointLevel": {"title": "endpointLevel", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "level defining the endpoint"}, "endpointSubLevel": {"title": "endpointSubLevel", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "sub level defining the endpoint"}, "endpointUnits": {"title": "endpointUnits", "allOf": [{"$ref": "#/components/schemas/EndpointUnits"}], "description": "the endpoint units selected for the study endpoint"}, "endpoint": {"title": "endpoint", "allOf": [{"$ref": "#/components/schemas/Endpoint"}], "description": "the endpoint selected for the study"}, "timeframe": {"title": "timeframe", "allOf": [{"$ref": "#/components/schemas/Timeframe"}], "description": "the timeframe selected for the study"}, "latestEndpoint": {"title": "latestEndpoint", "allOf": [{"$ref": "#/components/schemas/Endpoint"}], "description": "Latest version of the endpoint selected for the study (if available else none)"}, "latestTimeframe": {"title": "latestTimeframe", "allOf": [{"$ref": "#/components/schemas/Timeframe"}], "description": "Latest version of the timeframe selected for the study (if available else none)"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete endpoint and timeframe versions"}}}, "StudySelectionEndpointCreateInput": {"title": "StudySelectionEndpointCreateInput", "required": ["endpointData"], "type": "object", "properties": {"studyObjectiveUid": {"title": "studyObjectiveUid", "type": "string", "description": "uid for a study objective to connect with"}, "endpointLevelUid": {"title": "endpoint level", "type": "string", "description": "level defining the endpoint"}, "endpointSubLevelUid": {"title": "endpoint sub level", "type": "string", "description": "sub level defining the endpoint"}, "endpointData": {"title": "endpointData", "allOf": [{"$ref": "#/components/schemas/EndpointCreateInput"}], "description": "endpoint data to create new endpoint"}, "endpointUnits": {"title": "endpointUnits", "allOf": [{"$ref": "#/components/schemas/EndpointUnits"}], "description": "hold the units used in the study endpoint"}, "timeframeUid": {"title": "timeframeUid", "type": "string", "description": "uid for a timeframe"}}}, "StudySelectionEndpointInput": {"title": "StudySelectionEndpointInput", "type": "object", "properties": {"studyObjectiveUid": {"title": "studyObjectiveUid", "type": "string", "description": "uid for a study objective to connect with"}, "endpointUid": {"title": "endpointUid", "type": "string", "description": "uid for a study objective to connect with"}, "endpointLevelUid": {"title": "endpoint level", "type": "string", "description": "level for the endpoint"}, "endpointSubLevelUid": {"title": "endpoint sub level", "type": "string", "description": "sub level for the endpoint"}, "timeframeUid": {"title": "timeframeUid", "type": "string", "description": "uid for a timeframe"}, "endpointUnits": {"title": "endpointUnits", "allOf": [{"$ref": "#/components/schemas/EndpointUnits"}], "description": "hold the units used in the study endpoint"}}}, "StudySelectionEndpointNewOrder": {"title": "StudySelectionEndpointNewOrder", "required": ["new_order"], "type": "object", "properties": {"new_order": {"title": "new_order", "type": "integer", "description": "Uid of the selected endpoint"}}}, "StudySelectionObjective": {"title": "StudySelectionObjective", "required": ["studyUid", "order", "studyObjectiveUid", "objective", "startDate", "userInitials", "latestObjective"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "studyObjectiveUid": {"title": "studyObjectiveUid", "type": "string", "description": "uid for the study objective"}, "objectiveLevel": {"title": "objectiveLevel", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "level defining the objective"}, "objective": {"title": "objective", "allOf": [{"$ref": "#/components/schemas/Objective"}], "description": "the objective selected for the study"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}, "endpointCount": {"title": "endpointCount", "type": "integer", "description": "Number of study endpoints related to given study objective."}, "latestObjective": {"title": "latestObjective", "allOf": [{"$ref": "#/components/schemas/Objective"}], "description": "Latest version of objective selected for study."}, "acceptedVersion": {"title": "Accepted Version", "type": "boolean", "description": "Denotes if user accepted obsolete objective versions"}}}, "StudySelectionObjectiveCore": {"title": "StudySelectionObjectiveCore", "required": ["studyUid", "order", "studyObjectiveUid", "objective", "startDate", "userInitials"], "type": "object", "properties": {"studyUid": {"title": "studyUid", "type": "string", "description": "The uid of the study"}, "order": {"title": "order", "type": "integer", "description": "The ordering of the selection"}, "projectNumber": {"title": "projectNumber", "type": "string", "description": "Number property of the project that the study belongs to"}, "projectName": {"title": "projectName", "type": "string", "description": "Name property of the project that the study belongs to"}, "studyObjectiveUid": {"title": "studyObjectiveUid", "type": "string", "description": "uid for the study objective"}, "objectiveLevel": {"title": "objectiveLevel", "allOf": [{"$ref": "#/components/schemas/CTTermName"}], "description": "level defining the objective"}, "objective": {"title": "objective", "allOf": [{"$ref": "#/components/schemas/Objective"}], "description": "the objective selected for the study"}, "startDate": {"title": "startDate", "type": "string", "description": "The most recent point in time when the study selection was edited.The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "userInitials": {"title": "userInitials", "type": "string", "description": "User initials for the version"}, "endDate": {"title": "endDate", "type": "string", "description": "Start date for the version", "format": "date-time"}, "status": {"title": "status", "type": "string", "description": "Change status"}, "changeType": {"title": "changeType", "type": "string", "description": "Type of last change for the version"}}}, "StudySelectionObjectiveCreateInput": {"title": "StudySelectionObjectiveCreateInput", "required": ["objectiveData"], "type": "object", "properties": {"objectiveLevelUid": {"title": "objectiveLevel", "type": "string", "description": "level defining the objective"}, "objectiveData": {"title": "objectiveData", "allOf": [{"$ref": "#/components/schemas/ObjectiveCreateInput"}], "description": "Objective data to create new objective"}}}, "StudySelectionObjectiveInput": {"title": "StudySelectionObjectiveInput", "type": "object", "properties": {"objectiveUid": {"title": "objectiveUid", "type": "string", "description": "Uid of the selected objective"}, "objectiveLevelUid": {"title": "objectiveLevel", "type": "string", "description": "level defining the objective"}}}, "StudySelectionObjectiveNewOrder": {"title": "StudySelectionObjectiveNewOrder", "required": ["new_order"], "type": "object", "properties": {"new_order": {"title": "new_order", "type": "integer", "description": "Uid of the selected objective"}}}, "StudySummaryListing": {"title": "StudySummaryListing", "required": ["STUDYID", "DOMAIN"], "type": "object", "properties": {"STUDYID": {"title": "Study Identifier", "type": "string", "description": "Unique identifier for a study."}, "DOMAIN": {"title": "Domain Abbreviation", "type": "string", "description": "Two-character abbreviation for the domain"}, "TSPARMCD": {"title": "Trial Summary Parameter Short Name", "type": "string", "description": "\n        TSPARMCD (the companion to TSPARM) is limited to 8 characters and does not have special character restrictions.\n        These values should be short for ease of use in programming, but it is not expected that TSPARMCD will need to\n        serve as variable names. Examples: AGEMIN, AGEMAX\n        "}, "TSPARM": {"title": "Trial Summary Parameter", "type": "string", "description": "\n        Term for the Trial Summary Parameter. The value in TSPARM cannot be longer than 40 characters.\n        Examples Planned Minimum Age of Subjects, Planned Maximum Age of Subjects\n        "}, "TSVAL": {"title": "Parameter Value", "anyOf": [{"type": "string"}, {"type": "array", "items": {}}], "description": "\n        Value of TSPARM. Example: \"ASTHMA\" when TSPARM value is \"Trial Indication\".\n        TSVAL can only be null when TSVALNF is populated. Text over 200 characters can be added to additional columns TSVAL1-TSVALn.\n        "}, "TSVALNF": {"title": "Parameter Null Flavor", "type": "string", "description": "\n        Null flavor for the value of TSPARM, to be populated if and only if TSVAL is null.\n        "}, "TSVALCD": {"title": "Parameter Value Code", "type": "string", "description": "\n        This is the code of the term in TSVAL. For example; 6CW7F3G59X is the code for Gabapentin,\n        C49488 is the code for Y. The length of this variable can be longer than 8 to accommodate\n        the length of the external terminology.\n        "}, "TSVCDREF": {"title": "Name of the Reference Terminology", "type": "string", "description": "The name of the Reference Terminology from which TSVALCD is taken. For example; CDISC, SNOMED, ISO 8601."}, "TSVCDVER": {"title": "Version of the Reference Terminology", "type": "string", "description": "The version number of the Reference Terminology, if applicable."}}}, "StudyTypeListingModel": {"title": "Study Type model for listing", "type": "object", "properties": {"studyTypeCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "studyTypeNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "trialTypesCodes": {"title": "Trialtypescodes", "type": "array", "items": {"$ref": "#/components/schemas/SimpleListingCTModel"}}, "trialTypesNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "trialPhaseCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "trialPhaseNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "isExtensionTrial": {"title": "Isextensiontrial", "type": "boolean"}, "isExtensionTrialNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "isAdaptiveDesign": {"title": "Isadaptivedesign", "type": "boolean"}, "isAdaptiveDesignNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "studyStopRules": {"title": "Studystoprules", "type": "string"}, "studyStopRulesNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "confirmedResponseMinimumDuration": {"title": "Confirmedresponseminimumduration", "type": "string"}, "confirmedResponseMinimumDurationNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}, "postAuthIndicator": {"title": "Postauthindicator", "type": "boolean"}, "postAuthIndicatorNullValueCode": {"$ref": "#/components/schemas/SimpleListingCTModel"}}}, "StudyVersionMetadataJsonModel": {"title": "StudyVersionMetadata", "type": "object", "properties": {"studyStatus": {"title": "Studystatus", "type": "string"}, "lockedVersionNumber": {"title": "Lockedversionnumber", "type": "integer"}, "versionTimestamp": {"title": "Versiontimestamp", "type": "string", "format": "date-time"}, "lockedVersionAuthor": {"title": "Lockedversionauthor", "type": "string"}, "lockedVersionInfo": {"title": "Lockedversioninfo", "type": "string"}}}, "StudyVisit": {"title": "StudyVisit", "required": ["studyEpochUid", "visitTypeUid", "showVisit", "visitContactModeUid", "visitClass", "isGlobalAnchorVisit", "uid", "studyUid", "studyEpochName", "epochUid", "order", "visitTypeName", "visitContactModeName", "visitNumber", "visitSubNumber", "uniqueVisitNumber", "visitSubName", "visitName", "visitShortName", "status", "startDate", "userInitials", "possibleActions"], "type": "object", "properties": {"studyEpochUid": {"title": "Studyepochuid", "type": "string"}, "visitTypeUid": {"title": "Visittypeuid", "type": "string"}, "timeReferenceUid": {"title": "Timereferenceuid", "type": "string"}, "timeValue": {"title": "Timevalue", "type": "integer"}, "timeUnitUid": {"title": "Timeunituid", "type": "string"}, "visitSubLabelCodelistUid": {"title": "Visitsublabelcodelistuid", "type": "string"}, "visitSubLabelReference": {"title": "Visitsublabelreference", "type": "string"}, "legacyVisitId": {"title": "Legacyvisitid", "type": "string"}, "legacyVisitTypeAlias": {"title": "Legacyvisittypealias", "type": "string"}, "legacyName": {"title": "Legacyname", "type": "string"}, "legacySubName": {"title": "Legacysubname", "type": "string"}, "consecutiveVisitGroup": {"title": "Consecutivevisitgroup", "type": "string"}, "showVisit": {"title": "Showvisit", "type": "boolean"}, "minVisitWindowValue": {"title": "Minvisitwindowvalue", "type": "integer", "default": -9999}, "maxVisitWindowValue": {"title": "Maxvisitwindowvalue", "type": "integer", "default": 9999}, "visitWindowUnitUid": {"title": "Visitwindowunituid", "type": "string"}, "description": {"title": "Description", "type": "string"}, "startRule": {"title": "Startrule", "type": "string"}, "endRule": {"title": "Endrule", "type": "string"}, "note": {"title": "Note", "type": "string"}, "visitContactModeUid": {"title": "Visitcontactmodeuid", "type": "string"}, "epochAllocationUid": {"title": "Epochallocationuid", "type": "string"}, "visitClass": {"title": "Visitclass", "type": "string"}, "visitSubclass": {"title": "Visitsubclass", "type": "string"}, "isGlobalAnchorVisit": {"title": "Isglobalanchorvisit", "type": "boolean"}, "uid": {"title": "Uid", "type": "string", "description": "Uid of the Visit"}, "studyUid": {"title": "Studyuid", "type": "string"}, "studyEpochName": {"title": "Studyepochname", "type": "string"}, "epochUid": {"title": "The uid of the study epoch", "type": "string", "description": "The uid of the study epoch"}, "order": {"title": "Order", "type": "integer"}, "visitTypeName": {"title": "Visittypename", "type": "string"}, "timeReferenceName": {"title": "Timereferencename", "type": "string"}, "timeUnitName": {"title": "Timeunitname", "type": "string"}, "visitContactModeName": {"title": "Visitcontactmodename", "type": "string"}, "epochAllocationName": {"title": "Epochallocationname", "type": "string"}, "durationTime": {"title": "Durationtime", "type": "number"}, "durationTimeUnit": {"title": "Durationtimeunit", "type": "string"}, "studyDayNumber": {"title": "Studydaynumber", "type": "integer"}, "studyDurationDaysLabel": {"title": "Studydurationdayslabel", "type": "string"}, "studyDayLabel": {"title": "Studydaylabel", "type": "string"}, "studyWeekNumber": {"title": "Studyweeknumber", "type": "integer"}, "studyDurationWeeksLabel": {"title": "Studydurationweekslabel", "type": "string"}, "studyWeekLabel": {"title": "Studyweeklabel", "type": "string"}, "visitNumber": {"title": "Visitnumber", "type": "integer"}, "visitSubNumber": {"title": "Visitsubnumber", "type": "integer"}, "uniqueVisitNumber": {"title": "Uniquevisitnumber", "type": "integer"}, "visitSubName": {"title": "Visitsubname", "type": "string"}, "visitSubLabel": {"title": "Visitsublabel", "type": "string"}, "visitName": {"title": "Visitname", "type": "string"}, "visitShortName": {"title": "Visitshortname", "type": "string"}, "visitWindowUnitName": {"title": "Visitwindowunitname", "type": "string"}, "status": {"title": "Status", "type": "string", "description": "Study Visit status"}, "startDate": {"title": "Creation Date", "type": "string", "description": "Study Visit creation date"}, "userInitials": {"title": "User Initials", "type": "string", "description": "Initials of user that created last modification"}, "possibleActions": {"title": "Possible actions", "type": "array", "items": {"type": "string"}, "description": "List of actions to perform on item"}, "studyActivityCount": {"title": "Studyactivitycount", "type": "integer", "description": "Count of Study Activities assigned to Study Visit"}}}, "StudyVisitCreateInput": {"title": "StudyVisitCreateInput", "required": ["studyEpochUid", "visitTypeUid", "showVisit", "visitContactModeUid", "visitClass", "isGlobalAnchorVisit"], "type": "object", "properties": {"studyEpochUid": {"title": "Studyepochuid", "type": "string"}, "visitTypeUid": {"title": "Visittypeuid", "type": "string"}, "timeReferenceUid": {"title": "Timereferenceuid", "type": "string"}, "timeValue": {"title": "Timevalue", "type": "integer"}, "timeUnitUid": {"title": "Timeunituid", "type": "string"}, "visitSubLabelCodelistUid": {"title": "Visitsublabelcodelistuid", "type": "string"}, "visitSubLabelReference": {"title": "Visitsublabelreference", "type": "string"}, "legacyVisitId": {"title": "Legacyvisitid", "type": "string"}, "legacyVisitTypeAlias": {"title": "Legacyvisittypealias", "type": "string"}, "legacyName": {"title": "Legacyname", "type": "string"}, "legacySubName": {"title": "Legacysubname", "type": "string"}, "consecutiveVisitGroup": {"title": "Consecutivevisitgroup", "type": "string"}, "showVisit": {"title": "Showvisit", "type": "boolean"}, "minVisitWindowValue": {"title": "Minvisitwindowvalue", "type": "integer", "default": -9999}, "maxVisitWindowValue": {"title": "Maxvisitwindowvalue", "type": "integer", "default": 9999}, "visitWindowUnitUid": {"title": "Visitwindowunituid", "type": "string"}, "description": {"title": "Description", "type": "string"}, "startRule": {"title": "Startrule", "type": "string"}, "endRule": {"title": "Endrule", "type": "string"}, "note": {"title": "Note", "type": "string"}, "visitContactModeUid": {"title": "Visitcontactmodeuid", "type": "string"}, "epochAllocationUid": {"title": "Epochallocationuid", "type": "string"}, "visitClass": {"title": "Visitclass", "type": "string"}, "visitSubclass": {"title": "Visitsubclass", "type": "string"}, "isGlobalAnchorVisit": {"title": "Isglobalanchorvisit", "type": "boolean"}}}, "StudyVisitEditInput": {"title": "StudyVisitEditInput", "required": ["studyEpochUid", "visitTypeUid", "showVisit", "visitContactModeUid", "visitClass", "isGlobalAnchorVisit", "uid"], "type": "object", "properties": {"studyEpochUid": {"title": "Studyepochuid", "type": "string"}, "visitTypeUid": {"title": "Visittypeuid", "type": "string"}, "timeReferenceUid": {"title": "Timereferenceuid", "type": "string"}, "timeValue": {"title": "Timevalue", "type": "integer"}, "timeUnitUid": {"title": "Timeunituid", "type": "string"}, "visitSubLabelCodelistUid": {"title": "Visitsublabelcodelistuid", "type": "string"}, "visitSubLabelReference": {"title": "Visitsublabelreference", "type": "string"}, "legacyVisitId": {"title": "Legacyvisitid", "type": "string"}, "legacyVisitTypeAlias": {"title": "Legacyvisittypealias", "type": "string"}, "legacyName": {"title": "Legacyname", "type": "string"}, "legacySubName": {"title": "Legacysubname", "type": "string"}, "consecutiveVisitGroup": {"title": "Consecutivevisitgroup", "type": "string"}, "showVisit": {"title": "Showvisit", "type": "boolean"}, "minVisitWindowValue": {"title": "Minvisitwindowvalue", "type": "integer", "default": -9999}, "maxVisitWindowValue": {"title": "Maxvisitwindowvalue", "type": "integer", "default": 9999}, "visitWindowUnitUid": {"title": "Visitwindowunituid", "type": "string"}, "description": {"title": "Description", "type": "string"}, "startRule": {"title": "Startrule", "type": "string"}, "endRule": {"title": "Endrule", "type": "string"}, "note": {"title": "Note", "type": "string"}, "visitContactModeUid": {"title": "Visitcontactmodeuid", "type": "string"}, "epochAllocationUid": {"title": "Epochallocationuid", "type": "string"}, "visitClass": {"title": "Visitclass", "type": "string"}, "visitSubclass": {"title": "Visitsubclass", "type": "string"}, "isGlobalAnchorVisit": {"title": "Isglobalanchorvisit", "type": "boolean"}, "uid": {"title": "Uid", "type": "string", "description": "Uid of the Visit"}}}, "StudyVisitListing": {"title": "StudyVisitListing", "required": ["STUDYID", "DOMAIN", "VISITNUM"], "type": "object", "properties": {"STUDYID": {"title": "Study Identifier", "type": "string", "description": "Unique identifier for a study."}, "DOMAIN": {"title": "Domain Abbreviation", "type": "string", "description": "Two-character abbreviation for the domain"}, "VISITNUM": {"title": "Visit Number", "type": "integer", "description": "1. Clinical encounter number 2. Numeric version of VISIT, used for sorting."}, "VISIT": {"title": "Visit Name", "type": "string", "description": "1. Protocol-defined description of clinical encounter. 2. May\n        be used in addition to VISITNUM and/or VISITDY as a text description of the clinical encounter."}, "VISITDY": {"title": "Planned Study Day of Visit", "type": "integer", "description": "1. Planned study day of VISIT. 2. Due to its sequential nature, used for sorting."}, "ARMCD": {"title": "Planned Arm Code", "type": "string", "description": "\n        1.ARMCD is limited to 20 characters and does not have special character restrictions. \n        The maximum length of ARMCD is longer than for other \"short\" variables to accommodate \n        the kind of values that are likely to be needed for crossover trials. For example, if \n        ARMCD values for a seven- period crossover were constructed using two-character abbreviations \n        for each treatment and separating hyphens, the length of ARMCD values would be 20. 2. If the \n        timing of Visits for a trial does not depend on which ARM a subject is in, then ARMCD should be null.\n        "}, "ARM": {"title": "Description of Planned Arm", "type": "string", "description": "1. Name given to an Arm or Treatment Group. 2. If the timing\n        of Visits for a trial does not depend on which Arm a subject is in, then Arm should be left blank."}, "TVSTRL": {"title": "Visit Start Rule", "type": "string", "description": "Rule describing when the Visit starts, in relation to the sequence of Elements."}, "TVENRL": {"title": "Visit End Rule", "type": "string", "description": "Rule describing when the Visit ends, in relation to the sequence of Elements."}}}, "StudyVisitVersion": {"title": "StudyVisitVersion", "required": ["studyEpochUid", "visitTypeUid", "showVisit", "visitContactModeUid", "visitClass", "isGlobalAnchorVisit", "uid", "studyUid", "studyEpochName", "epochUid", "order", "visitTypeName", "visitContactModeName", "visitNumber", "visitSubNumber", "uniqueVisitNumber", "visitSubName", "visitName", "visitShortName", "status", "startDate", "userInitials", "possibleActions", "changes"], "type": "object", "properties": {"studyEpochUid": {"title": "Studyepochuid", "type": "string"}, "visitTypeUid": {"title": "Visittypeuid", "type": "string"}, "timeReferenceUid": {"title": "Timereferenceuid", "type": "string"}, "timeValue": {"title": "Timevalue", "type": "integer"}, "timeUnitUid": {"title": "Timeunituid", "type": "string"}, "visitSubLabelCodelistUid": {"title": "Visitsublabelcodelistuid", "type": "string"}, "visitSubLabelReference": {"title": "Visitsublabelreference", "type": "string"}, "legacyVisitId": {"title": "Legacyvisitid", "type": "string"}, "legacyVisitTypeAlias": {"title": "Legacyvisittypealias", "type": "string"}, "legacyName": {"title": "Legacyname", "type": "string"}, "legacySubName": {"title": "Legacysubname", "type": "string"}, "consecutiveVisitGroup": {"title": "Consecutivevisitgroup", "type": "string"}, "showVisit": {"title": "Showvisit", "type": "boolean"}, "minVisitWindowValue": {"title": "Minvisitwindowvalue", "type": "integer", "default": -9999}, "maxVisitWindowValue": {"title": "Maxvisitwindowvalue", "type": "integer", "default": 9999}, "visitWindowUnitUid": {"title": "Visitwindowunituid", "type": "string"}, "description": {"title": "Description", "type": "string"}, "startRule": {"title": "Startrule", "type": "string"}, "endRule": {"title": "Endrule", "type": "string"}, "note": {"title": "Note", "type": "string"}, "visitContactModeUid": {"title": "Visitcontactmodeuid", "type": "string"}, "epochAllocationUid": {"title": "Epochallocationuid", "type": "string"}, "visitClass": {"title": "Visitclass", "type": "string"}, "visitSubclass": {"title": "Visitsubclass", "type": "string"}, "isGlobalAnchorVisit": {"title": "Isglobalanchorvisit", "type": "boolean"}, "uid": {"title": "Uid", "type": "string", "description": "Uid of the Visit"}, "studyUid": {"title": "Studyuid", "type": "string"}, "studyEpochName": {"title": "Studyepochname", "type": "string"}, "epochUid": {"title": "The uid of the study epoch", "type": "string", "description": "The uid of the study epoch"}, "order": {"title": "Order", "type": "integer"}, "visitTypeName": {"title": "Visittypename", "type": "string"}, "timeReferenceName": {"title": "Timereferencename", "type": "string"}, "timeUnitName": {"title": "Timeunitname", "type": "string"}, "visitContactModeName": {"title": "Visitcontactmodename", "type": "string"}, "epochAllocationName": {"title": "Epochallocationname", "type": "string"}, "durationTime": {"title": "Durationtime", "type": "number"}, "durationTimeUnit": {"title": "Durationtimeunit", "type": "string"}, "studyDayNumber": {"title": "Studydaynumber", "type": "integer"}, "studyDurationDaysLabel": {"title": "Studydurationdayslabel", "type": "string"}, "studyDayLabel": {"title": "Studydaylabel", "type": "string"}, "studyWeekNumber": {"title": "Studyweeknumber", "type": "integer"}, "studyDurationWeeksLabel": {"title": "Studydurationweekslabel", "type": "string"}, "studyWeekLabel": {"title": "Studyweeklabel", "type": "string"}, "visitNumber": {"title": "Visitnumber", "type": "integer"}, "visitSubNumber": {"title": "Visitsubnumber", "type": "integer"}, "uniqueVisitNumber": {"title": "Uniquevisitnumber", "type": "integer"}, "visitSubName": {"title": "Visitsubname", "type": "string"}, "visitSubLabel": {"title": "Visitsublabel", "type": "string"}, "visitName": {"title": "Visitname", "type": "string"}, "visitShortName": {"title": "Visitshortname", "type": "string"}, "visitWindowUnitName": {"title": "Visitwindowunitname", "type": "string"}, "status": {"title": "Status", "type": "string", "description": "Study Visit status"}, "startDate": {"title": "Creation Date", "type": "string", "description": "Study Visit creation date"}, "userInitials": {"title": "User Initials", "type": "string", "description": "Initials of user that created last modification"}, "possibleActions": {"title": "Possible actions", "type": "array", "items": {"type": "string"}, "description": "List of actions to perform on item"}, "studyActivityCount": {"title": "Studyactivitycount", "type": "integer", "description": "Count of Study Activities assigned to Study Visit"}, "changes": {"title": "Changes", "type": "object"}}}, "Table": {"title": "Table", "required": ["data", "meta"], "type": "object", "properties": {"data": {"title": "Table data matrix", "type": "object", "description": "Table data, rows and columns, including headers. Data can be text or any."}, "meta": {"title": "Table metadata matrix", "type": "object", "description": "Metadata for each cell as dict."}, "num_header_rows": {"title": "Number of header rows", "type": "integer", "description": "Number of rows from the beginning of the table used as column headers", "default": 0}, "num_header_columns": {"title": "Number of header columns", "type": "integer", "description": "Number of columns from the beginning of each row used as row headers", "default": 0}}}, "TableHeader": {"title": "TableHeader", "required": ["data", "spans"], "type": "object", "properties": {"data": {"title": "Cell values as text", "type": "array", "items": {"type": "string"}}, "spans": {"title": "Cell spanning", "type": "array", "items": {"type": "integer"}, "description": "1: for normal cells, N: can be merged with following N-1 cells, 0: for cells to hide (merged)"}}}, "TableWithHeaders": {"title": "TableWithHeaders", "required": ["headers", "data"], "type": "object", "properties": {"headers": {"title": "Headers", "type": "array", "items": {"$ref": "#/components/schemas/TableHeader"}}, "data": {"title": "Data", "type": "array", "items": {"type": "array", "items": {"type": "string"}}}}}, "TargetType": {"title": "TargetType", "enum": ["template", "study", "form", "item-group", "item"], "description": "\n    Enum for ODM target types\n    "}, "TemplateParameter": {"title": "TemplateParameter", "required": ["name"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name of the template parameter. E.g. 'Intervention', 'Indication', 'Activity', ..."}, "values": {"title": "values", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterValue"}, "description": "The possible values of the template parameter."}}}, "TemplateParameterMultiSelectInput": {"title": "TemplateParameterMultiSelectInput", "required": ["values"], "type": "object", "properties": {"values": {"title": "values", "type": "array", "items": {"$ref": "#/components/schemas/IndexedTemplateParameterValue"}, "description": "A list of indexed template parameter values that are used at this position in the template."}, "value": {"title": "value", "type": "number", "description": "A numeric value used at this position in the template."}, "conjunction": {"title": "conjunction", "type": "string", "description": "If the selected template parameter value has multiple values, the conjunction string to connect them. Available values are ['and', 'or', ',']."}}}, "TemplateParameterValue": {"title": "TemplateParameterValue", "required": ["uid", "name", "type"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string", "description": "The unique id of the template parameter value."}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Lipids', 'Haematology', 'Body Temperature', ..."}, "type": {"title": "type", "type": "string", "description": "the type of template parameter, E.g. 'NumericFinding', 'CategoricFinding'"}}}, "TermChangeItem": {"title": "TermChangeItem", "required": ["uid", "value_node", "change_date", "codelists"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "value_node": {"title": "Value Node", "type": "object"}, "change_date": {"title": "Change Date", "type": "string", "format": "date-time"}, "codelists": {"title": "Codelists", "type": "array", "items": {}}}}, "TermCount": {"title": "TermCount", "required": ["libraryName", "count"], "type": "object", "properties": {"libraryName": {"title": "Libraryname", "type": "string"}, "count": {"title": "Count", "type": "integer"}}}, "TextValue": {"title": "TextValue", "required": ["uid", "name", "libraryName", "templateParameter"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean"}}}, "TextValueInput": {"title": "TextValueInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "Namesentencecase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean", "default": false}}}, "TextualFinding": {"title": "TextualFinding", "required": ["uid", "name", "libraryName", "startDate", "status", "version", "changeDescription", "userInitials", "possibleActions", "topicCode", "adamParamCode", "sdtmVariable", "sdtmSubcat", "sdtmCat", "sdtmDomain", "activities", "activitySubgroups", "activityGroups"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the ActivityInstances. Actions are: 'approve', 'edit', 'newVersion'."}, "type": {"title": "type", "type": "string", "description": "The subtype of ActivityInstance"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmSubcat": {"title": "sdtmSubcat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmCat": {"title": "sdtmCat", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "sdtmDomain": {"title": "sdtmDomain", "allOf": [{"$ref": "#/components/schemas/SimpleTermModel"}]}, "activities": {"title": "activities", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity unique identifiers"}, "activitySubgroups": {"title": "activitySubgroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity sub group unique identifiers"}, "activityGroups": {"title": "activityGroups", "type": "array", "items": {"$ref": "#/components/schemas/ActivityHierarchySimpleModel"}, "description": "List of activity group unique identifiers"}, "specimen": {"$ref": "#/components/schemas/SimpleTermModel"}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "testCode": {"$ref": "#/components/schemas/SimpleTermModel"}, "maxTextLength": {"title": "Maxtextlength", "type": "integer"}, "splitTextInSuppQual": {"title": "Splittextinsuppqual", "type": "boolean"}}}, "TextualFindingCreateInput": {"title": "TextualFindingCreateInput", "required": ["name", "libraryName"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "specimen": {"title": "Specimen", "type": "string"}, "testCode": {"title": "Testcode", "type": "string"}, "maxTextLength": {"title": "Maxtextlength", "type": "integer"}, "splitTextInSuppQual": {"title": "Splittextinsuppqual", "type": "boolean"}}}, "TextualFindingEditInput": {"title": "TextualFindingEditInput", "required": ["changeDescription"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "topicCode": {"title": "topicCode", "type": "string"}, "adamParamCode": {"title": "adamParamCode", "type": "string"}, "legacyDescription": {"title": "legacyDescription", "type": "string"}, "sdtmVariable": {"title": "sdtmVariable", "type": "string"}, "sdtmSubcat": {"title": "sdtmSubcat", "type": "string"}, "sdtmCat": {"title": "sdtmCat", "type": "string"}, "sdtmDomain": {"title": "sdtmDomain", "type": "string"}, "specimen": {"title": "Specimen", "type": "string"}, "activities": {"title": "activity", "type": "array", "items": {"type": "string"}}, "changeDescription": {"title": "changeDescription", "type": "string"}, "valueSasDisplayFormat": {"title": "Valuesasdisplayformat", "type": "string"}, "testCode": {"title": "Testcode", "type": "string"}, "maxTextLength": {"title": "Maxtextlength", "type": "integer"}, "splitTextInSuppQual": {"title": "Splittextinsuppqual", "type": "boolean"}}}, "TimePoint": {"title": "TimePoint", "required": ["uid", "name", "libraryName", "templateParameter", "numericValueUid", "unitDefinitionUid", "timeReferenceUid"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean"}, "numericValueUid": {"title": "Numericvalueuid", "type": "string"}, "unitDefinitionUid": {"title": "Unitdefinitionuid", "type": "string"}, "timeReferenceUid": {"title": "Timereferenceuid", "type": "string"}}}, "TimePointInput": {"title": "TimePointInput", "required": ["numericValueUid", "unitDefinitionUid", "timeReferenceUid"], "type": "object", "properties": {"name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean", "default": false}, "numericValueUid": {"title": "Numericvalueuid", "type": "string"}, "unitDefinitionUid": {"title": "Unitdefinitionuid", "type": "string"}, "timeReferenceUid": {"title": "Timereferenceuid", "type": "string"}}}, "Timeframe": {"title": "Timeframe", "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "namePlain": {"title": "Nameplain", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the timeframe. Actions are: 'approve', 'edit', 'inactivate', 'reactivate' and 'delete'."}, "timeframeTemplate": {"$ref": "#/components/schemas/TimeframeTemplateNameUid"}, "parameterValues": {"title": "Parametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values that are used within the timeframe. The values are ordered as they occur in the timeframe name."}, "library": {"$ref": "#/components/schemas/Library"}}}, "TimeframeCreateInput": {"title": "TimeframeCreateInput", "required": ["timeframeTemplateUid"], "type": "object", "properties": {"parameterValues": {"title": "parameterValues", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterMultiSelectInput"}, "description": "An ordered list of selected parameter values that are used to replace the parameters of the timeframe template."}, "timeframeTemplateUid": {"title": "timeframeTemplateUid", "type": "string", "description": "The unique id of the timeframe template that is used as the basis for the new timeframe."}, "nameOverride": {"title": "name", "type": "string", "description": "Optionally, a name to override the name inherited from the template."}, "libraryName": {"title": "libraryName", "type": "string", "description": "If specified: The name of the library to which the timeframe will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* endpoint can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true. \n\nIf not specified: The library of the timeframe template will be used."}}}, "TimeframeEditInput": {"title": "TimeframeEditInput", "required": ["changeDescription"], "type": "object", "properties": {"parameterValues": {"title": "parameterValues", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameterMultiSelectInput"}, "description": "An ordered list of selected parameter values that are used to replace the parameters of the timeframe template."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}}}, "TimeframeTemplate": {"title": "TimeframeTemplate", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "\n            The actual value/content. It may include parameters\n            referenced by simple strings in square brackets [].\n            "}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "\n            Part of the metadata: The point in time when the\n            (version of the) timeframe template was created.\n            The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00'\n            for October 31, 2020 at 6pm in UTC+2 timezone.\n            ", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the timeframe template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) timeframe template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) timeframe template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the timeframe template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the timeframe template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the timeframe template."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the timeframe template belongs."}}}, "TimeframeTemplateCreateInput": {"title": "TimeframeTemplateCreateInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "libraryName": {"title": "Libraryname", "type": "string", "description": "If specified: The name of the library to which the timeframe template will be linked. The following rules apply: \n* The library needs to be present, it will not be created with this request. The *[GET] /libraries* endpoint can help. And \n* The library needs to allow the creation: The 'isEditable' property of the library needs to be true.", "default": "Sponsor"}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited. Defaults to False.", "default": false}}}, "TimeframeTemplateEditInput": {"title": "TimeframeTemplateEditInput", "required": ["name", "changeDescription"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}}}, "TimeframeTemplateNameInput": {"title": "TimeframeTemplateNameInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "The actual value/content. It may include parameters referenced by simple strings in square brackets []."}, "guidanceText": {"title": "Guidancetext", "type": "string", "description": "Optional guidance text for using the template."}}}, "TimeframeTemplateNameUid": {"title": "TimeframeTemplateNameUid", "required": ["uid"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "\n            The actual value/content. It may include parameters\n            referenced by simple strings in square brackets [].\n            "}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}}}, "TimeframeTemplateVersion": {"title": "TimeframeTemplateVersion", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "\n            The actual value/content. It may include parameters\n            referenced by simple strings in square brackets [].\n            "}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "\n            Part of the metadata: The point in time when the\n            (version of the) timeframe template was created.\n            The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00'\n            for October 31, 2020 at 6pm in UTC+2 timezone.\n            ", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the timeframe template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) timeframe template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) timeframe template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the timeframe template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the timeframe template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the timeframe template."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the timeframe template belongs."}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the timeframe template (e.g. name, startDate, ..)."}}, "description": "Class for storing Timeframe Templates and calculation of differences"}, "TimeframeTemplateWithCount": {"title": "TimeframeTemplateWithCount", "required": ["uid", "editableInstance"], "type": "object", "properties": {"name": {"title": "Name", "type": "string", "description": "\n            The actual value/content. It may include parameters\n            referenced by simple strings in square brackets [].\n            "}, "namePlain": {"title": "Nameplain", "type": "string", "description": "The plain text version of the name property, stripped of HTML tags"}, "uid": {"title": "Uid", "type": "string", "description": "The unique id of the timeframe template."}, "editableInstance": {"title": "Editableinstance", "type": "boolean", "description": "Indicates if the name of this template's instances can be edited."}, "startDate": {"title": "Startdate", "type": "string", "description": "\n            Part of the metadata: The point in time when the\n            (version of the) timeframe template was created.\n            The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00'\n            for October 31, 2020 at 6pm in UTC+2 timezone.\n            ", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "description": "Part of the metadata: The point in time when the version of the timeframe template was closed (and a new one was created). The format is ISO 8601 in UTC\u00b10, e.g.: '2020-10-31T16:00:00+00:00' for October 31, 2020 at 6pm in UTC+2 timezone.", "format": "date-time"}, "status": {"title": "Status", "type": "string", "description": "The status in which the (version of the) timeframe template is in. Possible values are: 'Final', 'Draft' or 'Retired'."}, "version": {"title": "Version", "type": "string", "description": "The version number of the (version of the) timeframe template. The format is: <major>.<minor> where <major> and <minor> are digits. E.g. '0.1', '0.2', '1.0', ..."}, "changeDescription": {"title": "Changedescription", "type": "string", "description": "A short description about what has changed compared to the previous version."}, "userInitials": {"title": "Userinitials", "type": "string", "description": "The initials of the user that triggered the change of the timeframe template."}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the timeframe template. Actions are: 'approve', 'edit', 'newVersion', 'inactivate', 'reactivate' and 'delete'."}, "parameters": {"title": "Parameters", "type": "array", "items": {"$ref": "#/components/schemas/TemplateParameter"}, "description": "Those parameters that are used by the timeframe template."}, "library": {"title": "Library", "allOf": [{"$ref": "#/components/schemas/Library"}], "description": "The library to which the timeframe template belongs."}, "counts": {"title": "Counts", "allOf": [{"$ref": "#/components/schemas/ItemCounts"}], "description": "Optional counts of objective instatiations"}}}, "TimeframeVersion": {"title": "TimeframeVersion", "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "namePlain": {"title": "Nameplain", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "possibleActions": {"title": "Possibleactions", "type": "array", "items": {"type": "string"}, "description": "Holds those actions that can be performed on the timeframe. Actions are: 'approve', 'edit', 'inactivate', 'reactivate' and 'delete'."}, "timeframeTemplate": {"$ref": "#/components/schemas/TimeframeTemplateNameUid"}, "parameterValues": {"title": "Parametervalues", "type": "array", "items": {"$ref": "#/components/schemas/MultiTemplateParameterValue"}, "description": "Holds the parameter values that are used within the timeframe. The values are ordered as they occur in the timeframe name."}, "library": {"$ref": "#/components/schemas/Library"}, "changes": {"title": "Changes", "type": "object", "additionalProperties": {"type": "boolean"}, "description": "Denotes whether or not there was a change in a specific field/property compared to the previous version. The field names in this object here refer to the field names of the timeframe (e.g. name, startDate, ..)."}}, "description": "Class for storing Timeframes and calculation of differences"}, "TopicCdDef": {"title": "TopicCdDef", "type": "object", "properties": {"lb": {"title": "lb", "type": "string", "description": "Label"}, "topic_cd": {"title": "topic_cd", "type": "string", "description": "Topic Code"}, "short_topic_cd": {"title": "short_topic_cd", "type": "string", "description": "Short Topic Code"}, "description": {"title": "description", "type": "string", "description": "Description"}, "molecular_weight": {"title": "molecular_weight", "type": "number", "description": "Molecular Weight"}, "sas_display_format": {"title": "sas_display_format", "type": "string", "description": "SAS Display Format"}, "general_domain_class": {"title": "general_domain_class", "type": "string", "description": "General Domain Class"}, "sub_domain_class": {"title": "sub_domain_class", "type": "string", "description": "Sub Domain Class"}, "sub_domain_type": {"title": "sub_domain_type", "type": "string", "description": "Sub Domain Type"}}}, "UnitDefinitionModel": {"title": "UnitDefinitionModel", "required": ["startDate", "status", "version", "userInitials", "changeDescription", "uid", "name", "libraryName", "convertibleUnit", "displayUnit", "masterUnit", "siUnit", "usConventionalUnit", "ctUnits", "unitSubsets", "templateParameter"], "type": "object", "properties": {"startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "uid": {"title": "Uid", "type": "string"}, "name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "convertibleUnit": {"title": "Convertibleunit", "type": "boolean"}, "displayUnit": {"title": "Displayunit", "type": "boolean"}, "masterUnit": {"title": "Masterunit", "type": "boolean"}, "siUnit": {"title": "Siunit", "type": "boolean"}, "usConventionalUnit": {"title": "Usconventionalunit", "type": "boolean"}, "ctUnits": {"title": "Ctunits", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "unitSubsets": {"title": "Unitsubsets", "type": "array", "items": {"$ref": "#/components/schemas/SimpleTermModel"}}, "ucum": {"$ref": "#/components/schemas/SimpleTermModel"}, "unitDimension": {"$ref": "#/components/schemas/SimpleTermModel"}, "legacyCode": {"title": "Legacycode", "type": "string"}, "molecularWeightConvExpon": {"title": "Molecularweightconvexpon", "type": "integer"}, "conversionFactorToMaster": {"title": "Conversionfactortomaster", "type": "number"}, "comment": {"title": "Comment", "type": "string"}, "order": {"title": "Order", "type": "integer"}, "definition": {"title": "Definition", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean"}}}, "UnitDefinitionPatchInput": {"title": "UnitDefinitionPatchInput", "required": ["changeDescription"], "type": "object", "properties": {"changeDescription": {"title": "Changedescription", "type": "string"}, "name": {"title": "Name", "type": "string"}, "convertibleUnit": {"title": "Convertibleunit", "type": "boolean"}, "displayUnit": {"title": "Displayunit", "type": "boolean"}, "masterUnit": {"title": "Masterunit", "type": "boolean"}, "siUnit": {"title": "Siunit", "type": "boolean"}, "usConventionalUnit": {"title": "Usconventionalunit", "type": "boolean"}, "ctUnits": {"title": "Ctunits", "type": "array", "items": {"type": "string"}, "default": []}, "unitSubsets": {"title": "Unitsubsets", "type": "array", "items": {"type": "string"}, "default": []}, "ucum": {"title": "Ucum", "type": "string"}, "unitDimension": {"title": "Unitdimension", "type": "string"}, "legacyCode": {"title": "Legacycode", "type": "string"}, "molecularWeightConvExpon": {"title": "Molecularweightconvexpon", "type": "integer"}, "conversionFactorToMaster": {"title": "Conversionfactortomaster", "type": "number"}, "comment": {"title": "Comment", "type": "string"}, "order": {"title": "Order", "type": "integer"}, "definition": {"title": "Definition", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean"}}}, "UnitDefinitionPostInput": {"title": "UnitDefinitionPostInput", "required": ["name", "convertibleUnit", "displayUnit", "masterUnit", "siUnit", "usConventionalUnit", "ctUnits"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string", "default": "Sponsor"}, "convertibleUnit": {"title": "Convertibleunit", "type": "boolean"}, "displayUnit": {"title": "Displayunit", "type": "boolean"}, "masterUnit": {"title": "Masterunit", "type": "boolean"}, "siUnit": {"title": "Siunit", "type": "boolean"}, "usConventionalUnit": {"title": "Usconventionalunit", "type": "boolean"}, "ctUnits": {"title": "Ctunits", "type": "array", "items": {"type": "string"}}, "unitSubsets": {"title": "Unitsubsets", "type": "array", "items": {"type": "string"}, "default": []}, "ucum": {"title": "Ucum", "type": "string"}, "unitDimension": {"title": "Unitdimension", "type": "string"}, "legacyCode": {"title": "Legacycode", "type": "string"}, "molecularWeightConvExpon": {"title": "Molecularweightconvexpon", "type": "integer"}, "conversionFactorToMaster": {"title": "Conversionfactortomaster", "type": "number"}, "comment": {"title": "Comment", "type": "string"}, "order": {"title": "Order", "type": "integer"}, "definition": {"title": "Definition", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean", "default": false}}}, "UnitDefinitionSimpleModel": {"title": "UnitDefinitionSimpleModel", "required": ["uid"], "type": "object", "properties": {"uid": {"title": "uid", "type": "string"}, "name": {"title": "name", "type": "string"}}}, "ValidationError": {"title": "ValidationError", "required": ["loc", "msg", "type"], "type": "object", "properties": {"loc": {"title": "Location", "type": "array", "items": {"anyOf": [{"type": "string"}, {"type": "integer"}]}}, "msg": {"title": "Message", "type": "string"}, "type": {"title": "Error Type", "type": "string"}}}, "VisitName": {"title": "VisitName", "required": ["uid", "name", "libraryName", "templateParameter"], "type": "object", "properties": {"uid": {"title": "Uid", "type": "string"}, "name": {"title": "name", "type": "string", "description": "The name or the actual value. E.g. 'Systolic Blood Pressure', 'Body Temperature', 'Metformin', ..."}, "nameSentenceCase": {"title": "nameSentenceCase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "startDate": {"title": "Startdate", "type": "string", "format": "date-time"}, "endDate": {"title": "Enddate", "type": "string", "format": "date-time"}, "status": {"title": "Status", "type": "string"}, "version": {"title": "Version", "type": "string"}, "changeDescription": {"title": "Changedescription", "type": "string"}, "userInitials": {"title": "Userinitials", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean"}}}, "VisitNameInput": {"title": "VisitNameInput", "required": ["name"], "type": "object", "properties": {"name": {"title": "Name", "type": "string"}, "nameSentenceCase": {"title": "Namesentencecase", "type": "string"}, "definition": {"title": "definition", "type": "string"}, "abbreviation": {"title": "Abbreviation", "type": "string"}, "libraryName": {"title": "Libraryname", "type": "string"}, "templateParameter": {"title": "Templateparameter", "type": "boolean", "default": false}}}}}}